"""
$description Global live-streaming and video hosting social platform owned by Amazon.
$url twitch.tv
$type live, vod
$webbrowser Required for getting a new :ref:`client-integrity token <cli/plugins/twitch:Client-integrity token>`.
$metadata id
$metadata author
$metadata category
$metadata title
$notes See the :ref:`Authentication <cli/plugins/twitch:Authentication>` docs on how to prevent ads.
$notes Read more about :ref:`embedded ads <cli/plugins/twitch:Embedded ads>` here.
$notes :ref:`Low latency streaming <cli/plugins/twitch:Low latency streaming>` is supported.
$notes Acquires a :ref:`client-integrity token <cli/plugins/twitch:Client-integrity token>` on streaming access token failure.
"""

from __future__ import annotations

import argparse
import logging
import math
import re
import sys
from collections import deque
from collections.abc import Mapping
from contextlib import suppress
from dataclasses import dataclass, replace as dataclass_replace
from datetime import datetime, timedelta
from json import dumps as json_dumps
from random import random
from typing import ClassVar
from urllib.parse import urlparse

from requests.exceptions import HTTPError

from streamlink.exceptions import NoStreamsError, PluginError
from streamlink.plugin import Plugin, pluginargument, pluginmatcher
from streamlink.plugin.api import validate
from streamlink.session import Streamlink
from streamlink.stream.hls import (
    M3U8,
    DateRange,
    HLSPlaylist,
    HLSSegment,
    HLSStream,
    HLSStreamReader,
    HLSStreamWorker,
    HLSStreamWriter,
    M3U8Parser,
    parse_tag,
)
from streamlink.stream.http import HTTPStream
from streamlink.utils.parse import parse_json, parse_qsd
from streamlink.utils.random import CHOICES_ALPHA_NUM, random_token
from streamlink.utils.times import fromtimestamp, hours_minutes_seconds_float
from streamlink.utils.url import update_qsd


log = logging.getLogger(__name__)

LOW_LATENCY_MAX_LIVE_EDGE = 2
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_yield_from_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = yield from mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = yield from mutants[mutant_name](*call_args, **call_kwargs)
    return result


@dataclass
class TwitchHLSSegment(HLSSegment):
    ad: bool
    prefetch: bool


class TwitchM3U8(M3U8[TwitchHLSSegment, HLSPlaylist]):
    def xǁTwitchM3U8ǁ__init____mutmut_orig(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.dateranges_ads: list[DateRange] = []
    def xǁTwitchM3U8ǁ__init____mutmut_1(self, *args, **kwargs) -> None:
        super().__init__(**kwargs)
        self.dateranges_ads: list[DateRange] = []
    def xǁTwitchM3U8ǁ__init____mutmut_2(self, *args, **kwargs) -> None:
        super().__init__(*args, )
        self.dateranges_ads: list[DateRange] = []
    def xǁTwitchM3U8ǁ__init____mutmut_3(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.dateranges_ads: list[DateRange] = None
    
    xǁTwitchM3U8ǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchM3U8ǁ__init____mutmut_1': xǁTwitchM3U8ǁ__init____mutmut_1, 
        'xǁTwitchM3U8ǁ__init____mutmut_2': xǁTwitchM3U8ǁ__init____mutmut_2, 
        'xǁTwitchM3U8ǁ__init____mutmut_3': xǁTwitchM3U8ǁ__init____mutmut_3
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchM3U8ǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁTwitchM3U8ǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁTwitchM3U8ǁ__init____mutmut_orig)
    xǁTwitchM3U8ǁ__init____mutmut_orig.__name__ = 'xǁTwitchM3U8ǁ__init__'


class TwitchM3U8Parser(M3U8Parser[TwitchM3U8, TwitchHLSSegment, HLSPlaylist]):
    __m3u8__: ClassVar[type[TwitchM3U8]] = TwitchM3U8
    __segment__: ClassVar[type[TwitchHLSSegment]] = TwitchHLSSegment

    @parse_tag("EXT-X-TWITCH-LIVE-SEQUENCE")
    def parse_ext_x_twitch_live_sequence(self, value):
        # Unset discontinuity state if the previous segment was not an ad,
        # as the following segment won't be an ad
        if self.m3u8.segments and not self.m3u8.segments[-1].ad:
            self._discontinuity = False

    @parse_tag("EXT-X-TWITCH-PREFETCH")
    def parse_tag_ext_x_twitch_prefetch(self, value):
        segments = self.m3u8.segments
        if not segments:  # pragma: no cover
            return
        last = segments[-1]

        # Use the average duration of all regular segments for the duration of prefetch segments.
        # This is better than using the duration of the last segment when regular segment durations vary a lot.
        # In low latency mode, the playlist reload time is the duration of the last segment.
        duration = last.duration if last.prefetch else sum(segment.duration for segment in segments) / float(len(segments))

        # Use the last duration for extrapolating the start time of the prefetch segment, which is needed for checking
        # whether it is an ad segment and matches the parsed date ranges or not
        date = last.date + timedelta(seconds=last.duration)

        # Always treat prefetch segments after a discontinuity as ad segments
        # (discontinuity tag inserted after last regular segment)
        # Don't reset discontinuity state: the date extrapolation might be inaccurate,
        # so all following prefetch segments should be considered an ad after a discontinuity
        ad = self._discontinuity or self._is_segment_ad(date)

        # Since we don't reset the discontinuity state in prefetch segments for the purpose of ad detection,
        # set the prefetch segment's discontinuity attribute based on ad transitions
        discontinuity = ad != last.ad

        segment = dataclass_replace(
            last,
            uri=self.uri(value),
            duration=duration,
            title=None,
            discontinuity=discontinuity,
            date=date,
            ad=ad,
            prefetch=True,
        )
        segments.append(segment)

    @parse_tag("EXT-X-DATERANGE")
    def parse_tag_ext_x_daterange(self, value):
        super().parse_tag_ext_x_daterange(value)
        daterange = self.m3u8.dateranges[-1]
        if self._is_daterange_ad(daterange):
            self.m3u8.dateranges_ads.append(daterange)

    def xǁTwitchM3U8Parserǁget_segment__mutmut_orig(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_1(self, uri: str, **data) -> TwitchHLSSegment:
        ad = None
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_2(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(None, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_3(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_4(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_5(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, )
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_6(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = None  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_7(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(None, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_8(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=None, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_9(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=None)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_10(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_11(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_12(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, )  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_13(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=True)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_14(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity or not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_15(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_16(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad or self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_17(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments or not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_18(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_19(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[+1].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_20(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-2].ad
        ):  # fmt: skip
            segment.discontinuity = False

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_21(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = None

        return segment

    def xǁTwitchM3U8Parserǁget_segment__mutmut_22(self, uri: str, **data) -> TwitchHLSSegment:
        ad = self._is_segment_ad(self._date, self._extinf.title if self._extinf else None)
        segment: TwitchHLSSegment = super().get_segment(uri, ad=ad, prefetch=False)  # type: ignore[assignment]

        # Special case where Twitch incorrectly inserts discontinuity tags between segments of the live content
        if (
            segment.discontinuity
            and not segment.ad
            and self.m3u8.segments
            and not self.m3u8.segments[-1].ad
        ):  # fmt: skip
            segment.discontinuity = True

        return segment
    
    xǁTwitchM3U8Parserǁget_segment__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchM3U8Parserǁget_segment__mutmut_1': xǁTwitchM3U8Parserǁget_segment__mutmut_1, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_2': xǁTwitchM3U8Parserǁget_segment__mutmut_2, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_3': xǁTwitchM3U8Parserǁget_segment__mutmut_3, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_4': xǁTwitchM3U8Parserǁget_segment__mutmut_4, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_5': xǁTwitchM3U8Parserǁget_segment__mutmut_5, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_6': xǁTwitchM3U8Parserǁget_segment__mutmut_6, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_7': xǁTwitchM3U8Parserǁget_segment__mutmut_7, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_8': xǁTwitchM3U8Parserǁget_segment__mutmut_8, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_9': xǁTwitchM3U8Parserǁget_segment__mutmut_9, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_10': xǁTwitchM3U8Parserǁget_segment__mutmut_10, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_11': xǁTwitchM3U8Parserǁget_segment__mutmut_11, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_12': xǁTwitchM3U8Parserǁget_segment__mutmut_12, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_13': xǁTwitchM3U8Parserǁget_segment__mutmut_13, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_14': xǁTwitchM3U8Parserǁget_segment__mutmut_14, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_15': xǁTwitchM3U8Parserǁget_segment__mutmut_15, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_16': xǁTwitchM3U8Parserǁget_segment__mutmut_16, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_17': xǁTwitchM3U8Parserǁget_segment__mutmut_17, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_18': xǁTwitchM3U8Parserǁget_segment__mutmut_18, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_19': xǁTwitchM3U8Parserǁget_segment__mutmut_19, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_20': xǁTwitchM3U8Parserǁget_segment__mutmut_20, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_21': xǁTwitchM3U8Parserǁget_segment__mutmut_21, 
        'xǁTwitchM3U8Parserǁget_segment__mutmut_22': xǁTwitchM3U8Parserǁget_segment__mutmut_22
    }
    
    def get_segment(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchM3U8Parserǁget_segment__mutmut_orig"), object.__getattribute__(self, "xǁTwitchM3U8Parserǁget_segment__mutmut_mutants"), args, kwargs, self)
        return result 
    
    get_segment.__signature__ = _mutmut_signature(xǁTwitchM3U8Parserǁget_segment__mutmut_orig)
    xǁTwitchM3U8Parserǁget_segment__mutmut_orig.__name__ = 'xǁTwitchM3U8Parserǁget_segment'

    def xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_orig(self, date: datetime | None, title: str | None = None) -> bool:
        return (
            title is not None and "Amazon" in title
            or any(self.m3u8.is_date_in_daterange(date, daterange) for daterange in self.m3u8.dateranges_ads)
        )  # fmt: skip

    def xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_1(self, date: datetime | None, title: str | None = None) -> bool:
        return (
            title is None and "Amazon" in title
            or any(self.m3u8.is_date_in_daterange(date, daterange) for daterange in self.m3u8.dateranges_ads)
        )  # fmt: skip

    def xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_2(self, date: datetime | None, title: str | None = None) -> bool:
        return (
            title is not None or "Amazon" in title
            or any(self.m3u8.is_date_in_daterange(date, daterange) for daterange in self.m3u8.dateranges_ads)
        )  # fmt: skip

    def xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_3(self, date: datetime | None, title: str | None = None) -> bool:
        return (
            title is not None and "XXAmazonXX" in title
            or any(self.m3u8.is_date_in_daterange(date, daterange) for daterange in self.m3u8.dateranges_ads)
        )  # fmt: skip

    def xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_4(self, date: datetime | None, title: str | None = None) -> bool:
        return (
            title is not None and "amazon" in title
            or any(self.m3u8.is_date_in_daterange(date, daterange) for daterange in self.m3u8.dateranges_ads)
        )  # fmt: skip

    def xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_5(self, date: datetime | None, title: str | None = None) -> bool:
        return (
            title is not None and "AMAZON" in title
            or any(self.m3u8.is_date_in_daterange(date, daterange) for daterange in self.m3u8.dateranges_ads)
        )  # fmt: skip

    def xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_6(self, date: datetime | None, title: str | None = None) -> bool:
        return (
            title is not None and "Amazon" not in title
            or any(self.m3u8.is_date_in_daterange(date, daterange) for daterange in self.m3u8.dateranges_ads)
        )  # fmt: skip

    def xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_7(self, date: datetime | None, title: str | None = None) -> bool:
        return (
            title is not None and "Amazon" in title and any(self.m3u8.is_date_in_daterange(date, daterange) for daterange in self.m3u8.dateranges_ads)
        )  # fmt: skip

    def xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_8(self, date: datetime | None, title: str | None = None) -> bool:
        return (
            title is not None and "Amazon" in title
            or any(None)
        )  # fmt: skip

    def xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_9(self, date: datetime | None, title: str | None = None) -> bool:
        return (
            title is not None and "Amazon" in title
            or any(self.m3u8.is_date_in_daterange(None, daterange) for daterange in self.m3u8.dateranges_ads)
        )  # fmt: skip

    def xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_10(self, date: datetime | None, title: str | None = None) -> bool:
        return (
            title is not None and "Amazon" in title
            or any(self.m3u8.is_date_in_daterange(date, None) for daterange in self.m3u8.dateranges_ads)
        )  # fmt: skip

    def xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_11(self, date: datetime | None, title: str | None = None) -> bool:
        return (
            title is not None and "Amazon" in title
            or any(self.m3u8.is_date_in_daterange(daterange) for daterange in self.m3u8.dateranges_ads)
        )  # fmt: skip

    def xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_12(self, date: datetime | None, title: str | None = None) -> bool:
        return (
            title is not None and "Amazon" in title
            or any(self.m3u8.is_date_in_daterange(date, ) for daterange in self.m3u8.dateranges_ads)
        )  # fmt: skip
    
    xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_1': xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_1, 
        'xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_2': xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_2, 
        'xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_3': xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_3, 
        'xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_4': xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_4, 
        'xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_5': xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_5, 
        'xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_6': xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_6, 
        'xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_7': xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_7, 
        'xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_8': xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_8, 
        'xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_9': xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_9, 
        'xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_10': xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_10, 
        'xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_11': xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_11, 
        'xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_12': xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_12
    }
    
    def _is_segment_ad(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_orig"), object.__getattribute__(self, "xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_mutants"), args, kwargs, self)
        return result 
    
    _is_segment_ad.__signature__ = _mutmut_signature(xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_orig)
    xǁTwitchM3U8Parserǁ_is_segment_ad__mutmut_orig.__name__ = 'xǁTwitchM3U8Parserǁ_is_segment_ad'

    @staticmethod
    def _is_daterange_ad(daterange: DateRange) -> bool:
        return (
            daterange.classname == "twitch-stitched-ad"
            or str(daterange.id or "").startswith("stitched-ad-")
            or any(attr_key.startswith("X-TV-TWITCH-AD-") for attr_key in daterange.x.keys())
        )


class TwitchHLSStreamWorker(HLSStreamWorker):
    reader: TwitchHLSStreamReader
    writer: TwitchHLSStreamWriter
    stream: TwitchHLSStream

    def xǁTwitchHLSStreamWorkerǁ__init____mutmut_orig(self, reader, *args, **kwargs) -> None:
        self.had_content: bool = False
        self.logged_ads: deque[str] = deque(maxlen=10)
        super().__init__(reader, *args, **kwargs)

    def xǁTwitchHLSStreamWorkerǁ__init____mutmut_1(self, reader, *args, **kwargs) -> None:
        self.had_content: bool = None
        self.logged_ads: deque[str] = deque(maxlen=10)
        super().__init__(reader, *args, **kwargs)

    def xǁTwitchHLSStreamWorkerǁ__init____mutmut_2(self, reader, *args, **kwargs) -> None:
        self.had_content: bool = True
        self.logged_ads: deque[str] = deque(maxlen=10)
        super().__init__(reader, *args, **kwargs)

    def xǁTwitchHLSStreamWorkerǁ__init____mutmut_3(self, reader, *args, **kwargs) -> None:
        self.had_content: bool = False
        self.logged_ads: deque[str] = None
        super().__init__(reader, *args, **kwargs)

    def xǁTwitchHLSStreamWorkerǁ__init____mutmut_4(self, reader, *args, **kwargs) -> None:
        self.had_content: bool = False
        self.logged_ads: deque[str] = deque(maxlen=None)
        super().__init__(reader, *args, **kwargs)

    def xǁTwitchHLSStreamWorkerǁ__init____mutmut_5(self, reader, *args, **kwargs) -> None:
        self.had_content: bool = False
        self.logged_ads: deque[str] = deque(maxlen=11)
        super().__init__(reader, *args, **kwargs)

    def xǁTwitchHLSStreamWorkerǁ__init____mutmut_6(self, reader, *args, **kwargs) -> None:
        self.had_content: bool = False
        self.logged_ads: deque[str] = deque(maxlen=10)
        super().__init__(None, *args, **kwargs)

    def xǁTwitchHLSStreamWorkerǁ__init____mutmut_7(self, reader, *args, **kwargs) -> None:
        self.had_content: bool = False
        self.logged_ads: deque[str] = deque(maxlen=10)
        super().__init__(*args, **kwargs)

    def xǁTwitchHLSStreamWorkerǁ__init____mutmut_8(self, reader, *args, **kwargs) -> None:
        self.had_content: bool = False
        self.logged_ads: deque[str] = deque(maxlen=10)
        super().__init__(reader, **kwargs)

    def xǁTwitchHLSStreamWorkerǁ__init____mutmut_9(self, reader, *args, **kwargs) -> None:
        self.had_content: bool = False
        self.logged_ads: deque[str] = deque(maxlen=10)
        super().__init__(reader, *args, )
    
    xǁTwitchHLSStreamWorkerǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchHLSStreamWorkerǁ__init____mutmut_1': xǁTwitchHLSStreamWorkerǁ__init____mutmut_1, 
        'xǁTwitchHLSStreamWorkerǁ__init____mutmut_2': xǁTwitchHLSStreamWorkerǁ__init____mutmut_2, 
        'xǁTwitchHLSStreamWorkerǁ__init____mutmut_3': xǁTwitchHLSStreamWorkerǁ__init____mutmut_3, 
        'xǁTwitchHLSStreamWorkerǁ__init____mutmut_4': xǁTwitchHLSStreamWorkerǁ__init____mutmut_4, 
        'xǁTwitchHLSStreamWorkerǁ__init____mutmut_5': xǁTwitchHLSStreamWorkerǁ__init____mutmut_5, 
        'xǁTwitchHLSStreamWorkerǁ__init____mutmut_6': xǁTwitchHLSStreamWorkerǁ__init____mutmut_6, 
        'xǁTwitchHLSStreamWorkerǁ__init____mutmut_7': xǁTwitchHLSStreamWorkerǁ__init____mutmut_7, 
        'xǁTwitchHLSStreamWorkerǁ__init____mutmut_8': xǁTwitchHLSStreamWorkerǁ__init____mutmut_8, 
        'xǁTwitchHLSStreamWorkerǁ__init____mutmut_9': xǁTwitchHLSStreamWorkerǁ__init____mutmut_9
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchHLSStreamWorkerǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁTwitchHLSStreamWorkerǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁTwitchHLSStreamWorkerǁ__init____mutmut_orig)
    xǁTwitchHLSStreamWorkerǁ__init____mutmut_orig.__name__ = 'xǁTwitchHLSStreamWorkerǁ__init__'

    def xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_orig(self, playlist: TwitchM3U8):  # type: ignore[override]
        if self.stream.low_latency and playlist.segments:
            return playlist.segments[-1].duration

        return super()._playlist_reload_time(playlist)

    def xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_1(self, playlist: TwitchM3U8):  # type: ignore[override]
        if self.stream.low_latency or playlist.segments:
            return playlist.segments[-1].duration

        return super()._playlist_reload_time(playlist)

    def xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_2(self, playlist: TwitchM3U8):  # type: ignore[override]
        if self.stream.low_latency and playlist.segments:
            return playlist.segments[+1].duration

        return super()._playlist_reload_time(playlist)

    def xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_3(self, playlist: TwitchM3U8):  # type: ignore[override]
        if self.stream.low_latency and playlist.segments:
            return playlist.segments[-2].duration

        return super()._playlist_reload_time(playlist)

    def xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_4(self, playlist: TwitchM3U8):  # type: ignore[override]
        if self.stream.low_latency and playlist.segments:
            return playlist.segments[-1].duration

        return super()._playlist_reload_time(None)
    
    xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_1': xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_1, 
        'xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_2': xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_2, 
        'xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_3': xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_3, 
        'xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_4': xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_4
    }
    
    def _playlist_reload_time(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_orig"), object.__getattribute__(self, "xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_mutants"), args, kwargs, self)
        return result 
    
    _playlist_reload_time.__signature__ = _mutmut_signature(xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_orig)
    xǁTwitchHLSStreamWorkerǁ_playlist_reload_time__mutmut_orig.__name__ = 'xǁTwitchHLSStreamWorkerǁ_playlist_reload_time'

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_orig(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_1(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_2(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = None

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_3(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_4(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_5(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = None

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_6(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next(None, False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_7(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), None)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_8(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next(False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_9(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), )

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_10(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((False for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_11(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_12(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), True)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_13(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency or self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_14(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content or not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_15(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_16(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next(None, False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_17(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), None)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_18(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next(False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_19(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), )
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_20(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((False for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_21(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), True)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_22(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info(None)

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_23(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("XXThis is not a low latency streamXX")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_24(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("this is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_25(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("THIS IS NOT A LOW LATENCY STREAM")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_26(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads or self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_27(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence != -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_28(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == +1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_29(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -2 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_30(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 or not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_31(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_32(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info(None)

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_33(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("XXWaiting for pre-roll ads to finish, be patientXX")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_34(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_35(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("WAITING FOR PRE-ROLL ADS TO FINISH, BE PATIENT")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_36(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_37(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                break

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_38(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = None  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_39(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get(None)
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_40(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("XXX-TV-TWITCH-AD-COMMERCIAL-IDXX")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_41(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("x-tv-twitch-ad-commercial-id")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_42(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-tv-twitch-ad-commercial-id")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_43(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID") and daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_44(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get(None)
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_45(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("XXX-TV-TWITCH-AD-ROLL-TYPEXX")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_46(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("x-tv-twitch-ad-roll-type")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_47(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-tv-twitch-ad-roll-type")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_48(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_49(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id and ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_50(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id not in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_51(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                break
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_52(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(None)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_53(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = None
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_54(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(None)
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_55(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(None))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_56(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get(None, "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_57(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", None)))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_58(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_59(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", )))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_60(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("XXX-TV-TWITCH-AD-POD-FILLED-DURATIONXX", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_61(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("x-tv-twitch-ad-pod-filled-duration", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_62(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-tv-twitch-ad-pod-filled-duration", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_63(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "XXXX")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_64(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = None

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_65(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(None)

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_66(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(None)

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_67(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'XXsXX' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_68(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'S' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_69(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'S' if duration != 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_70(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration == 1 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_71(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 2 else ''}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_72(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else 'XXXX'}")

        return super().process_segments(playlist)

    def xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_73(self, playlist: TwitchM3U8):  # type: ignore[override]
        # ignore prefetch segments if not LL streaming
        if not self.stream.low_latency:
            playlist.segments = [segment for segment in playlist.segments if not segment.prefetch]

        # check for sequences with real content
        if not self.had_content:
            self.had_content = next((True for segment in playlist.segments if not segment.ad), False)

            # When filtering ads, to check whether it's a LL stream, we need to wait for the real content to show up,
            # since playlists with only ad segments don't contain prefetch segments
            if (
                self.stream.low_latency
                and self.had_content
                and not next((True for segment in playlist.segments if segment.prefetch), False)
            ):
                log.info("This is not a low latency stream")

        # show pre-roll ads message only on the first playlist containing ads
        if self.stream.disable_ads and self.playlist_sequence == -1 and not self.had_content:
            log.info("Waiting for pre-roll ads to finish, be patient")

        # log the duration of whole advertisement breaks
        for daterange_ads in playlist.dateranges_ads:
            if not daterange_ads.duration:  # pragma: no cover
                continue

            ads_id: str | None = (
                daterange_ads.x.get("X-TV-TWITCH-AD-COMMERCIAL-ID")
                or daterange_ads.x.get("X-TV-TWITCH-AD-ROLL-TYPE")
            )  # fmt: skip
            if not ads_id or ads_id in self.logged_ads:
                continue
            self.logged_ads.append(ads_id)

            # use Twitch's own ads duration metadata if available
            try:
                duration = math.ceil(float(daterange_ads.x.get("X-TV-TWITCH-AD-POD-FILLED-DURATION", "")))
            except ValueError:
                duration = math.ceil(daterange_ads.duration.total_seconds())

            log.info(f"Detected advertisement break of {duration} second{'s' if duration != 1 else ''}")

        return super().process_segments(None)
    
    xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_1': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_1, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_2': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_2, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_3': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_3, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_4': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_4, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_5': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_5, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_6': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_6, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_7': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_7, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_8': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_8, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_9': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_9, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_10': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_10, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_11': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_11, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_12': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_12, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_13': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_13, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_14': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_14, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_15': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_15, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_16': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_16, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_17': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_17, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_18': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_18, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_19': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_19, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_20': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_20, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_21': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_21, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_22': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_22, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_23': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_23, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_24': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_24, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_25': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_25, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_26': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_26, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_27': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_27, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_28': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_28, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_29': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_29, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_30': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_30, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_31': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_31, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_32': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_32, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_33': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_33, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_34': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_34, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_35': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_35, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_36': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_36, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_37': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_37, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_38': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_38, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_39': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_39, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_40': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_40, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_41': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_41, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_42': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_42, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_43': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_43, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_44': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_44, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_45': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_45, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_46': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_46, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_47': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_47, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_48': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_48, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_49': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_49, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_50': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_50, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_51': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_51, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_52': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_52, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_53': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_53, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_54': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_54, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_55': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_55, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_56': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_56, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_57': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_57, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_58': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_58, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_59': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_59, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_60': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_60, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_61': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_61, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_62': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_62, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_63': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_63, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_64': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_64, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_65': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_65, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_66': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_66, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_67': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_67, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_68': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_68, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_69': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_69, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_70': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_70, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_71': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_71, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_72': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_72, 
        'xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_73': xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_73
    }
    
    def process_segments(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_orig"), object.__getattribute__(self, "xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_mutants"), args, kwargs, self)
        return result 
    
    process_segments.__signature__ = _mutmut_signature(xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_orig)
    xǁTwitchHLSStreamWorkerǁprocess_segments__mutmut_orig.__name__ = 'xǁTwitchHLSStreamWorkerǁprocess_segments'


class TwitchHLSStreamWriter(HLSStreamWriter):
    reader: TwitchHLSStreamReader
    stream: TwitchHLSStream

    def xǁTwitchHLSStreamWriterǁshould_filter_segment__mutmut_orig(self, segment: TwitchHLSSegment) -> bool:  # type: ignore[override]
        return self.stream.disable_ads and segment.ad

    def xǁTwitchHLSStreamWriterǁshould_filter_segment__mutmut_1(self, segment: TwitchHLSSegment) -> bool:  # type: ignore[override]
        return self.stream.disable_ads or segment.ad
    
    xǁTwitchHLSStreamWriterǁshould_filter_segment__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchHLSStreamWriterǁshould_filter_segment__mutmut_1': xǁTwitchHLSStreamWriterǁshould_filter_segment__mutmut_1
    }
    
    def should_filter_segment(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchHLSStreamWriterǁshould_filter_segment__mutmut_orig"), object.__getattribute__(self, "xǁTwitchHLSStreamWriterǁshould_filter_segment__mutmut_mutants"), args, kwargs, self)
        return result 
    
    should_filter_segment.__signature__ = _mutmut_signature(xǁTwitchHLSStreamWriterǁshould_filter_segment__mutmut_orig)
    xǁTwitchHLSStreamWriterǁshould_filter_segment__mutmut_orig.__name__ = 'xǁTwitchHLSStreamWriterǁshould_filter_segment'


class TwitchHLSStreamReader(HLSStreamReader):
    __worker__ = TwitchHLSStreamWorker
    __writer__ = TwitchHLSStreamWriter

    worker: TwitchHLSStreamWorker
    writer: TwitchHLSStreamWriter
    stream: TwitchHLSStream

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_orig(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_1(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info(None)
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_2(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("XXWill skip ad segmentsXX")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_3(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_4(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("WILL SKIP AD SEGMENTS")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_5(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = None
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_6(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(None, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_7(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, None)
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_8(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_9(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, )
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_10(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(2, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_11(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(None, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_12(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, None))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_13(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_14(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, ))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_15(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get(None)))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_16(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("XXhls-live-edgeXX")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_17(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("HLS-LIVE-EDGE")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_18(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("Hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_19(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set(None, live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_20(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", None)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_21(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set(live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_22(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", )
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_23(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("XXhls-live-edgeXX", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_24(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("HLS-LIVE-EDGE", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_25(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("Hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_26(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set(None, True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_27(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", None)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_28(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set(True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_29(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", )
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_30(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("XXhls-segment-stream-dataXX", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_31(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("HLS-SEGMENT-STREAM-DATA", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_32(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("Hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_33(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", False)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_34(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(None)

        super().__init__(stream, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_35(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(None, **kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_36(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(**kwargs)

    def xǁTwitchHLSStreamReaderǁ__init____mutmut_37(self, stream: TwitchHLSStream, **kwargs):
        if stream.disable_ads:
            log.info("Will skip ad segments")
        if stream.low_latency:
            live_edge = max(1, min(LOW_LATENCY_MAX_LIVE_EDGE, stream.session.options.get("hls-live-edge")))
            stream.session.options.set("hls-live-edge", live_edge)
            stream.session.options.set("hls-segment-stream-data", True)
            log.info(f"Low latency streaming (HLS live edge: {live_edge})")

        super().__init__(stream, )
    
    xǁTwitchHLSStreamReaderǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchHLSStreamReaderǁ__init____mutmut_1': xǁTwitchHLSStreamReaderǁ__init____mutmut_1, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_2': xǁTwitchHLSStreamReaderǁ__init____mutmut_2, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_3': xǁTwitchHLSStreamReaderǁ__init____mutmut_3, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_4': xǁTwitchHLSStreamReaderǁ__init____mutmut_4, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_5': xǁTwitchHLSStreamReaderǁ__init____mutmut_5, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_6': xǁTwitchHLSStreamReaderǁ__init____mutmut_6, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_7': xǁTwitchHLSStreamReaderǁ__init____mutmut_7, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_8': xǁTwitchHLSStreamReaderǁ__init____mutmut_8, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_9': xǁTwitchHLSStreamReaderǁ__init____mutmut_9, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_10': xǁTwitchHLSStreamReaderǁ__init____mutmut_10, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_11': xǁTwitchHLSStreamReaderǁ__init____mutmut_11, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_12': xǁTwitchHLSStreamReaderǁ__init____mutmut_12, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_13': xǁTwitchHLSStreamReaderǁ__init____mutmut_13, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_14': xǁTwitchHLSStreamReaderǁ__init____mutmut_14, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_15': xǁTwitchHLSStreamReaderǁ__init____mutmut_15, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_16': xǁTwitchHLSStreamReaderǁ__init____mutmut_16, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_17': xǁTwitchHLSStreamReaderǁ__init____mutmut_17, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_18': xǁTwitchHLSStreamReaderǁ__init____mutmut_18, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_19': xǁTwitchHLSStreamReaderǁ__init____mutmut_19, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_20': xǁTwitchHLSStreamReaderǁ__init____mutmut_20, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_21': xǁTwitchHLSStreamReaderǁ__init____mutmut_21, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_22': xǁTwitchHLSStreamReaderǁ__init____mutmut_22, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_23': xǁTwitchHLSStreamReaderǁ__init____mutmut_23, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_24': xǁTwitchHLSStreamReaderǁ__init____mutmut_24, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_25': xǁTwitchHLSStreamReaderǁ__init____mutmut_25, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_26': xǁTwitchHLSStreamReaderǁ__init____mutmut_26, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_27': xǁTwitchHLSStreamReaderǁ__init____mutmut_27, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_28': xǁTwitchHLSStreamReaderǁ__init____mutmut_28, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_29': xǁTwitchHLSStreamReaderǁ__init____mutmut_29, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_30': xǁTwitchHLSStreamReaderǁ__init____mutmut_30, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_31': xǁTwitchHLSStreamReaderǁ__init____mutmut_31, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_32': xǁTwitchHLSStreamReaderǁ__init____mutmut_32, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_33': xǁTwitchHLSStreamReaderǁ__init____mutmut_33, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_34': xǁTwitchHLSStreamReaderǁ__init____mutmut_34, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_35': xǁTwitchHLSStreamReaderǁ__init____mutmut_35, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_36': xǁTwitchHLSStreamReaderǁ__init____mutmut_36, 
        'xǁTwitchHLSStreamReaderǁ__init____mutmut_37': xǁTwitchHLSStreamReaderǁ__init____mutmut_37
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchHLSStreamReaderǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁTwitchHLSStreamReaderǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁTwitchHLSStreamReaderǁ__init____mutmut_orig)
    xǁTwitchHLSStreamReaderǁ__init____mutmut_orig.__name__ = 'xǁTwitchHLSStreamReaderǁ__init__'


class TwitchHLSStream(HLSStream):
    __reader__ = TwitchHLSStreamReader
    __parser__ = TwitchM3U8Parser

    def xǁTwitchHLSStreamǁ__init____mutmut_orig(self, *args, disable_ads: bool = False, low_latency: bool = False, **kwargs):
        super().__init__(*args, **kwargs)
        self.disable_ads = disable_ads
        self.low_latency = low_latency

    def xǁTwitchHLSStreamǁ__init____mutmut_1(self, *args, disable_ads: bool = True, low_latency: bool = False, **kwargs):
        super().__init__(*args, **kwargs)
        self.disable_ads = disable_ads
        self.low_latency = low_latency

    def xǁTwitchHLSStreamǁ__init____mutmut_2(self, *args, disable_ads: bool = False, low_latency: bool = True, **kwargs):
        super().__init__(*args, **kwargs)
        self.disable_ads = disable_ads
        self.low_latency = low_latency

    def xǁTwitchHLSStreamǁ__init____mutmut_3(self, *args, disable_ads: bool = False, low_latency: bool = False, **kwargs):
        super().__init__(**kwargs)
        self.disable_ads = disable_ads
        self.low_latency = low_latency

    def xǁTwitchHLSStreamǁ__init____mutmut_4(self, *args, disable_ads: bool = False, low_latency: bool = False, **kwargs):
        super().__init__(*args, )
        self.disable_ads = disable_ads
        self.low_latency = low_latency

    def xǁTwitchHLSStreamǁ__init____mutmut_5(self, *args, disable_ads: bool = False, low_latency: bool = False, **kwargs):
        super().__init__(*args, **kwargs)
        self.disable_ads = None
        self.low_latency = low_latency

    def xǁTwitchHLSStreamǁ__init____mutmut_6(self, *args, disable_ads: bool = False, low_latency: bool = False, **kwargs):
        super().__init__(*args, **kwargs)
        self.disable_ads = disable_ads
        self.low_latency = None
    
    xǁTwitchHLSStreamǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchHLSStreamǁ__init____mutmut_1': xǁTwitchHLSStreamǁ__init____mutmut_1, 
        'xǁTwitchHLSStreamǁ__init____mutmut_2': xǁTwitchHLSStreamǁ__init____mutmut_2, 
        'xǁTwitchHLSStreamǁ__init____mutmut_3': xǁTwitchHLSStreamǁ__init____mutmut_3, 
        'xǁTwitchHLSStreamǁ__init____mutmut_4': xǁTwitchHLSStreamǁ__init____mutmut_4, 
        'xǁTwitchHLSStreamǁ__init____mutmut_5': xǁTwitchHLSStreamǁ__init____mutmut_5, 
        'xǁTwitchHLSStreamǁ__init____mutmut_6': xǁTwitchHLSStreamǁ__init____mutmut_6
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchHLSStreamǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁTwitchHLSStreamǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁTwitchHLSStreamǁ__init____mutmut_orig)
    xǁTwitchHLSStreamǁ__init____mutmut_orig.__name__ = 'xǁTwitchHLSStreamǁ__init__'


class UsherService:
    def xǁUsherServiceǁ__init____mutmut_orig(self, session):
        self.session = session
    def xǁUsherServiceǁ__init____mutmut_1(self, session):
        self.session = None
    
    xǁUsherServiceǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁUsherServiceǁ__init____mutmut_1': xǁUsherServiceǁ__init____mutmut_1
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁUsherServiceǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁUsherServiceǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁUsherServiceǁ__init____mutmut_orig)
    xǁUsherServiceǁ__init____mutmut_orig.__name__ = 'xǁUsherServiceǁ__init__'

    def xǁUsherServiceǁ_create_url__mutmut_orig(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_1(self, endpoint, **extra_params):
        url = None
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_2(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = None
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_3(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "XXplayerXX": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_4(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "PLAYER": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_5(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "Player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_6(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "XXtwitchwebXX",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_7(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "TWITCHWEB",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_8(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "Twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_9(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "XXpXX": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_10(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "P": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_11(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "P": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_12(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(None),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_13(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() / 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_14(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 1000000),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_15(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "XXtypeXX": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_16(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "TYPE": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_17(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "Type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_18(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "XXanyXX",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_19(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "ANY",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_20(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "Any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_21(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "XXallow_sourceXX": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_22(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "ALLOW_SOURCE": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_23(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "Allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_24(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "XXtrueXX",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_25(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "TRUE",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_26(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "True",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_27(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "XXallow_audio_onlyXX": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_28(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "ALLOW_AUDIO_ONLY": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_29(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "Allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_30(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "XXtrueXX",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_31(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "TRUE",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_32(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "True",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_33(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "XXallow_spectreXX": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_34(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "ALLOW_SPECTRE": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_35(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "Allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_36(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "XXfalseXX",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_37(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "FALSE",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_38(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "False",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_39(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(None)

        req = self.session.http.prepare_new_request(url=url, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_40(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = None

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_41(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=None, params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_42(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, params=None)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_43(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(params=params)

        return req.url

    def xǁUsherServiceǁ_create_url__mutmut_44(self, endpoint, **extra_params):
        url = f"https://usher.ttvnw.net{endpoint}"
        params = {
            "player": "twitchweb",
            "p": int(random() * 999999),
            "type": "any",
            "allow_source": "true",
            "allow_audio_only": "true",
            "allow_spectre": "false",
        }
        params.update(extra_params)

        req = self.session.http.prepare_new_request(url=url, )

        return req.url
    
    xǁUsherServiceǁ_create_url__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁUsherServiceǁ_create_url__mutmut_1': xǁUsherServiceǁ_create_url__mutmut_1, 
        'xǁUsherServiceǁ_create_url__mutmut_2': xǁUsherServiceǁ_create_url__mutmut_2, 
        'xǁUsherServiceǁ_create_url__mutmut_3': xǁUsherServiceǁ_create_url__mutmut_3, 
        'xǁUsherServiceǁ_create_url__mutmut_4': xǁUsherServiceǁ_create_url__mutmut_4, 
        'xǁUsherServiceǁ_create_url__mutmut_5': xǁUsherServiceǁ_create_url__mutmut_5, 
        'xǁUsherServiceǁ_create_url__mutmut_6': xǁUsherServiceǁ_create_url__mutmut_6, 
        'xǁUsherServiceǁ_create_url__mutmut_7': xǁUsherServiceǁ_create_url__mutmut_7, 
        'xǁUsherServiceǁ_create_url__mutmut_8': xǁUsherServiceǁ_create_url__mutmut_8, 
        'xǁUsherServiceǁ_create_url__mutmut_9': xǁUsherServiceǁ_create_url__mutmut_9, 
        'xǁUsherServiceǁ_create_url__mutmut_10': xǁUsherServiceǁ_create_url__mutmut_10, 
        'xǁUsherServiceǁ_create_url__mutmut_11': xǁUsherServiceǁ_create_url__mutmut_11, 
        'xǁUsherServiceǁ_create_url__mutmut_12': xǁUsherServiceǁ_create_url__mutmut_12, 
        'xǁUsherServiceǁ_create_url__mutmut_13': xǁUsherServiceǁ_create_url__mutmut_13, 
        'xǁUsherServiceǁ_create_url__mutmut_14': xǁUsherServiceǁ_create_url__mutmut_14, 
        'xǁUsherServiceǁ_create_url__mutmut_15': xǁUsherServiceǁ_create_url__mutmut_15, 
        'xǁUsherServiceǁ_create_url__mutmut_16': xǁUsherServiceǁ_create_url__mutmut_16, 
        'xǁUsherServiceǁ_create_url__mutmut_17': xǁUsherServiceǁ_create_url__mutmut_17, 
        'xǁUsherServiceǁ_create_url__mutmut_18': xǁUsherServiceǁ_create_url__mutmut_18, 
        'xǁUsherServiceǁ_create_url__mutmut_19': xǁUsherServiceǁ_create_url__mutmut_19, 
        'xǁUsherServiceǁ_create_url__mutmut_20': xǁUsherServiceǁ_create_url__mutmut_20, 
        'xǁUsherServiceǁ_create_url__mutmut_21': xǁUsherServiceǁ_create_url__mutmut_21, 
        'xǁUsherServiceǁ_create_url__mutmut_22': xǁUsherServiceǁ_create_url__mutmut_22, 
        'xǁUsherServiceǁ_create_url__mutmut_23': xǁUsherServiceǁ_create_url__mutmut_23, 
        'xǁUsherServiceǁ_create_url__mutmut_24': xǁUsherServiceǁ_create_url__mutmut_24, 
        'xǁUsherServiceǁ_create_url__mutmut_25': xǁUsherServiceǁ_create_url__mutmut_25, 
        'xǁUsherServiceǁ_create_url__mutmut_26': xǁUsherServiceǁ_create_url__mutmut_26, 
        'xǁUsherServiceǁ_create_url__mutmut_27': xǁUsherServiceǁ_create_url__mutmut_27, 
        'xǁUsherServiceǁ_create_url__mutmut_28': xǁUsherServiceǁ_create_url__mutmut_28, 
        'xǁUsherServiceǁ_create_url__mutmut_29': xǁUsherServiceǁ_create_url__mutmut_29, 
        'xǁUsherServiceǁ_create_url__mutmut_30': xǁUsherServiceǁ_create_url__mutmut_30, 
        'xǁUsherServiceǁ_create_url__mutmut_31': xǁUsherServiceǁ_create_url__mutmut_31, 
        'xǁUsherServiceǁ_create_url__mutmut_32': xǁUsherServiceǁ_create_url__mutmut_32, 
        'xǁUsherServiceǁ_create_url__mutmut_33': xǁUsherServiceǁ_create_url__mutmut_33, 
        'xǁUsherServiceǁ_create_url__mutmut_34': xǁUsherServiceǁ_create_url__mutmut_34, 
        'xǁUsherServiceǁ_create_url__mutmut_35': xǁUsherServiceǁ_create_url__mutmut_35, 
        'xǁUsherServiceǁ_create_url__mutmut_36': xǁUsherServiceǁ_create_url__mutmut_36, 
        'xǁUsherServiceǁ_create_url__mutmut_37': xǁUsherServiceǁ_create_url__mutmut_37, 
        'xǁUsherServiceǁ_create_url__mutmut_38': xǁUsherServiceǁ_create_url__mutmut_38, 
        'xǁUsherServiceǁ_create_url__mutmut_39': xǁUsherServiceǁ_create_url__mutmut_39, 
        'xǁUsherServiceǁ_create_url__mutmut_40': xǁUsherServiceǁ_create_url__mutmut_40, 
        'xǁUsherServiceǁ_create_url__mutmut_41': xǁUsherServiceǁ_create_url__mutmut_41, 
        'xǁUsherServiceǁ_create_url__mutmut_42': xǁUsherServiceǁ_create_url__mutmut_42, 
        'xǁUsherServiceǁ_create_url__mutmut_43': xǁUsherServiceǁ_create_url__mutmut_43, 
        'xǁUsherServiceǁ_create_url__mutmut_44': xǁUsherServiceǁ_create_url__mutmut_44
    }
    
    def _create_url(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁUsherServiceǁ_create_url__mutmut_orig"), object.__getattribute__(self, "xǁUsherServiceǁ_create_url__mutmut_mutants"), args, kwargs, self)
        return result 
    
    _create_url.__signature__ = _mutmut_signature(xǁUsherServiceǁ_create_url__mutmut_orig)
    xǁUsherServiceǁ_create_url__mutmut_orig.__name__ = 'xǁUsherServiceǁ_create_url'

    def xǁUsherServiceǁchannel__mutmut_orig(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_1(self, channel: str, **extra_params) -> str:
        with suppress(None):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_2(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = None
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_3(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(None)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_4(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                None,
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_5(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                None,
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_6(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                None,
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_7(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_8(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_9(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_10(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get(None),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_11(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("XXtokenXX"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_12(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("TOKEN"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_13(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("Token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_14(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "XXadblockXX": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_15(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "ADBLOCK": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_16(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "Adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_17(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "XXgeoblock_reasonXX": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_18(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "GEOBLOCK_REASON": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_19(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "Geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_20(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "XXhide_adsXX": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_21(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "HIDE_ADS": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_22(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "Hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_23(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "XXserver_adsXX": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_24(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "SERVER_ADS": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_25(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "Server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_26(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "XXshow_adsXX": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_27(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "SHOW_ADS": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_28(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "Show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_29(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(None)

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", **extra_params)

    def xǁUsherServiceǁchannel__mutmut_30(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(None, **extra_params)

    def xǁUsherServiceǁchannel__mutmut_31(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(**extra_params)

    def xǁUsherServiceǁchannel__mutmut_32(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.lower()}.m3u8", )

    def xǁUsherServiceǁchannel__mutmut_33(self, channel: str, **extra_params) -> str:
        with suppress(PluginError):
            extra_params_debug = validate.Schema(
                validate.get("token"),
                validate.parse_json(),
                {
                    "adblock": bool,
                    "geoblock_reason": str,
                    "hide_ads": bool,
                    "server_ads": bool,
                    "show_ads": bool,
                },
            ).validate(extra_params)
            log.debug(f"{extra_params_debug!r}")

        return self._create_url(f"/api/channel/hls/{channel.upper()}.m3u8", **extra_params)
    
    xǁUsherServiceǁchannel__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁUsherServiceǁchannel__mutmut_1': xǁUsherServiceǁchannel__mutmut_1, 
        'xǁUsherServiceǁchannel__mutmut_2': xǁUsherServiceǁchannel__mutmut_2, 
        'xǁUsherServiceǁchannel__mutmut_3': xǁUsherServiceǁchannel__mutmut_3, 
        'xǁUsherServiceǁchannel__mutmut_4': xǁUsherServiceǁchannel__mutmut_4, 
        'xǁUsherServiceǁchannel__mutmut_5': xǁUsherServiceǁchannel__mutmut_5, 
        'xǁUsherServiceǁchannel__mutmut_6': xǁUsherServiceǁchannel__mutmut_6, 
        'xǁUsherServiceǁchannel__mutmut_7': xǁUsherServiceǁchannel__mutmut_7, 
        'xǁUsherServiceǁchannel__mutmut_8': xǁUsherServiceǁchannel__mutmut_8, 
        'xǁUsherServiceǁchannel__mutmut_9': xǁUsherServiceǁchannel__mutmut_9, 
        'xǁUsherServiceǁchannel__mutmut_10': xǁUsherServiceǁchannel__mutmut_10, 
        'xǁUsherServiceǁchannel__mutmut_11': xǁUsherServiceǁchannel__mutmut_11, 
        'xǁUsherServiceǁchannel__mutmut_12': xǁUsherServiceǁchannel__mutmut_12, 
        'xǁUsherServiceǁchannel__mutmut_13': xǁUsherServiceǁchannel__mutmut_13, 
        'xǁUsherServiceǁchannel__mutmut_14': xǁUsherServiceǁchannel__mutmut_14, 
        'xǁUsherServiceǁchannel__mutmut_15': xǁUsherServiceǁchannel__mutmut_15, 
        'xǁUsherServiceǁchannel__mutmut_16': xǁUsherServiceǁchannel__mutmut_16, 
        'xǁUsherServiceǁchannel__mutmut_17': xǁUsherServiceǁchannel__mutmut_17, 
        'xǁUsherServiceǁchannel__mutmut_18': xǁUsherServiceǁchannel__mutmut_18, 
        'xǁUsherServiceǁchannel__mutmut_19': xǁUsherServiceǁchannel__mutmut_19, 
        'xǁUsherServiceǁchannel__mutmut_20': xǁUsherServiceǁchannel__mutmut_20, 
        'xǁUsherServiceǁchannel__mutmut_21': xǁUsherServiceǁchannel__mutmut_21, 
        'xǁUsherServiceǁchannel__mutmut_22': xǁUsherServiceǁchannel__mutmut_22, 
        'xǁUsherServiceǁchannel__mutmut_23': xǁUsherServiceǁchannel__mutmut_23, 
        'xǁUsherServiceǁchannel__mutmut_24': xǁUsherServiceǁchannel__mutmut_24, 
        'xǁUsherServiceǁchannel__mutmut_25': xǁUsherServiceǁchannel__mutmut_25, 
        'xǁUsherServiceǁchannel__mutmut_26': xǁUsherServiceǁchannel__mutmut_26, 
        'xǁUsherServiceǁchannel__mutmut_27': xǁUsherServiceǁchannel__mutmut_27, 
        'xǁUsherServiceǁchannel__mutmut_28': xǁUsherServiceǁchannel__mutmut_28, 
        'xǁUsherServiceǁchannel__mutmut_29': xǁUsherServiceǁchannel__mutmut_29, 
        'xǁUsherServiceǁchannel__mutmut_30': xǁUsherServiceǁchannel__mutmut_30, 
        'xǁUsherServiceǁchannel__mutmut_31': xǁUsherServiceǁchannel__mutmut_31, 
        'xǁUsherServiceǁchannel__mutmut_32': xǁUsherServiceǁchannel__mutmut_32, 
        'xǁUsherServiceǁchannel__mutmut_33': xǁUsherServiceǁchannel__mutmut_33
    }
    
    def channel(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁUsherServiceǁchannel__mutmut_orig"), object.__getattribute__(self, "xǁUsherServiceǁchannel__mutmut_mutants"), args, kwargs, self)
        return result 
    
    channel.__signature__ = _mutmut_signature(xǁUsherServiceǁchannel__mutmut_orig)
    xǁUsherServiceǁchannel__mutmut_orig.__name__ = 'xǁUsherServiceǁchannel'

    def xǁUsherServiceǁvideo__mutmut_orig(self, video_id: str, **extra_params) -> str:
        return self._create_url(f"/vod/{video_id}", **extra_params)

    def xǁUsherServiceǁvideo__mutmut_1(self, video_id: str, **extra_params) -> str:
        return self._create_url(None, **extra_params)

    def xǁUsherServiceǁvideo__mutmut_2(self, video_id: str, **extra_params) -> str:
        return self._create_url(**extra_params)

    def xǁUsherServiceǁvideo__mutmut_3(self, video_id: str, **extra_params) -> str:
        return self._create_url(f"/vod/{video_id}", )
    
    xǁUsherServiceǁvideo__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁUsherServiceǁvideo__mutmut_1': xǁUsherServiceǁvideo__mutmut_1, 
        'xǁUsherServiceǁvideo__mutmut_2': xǁUsherServiceǁvideo__mutmut_2, 
        'xǁUsherServiceǁvideo__mutmut_3': xǁUsherServiceǁvideo__mutmut_3
    }
    
    def video(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁUsherServiceǁvideo__mutmut_orig"), object.__getattribute__(self, "xǁUsherServiceǁvideo__mutmut_mutants"), args, kwargs, self)
        return result 
    
    video.__signature__ = _mutmut_signature(xǁUsherServiceǁvideo__mutmut_orig)
    xǁUsherServiceǁvideo__mutmut_orig.__name__ = 'xǁUsherServiceǁvideo'


class TwitchAPI:
    CLIENT_ID = "kimne78kx3ncx6brgo4mv6wki5h1ko"

    def xǁTwitchAPIǁ__init____mutmut_orig(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("playerType", "embed")

    def xǁTwitchAPIǁ__init____mutmut_1(self, session, api_header=None, access_token_param=None):
        self.session = None
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("playerType", "embed")

    def xǁTwitchAPIǁ__init____mutmut_2(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = None
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("playerType", "embed")

    def xǁTwitchAPIǁ__init____mutmut_3(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "XXClient-IDXX": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("playerType", "embed")

    def xǁTwitchAPIǁ__init____mutmut_4(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "client-id": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("playerType", "embed")

    def xǁTwitchAPIǁ__init____mutmut_5(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "CLIENT-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("playerType", "embed")

    def xǁTwitchAPIǁ__init____mutmut_6(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-id": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("playerType", "embed")

    def xǁTwitchAPIǁ__init____mutmut_7(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(None))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("playerType", "embed")

    def xǁTwitchAPIǁ__init____mutmut_8(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header and []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("playerType", "embed")

    def xǁTwitchAPIǁ__init____mutmut_9(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = None
        self.access_token_params.setdefault("playerType", "embed")

    def xǁTwitchAPIǁ__init____mutmut_10(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(None)
        self.access_token_params.setdefault("playerType", "embed")

    def xǁTwitchAPIǁ__init____mutmut_11(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param and [])
        self.access_token_params.setdefault("playerType", "embed")

    def xǁTwitchAPIǁ__init____mutmut_12(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault(None, "embed")

    def xǁTwitchAPIǁ__init____mutmut_13(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("playerType", None)

    def xǁTwitchAPIǁ__init____mutmut_14(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("embed")

    def xǁTwitchAPIǁ__init____mutmut_15(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("playerType", )

    def xǁTwitchAPIǁ__init____mutmut_16(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("XXplayerTypeXX", "embed")

    def xǁTwitchAPIǁ__init____mutmut_17(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("playertype", "embed")

    def xǁTwitchAPIǁ__init____mutmut_18(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("PLAYERTYPE", "embed")

    def xǁTwitchAPIǁ__init____mutmut_19(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("Playertype", "embed")

    def xǁTwitchAPIǁ__init____mutmut_20(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("playerType", "XXembedXX")

    def xǁTwitchAPIǁ__init____mutmut_21(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("playerType", "EMBED")

    def xǁTwitchAPIǁ__init____mutmut_22(self, session, api_header=None, access_token_param=None):
        self.session = session
        self.headers = {
            "Client-ID": self.CLIENT_ID,
        }
        self.headers.update(**dict(api_header or []))
        self.access_token_params = dict(access_token_param or [])
        self.access_token_params.setdefault("playerType", "Embed")
    
    xǁTwitchAPIǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchAPIǁ__init____mutmut_1': xǁTwitchAPIǁ__init____mutmut_1, 
        'xǁTwitchAPIǁ__init____mutmut_2': xǁTwitchAPIǁ__init____mutmut_2, 
        'xǁTwitchAPIǁ__init____mutmut_3': xǁTwitchAPIǁ__init____mutmut_3, 
        'xǁTwitchAPIǁ__init____mutmut_4': xǁTwitchAPIǁ__init____mutmut_4, 
        'xǁTwitchAPIǁ__init____mutmut_5': xǁTwitchAPIǁ__init____mutmut_5, 
        'xǁTwitchAPIǁ__init____mutmut_6': xǁTwitchAPIǁ__init____mutmut_6, 
        'xǁTwitchAPIǁ__init____mutmut_7': xǁTwitchAPIǁ__init____mutmut_7, 
        'xǁTwitchAPIǁ__init____mutmut_8': xǁTwitchAPIǁ__init____mutmut_8, 
        'xǁTwitchAPIǁ__init____mutmut_9': xǁTwitchAPIǁ__init____mutmut_9, 
        'xǁTwitchAPIǁ__init____mutmut_10': xǁTwitchAPIǁ__init____mutmut_10, 
        'xǁTwitchAPIǁ__init____mutmut_11': xǁTwitchAPIǁ__init____mutmut_11, 
        'xǁTwitchAPIǁ__init____mutmut_12': xǁTwitchAPIǁ__init____mutmut_12, 
        'xǁTwitchAPIǁ__init____mutmut_13': xǁTwitchAPIǁ__init____mutmut_13, 
        'xǁTwitchAPIǁ__init____mutmut_14': xǁTwitchAPIǁ__init____mutmut_14, 
        'xǁTwitchAPIǁ__init____mutmut_15': xǁTwitchAPIǁ__init____mutmut_15, 
        'xǁTwitchAPIǁ__init____mutmut_16': xǁTwitchAPIǁ__init____mutmut_16, 
        'xǁTwitchAPIǁ__init____mutmut_17': xǁTwitchAPIǁ__init____mutmut_17, 
        'xǁTwitchAPIǁ__init____mutmut_18': xǁTwitchAPIǁ__init____mutmut_18, 
        'xǁTwitchAPIǁ__init____mutmut_19': xǁTwitchAPIǁ__init____mutmut_19, 
        'xǁTwitchAPIǁ__init____mutmut_20': xǁTwitchAPIǁ__init____mutmut_20, 
        'xǁTwitchAPIǁ__init____mutmut_21': xǁTwitchAPIǁ__init____mutmut_21, 
        'xǁTwitchAPIǁ__init____mutmut_22': xǁTwitchAPIǁ__init____mutmut_22
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchAPIǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁTwitchAPIǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁTwitchAPIǁ__init____mutmut_orig)
    xǁTwitchAPIǁ__init____mutmut_orig.__name__ = 'xǁTwitchAPIǁ__init__'

    def xǁTwitchAPIǁcall__mutmut_orig(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "https://gql.twitch.tv/gql",
            json=data,
            headers={
                **self.headers,
                **(headers or {}),
            },
            schema=validate.Schema(
                validate.parse_json(),
                schema,
            ),
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_1(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            None,
            json=data,
            headers={
                **self.headers,
                **(headers or {}),
            },
            schema=validate.Schema(
                validate.parse_json(),
                schema,
            ),
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_2(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "https://gql.twitch.tv/gql",
            json=None,
            headers={
                **self.headers,
                **(headers or {}),
            },
            schema=validate.Schema(
                validate.parse_json(),
                schema,
            ),
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_3(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "https://gql.twitch.tv/gql",
            json=data,
            headers=None,
            schema=validate.Schema(
                validate.parse_json(),
                schema,
            ),
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_4(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "https://gql.twitch.tv/gql",
            json=data,
            headers={
                **self.headers,
                **(headers or {}),
            },
            schema=None,
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_5(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            json=data,
            headers={
                **self.headers,
                **(headers or {}),
            },
            schema=validate.Schema(
                validate.parse_json(),
                schema,
            ),
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_6(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "https://gql.twitch.tv/gql",
            headers={
                **self.headers,
                **(headers or {}),
            },
            schema=validate.Schema(
                validate.parse_json(),
                schema,
            ),
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_7(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "https://gql.twitch.tv/gql",
            json=data,
            schema=validate.Schema(
                validate.parse_json(),
                schema,
            ),
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_8(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "https://gql.twitch.tv/gql",
            json=data,
            headers={
                **self.headers,
                **(headers or {}),
            },
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_9(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "https://gql.twitch.tv/gql",
            json=data,
            headers={
                **self.headers,
                **(headers or {}),
            },
            schema=validate.Schema(
                validate.parse_json(),
                schema,
            ),
            )

    def xǁTwitchAPIǁcall__mutmut_10(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "XXhttps://gql.twitch.tv/gqlXX",
            json=data,
            headers={
                **self.headers,
                **(headers or {}),
            },
            schema=validate.Schema(
                validate.parse_json(),
                schema,
            ),
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_11(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "HTTPS://GQL.TWITCH.TV/GQL",
            json=data,
            headers={
                **self.headers,
                **(headers or {}),
            },
            schema=validate.Schema(
                validate.parse_json(),
                schema,
            ),
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_12(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "Https://gql.twitch.tv/gql",
            json=data,
            headers={
                **self.headers,
                **(headers or {}),
            },
            schema=validate.Schema(
                validate.parse_json(),
                schema,
            ),
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_13(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "https://gql.twitch.tv/gql",
            json=data,
            headers={
                **self.headers,
                **(headers and {}),
            },
            schema=validate.Schema(
                validate.parse_json(),
                schema,
            ),
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_14(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "https://gql.twitch.tv/gql",
            json=data,
            headers={
                **self.headers,
                **(headers or {}),
            },
            schema=validate.Schema(
                None,
                schema,
            ),
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_15(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "https://gql.twitch.tv/gql",
            json=data,
            headers={
                **self.headers,
                **(headers or {}),
            },
            schema=validate.Schema(
                validate.parse_json(),
                None,
            ),
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_16(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "https://gql.twitch.tv/gql",
            json=data,
            headers={
                **self.headers,
                **(headers or {}),
            },
            schema=validate.Schema(
                schema,
            ),
            **kwargs,
        )

    def xǁTwitchAPIǁcall__mutmut_17(self, data, /, *, headers=None, schema, **kwargs):
        return self.session.http.post(
            "https://gql.twitch.tv/gql",
            json=data,
            headers={
                **self.headers,
                **(headers or {}),
            },
            schema=validate.Schema(
                validate.parse_json(),
                ),
            **kwargs,
        )
    
    xǁTwitchAPIǁcall__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchAPIǁcall__mutmut_1': xǁTwitchAPIǁcall__mutmut_1, 
        'xǁTwitchAPIǁcall__mutmut_2': xǁTwitchAPIǁcall__mutmut_2, 
        'xǁTwitchAPIǁcall__mutmut_3': xǁTwitchAPIǁcall__mutmut_3, 
        'xǁTwitchAPIǁcall__mutmut_4': xǁTwitchAPIǁcall__mutmut_4, 
        'xǁTwitchAPIǁcall__mutmut_5': xǁTwitchAPIǁcall__mutmut_5, 
        'xǁTwitchAPIǁcall__mutmut_6': xǁTwitchAPIǁcall__mutmut_6, 
        'xǁTwitchAPIǁcall__mutmut_7': xǁTwitchAPIǁcall__mutmut_7, 
        'xǁTwitchAPIǁcall__mutmut_8': xǁTwitchAPIǁcall__mutmut_8, 
        'xǁTwitchAPIǁcall__mutmut_9': xǁTwitchAPIǁcall__mutmut_9, 
        'xǁTwitchAPIǁcall__mutmut_10': xǁTwitchAPIǁcall__mutmut_10, 
        'xǁTwitchAPIǁcall__mutmut_11': xǁTwitchAPIǁcall__mutmut_11, 
        'xǁTwitchAPIǁcall__mutmut_12': xǁTwitchAPIǁcall__mutmut_12, 
        'xǁTwitchAPIǁcall__mutmut_13': xǁTwitchAPIǁcall__mutmut_13, 
        'xǁTwitchAPIǁcall__mutmut_14': xǁTwitchAPIǁcall__mutmut_14, 
        'xǁTwitchAPIǁcall__mutmut_15': xǁTwitchAPIǁcall__mutmut_15, 
        'xǁTwitchAPIǁcall__mutmut_16': xǁTwitchAPIǁcall__mutmut_16, 
        'xǁTwitchAPIǁcall__mutmut_17': xǁTwitchAPIǁcall__mutmut_17
    }
    
    def call(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchAPIǁcall__mutmut_orig"), object.__getattribute__(self, "xǁTwitchAPIǁcall__mutmut_mutants"), args, kwargs, self)
        return result 
    
    call.__signature__ = _mutmut_signature(xǁTwitchAPIǁcall__mutmut_orig)
    xǁTwitchAPIǁcall__mutmut_orig.__name__ = 'xǁTwitchAPIǁcall'

    @staticmethod
    def _gql_persisted_query(operationname, sha256hash, **variables):
        return {
            "operationName": operationname,
            "extensions": {
                "persistedQuery": {
                    "version": 1,
                    "sha256Hash": sha256hash,
                },
            },
            "variables": dict(**variables),
        }

    @staticmethod
    def parse_token(tokenstr):
        return parse_json(
            tokenstr,
            schema=validate.Schema(
                {
                    "chansub": {
                        "restricted_bitrates": validate.all(
                            [str],
                            validate.filter(lambda n: not re.match(r"(.+_)?archives|live|chunked", n)),
                        ),
                    },
                },
                validate.get(("chansub", "restricted_bitrates")),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_orig(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_1(self, video_id):
        query = None

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_2(self, video_id):
        query = self._gql_persisted_query(
            None,
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_3(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            None,
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_4(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin=None,  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_5(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=None,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_6(self, video_id):
        query = self._gql_persisted_query(
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_7(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_8(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_9(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_10(self, video_id):
        query = self._gql_persisted_query(
            "XXVideoMetadataXX",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_11(self, video_id):
        query = self._gql_persisted_query(
            "videometadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_12(self, video_id):
        query = self._gql_persisted_query(
            "VIDEOMETADATA",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_13(self, video_id):
        query = self._gql_persisted_query(
            "Videometadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_14(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "XXcb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806XX",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_15(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "CB3B1EB2F2D2B2F65B8389BA446EC521D76C3AA44F5424A1B1D235FE21EB4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_16(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "Cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_17(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="XXXX",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_18(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            None,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_19(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=None,
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_20(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_21(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_22(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                None,
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_23(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                None,
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_24(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                None,
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_25(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_26(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_27(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_28(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "XXdataXX": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_29(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "DATA": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_30(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "Data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_31(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "XXvideoXX": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_32(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "VIDEO": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_33(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "Video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_34(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "XXidXX": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_35(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "ID": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_36(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "Id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_37(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "XXownerXX": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_38(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "OWNER": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_39(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "Owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_40(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "XXdisplayNameXX": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_41(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayname": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_42(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "DISPLAYNAME": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_43(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "Displayname": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_44(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "XXtitleXX": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_45(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "TITLE": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_46(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "Title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_47(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "XXgameXX": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_48(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "GAME": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_49(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "Game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_50(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "XXdisplayNameXX": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_51(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayname": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_52(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "DISPLAYNAME": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_53(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "Displayname": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_54(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(None),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_55(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("XXdataXX", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_56(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("DATA", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_57(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("Data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_58(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "XXvideoXX")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_59(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "VIDEO")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_60(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "Video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_61(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    None,
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_62(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    None,
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_63(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    None,
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_64(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    None,
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_65(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_66(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_67(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_68(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_69(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "XXidXX",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_70(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "ID",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_71(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "Id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_72(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("XXownerXX", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_73(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("OWNER", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_74(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("Owner", "displayName"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_75(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "XXdisplayNameXX"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_76(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayname"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_77(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "DISPLAYNAME"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_78(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "Displayname"),
                    ("game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_79(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("XXgameXX", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_80(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("GAME", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_81(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("Game", "displayName"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_82(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "XXdisplayNameXX"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_83(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayname"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_84(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "DISPLAYNAME"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_85(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "Displayname"),
                    "title",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_86(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "XXtitleXX",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_87(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "TITLE",
                ),
            ),
        )

    # GraphQL API calls

    def xǁTwitchAPIǁmetadata_video__mutmut_88(self, video_id):
        query = self._gql_persisted_query(
            "VideoMetadata",
            "cb3b1eb2f2d2b2f65b8389ba446ec521d76c3aa44f5424a1b1d235fe21eb4806",
            channelLogin="",  # parameter can be empty
            videoID=video_id,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "video": {
                            "id": str,
                            "owner": {
                                "displayName": str,
                            },
                            "title": str,
                            "game": {
                                "displayName": str,
                            },
                        },
                    },
                },
                validate.get(("data", "video")),
                validate.union_get(
                    "id",
                    ("owner", "displayName"),
                    ("game", "displayName"),
                    "Title",
                ),
            ),
        )
    
    xǁTwitchAPIǁmetadata_video__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchAPIǁmetadata_video__mutmut_1': xǁTwitchAPIǁmetadata_video__mutmut_1, 
        'xǁTwitchAPIǁmetadata_video__mutmut_2': xǁTwitchAPIǁmetadata_video__mutmut_2, 
        'xǁTwitchAPIǁmetadata_video__mutmut_3': xǁTwitchAPIǁmetadata_video__mutmut_3, 
        'xǁTwitchAPIǁmetadata_video__mutmut_4': xǁTwitchAPIǁmetadata_video__mutmut_4, 
        'xǁTwitchAPIǁmetadata_video__mutmut_5': xǁTwitchAPIǁmetadata_video__mutmut_5, 
        'xǁTwitchAPIǁmetadata_video__mutmut_6': xǁTwitchAPIǁmetadata_video__mutmut_6, 
        'xǁTwitchAPIǁmetadata_video__mutmut_7': xǁTwitchAPIǁmetadata_video__mutmut_7, 
        'xǁTwitchAPIǁmetadata_video__mutmut_8': xǁTwitchAPIǁmetadata_video__mutmut_8, 
        'xǁTwitchAPIǁmetadata_video__mutmut_9': xǁTwitchAPIǁmetadata_video__mutmut_9, 
        'xǁTwitchAPIǁmetadata_video__mutmut_10': xǁTwitchAPIǁmetadata_video__mutmut_10, 
        'xǁTwitchAPIǁmetadata_video__mutmut_11': xǁTwitchAPIǁmetadata_video__mutmut_11, 
        'xǁTwitchAPIǁmetadata_video__mutmut_12': xǁTwitchAPIǁmetadata_video__mutmut_12, 
        'xǁTwitchAPIǁmetadata_video__mutmut_13': xǁTwitchAPIǁmetadata_video__mutmut_13, 
        'xǁTwitchAPIǁmetadata_video__mutmut_14': xǁTwitchAPIǁmetadata_video__mutmut_14, 
        'xǁTwitchAPIǁmetadata_video__mutmut_15': xǁTwitchAPIǁmetadata_video__mutmut_15, 
        'xǁTwitchAPIǁmetadata_video__mutmut_16': xǁTwitchAPIǁmetadata_video__mutmut_16, 
        'xǁTwitchAPIǁmetadata_video__mutmut_17': xǁTwitchAPIǁmetadata_video__mutmut_17, 
        'xǁTwitchAPIǁmetadata_video__mutmut_18': xǁTwitchAPIǁmetadata_video__mutmut_18, 
        'xǁTwitchAPIǁmetadata_video__mutmut_19': xǁTwitchAPIǁmetadata_video__mutmut_19, 
        'xǁTwitchAPIǁmetadata_video__mutmut_20': xǁTwitchAPIǁmetadata_video__mutmut_20, 
        'xǁTwitchAPIǁmetadata_video__mutmut_21': xǁTwitchAPIǁmetadata_video__mutmut_21, 
        'xǁTwitchAPIǁmetadata_video__mutmut_22': xǁTwitchAPIǁmetadata_video__mutmut_22, 
        'xǁTwitchAPIǁmetadata_video__mutmut_23': xǁTwitchAPIǁmetadata_video__mutmut_23, 
        'xǁTwitchAPIǁmetadata_video__mutmut_24': xǁTwitchAPIǁmetadata_video__mutmut_24, 
        'xǁTwitchAPIǁmetadata_video__mutmut_25': xǁTwitchAPIǁmetadata_video__mutmut_25, 
        'xǁTwitchAPIǁmetadata_video__mutmut_26': xǁTwitchAPIǁmetadata_video__mutmut_26, 
        'xǁTwitchAPIǁmetadata_video__mutmut_27': xǁTwitchAPIǁmetadata_video__mutmut_27, 
        'xǁTwitchAPIǁmetadata_video__mutmut_28': xǁTwitchAPIǁmetadata_video__mutmut_28, 
        'xǁTwitchAPIǁmetadata_video__mutmut_29': xǁTwitchAPIǁmetadata_video__mutmut_29, 
        'xǁTwitchAPIǁmetadata_video__mutmut_30': xǁTwitchAPIǁmetadata_video__mutmut_30, 
        'xǁTwitchAPIǁmetadata_video__mutmut_31': xǁTwitchAPIǁmetadata_video__mutmut_31, 
        'xǁTwitchAPIǁmetadata_video__mutmut_32': xǁTwitchAPIǁmetadata_video__mutmut_32, 
        'xǁTwitchAPIǁmetadata_video__mutmut_33': xǁTwitchAPIǁmetadata_video__mutmut_33, 
        'xǁTwitchAPIǁmetadata_video__mutmut_34': xǁTwitchAPIǁmetadata_video__mutmut_34, 
        'xǁTwitchAPIǁmetadata_video__mutmut_35': xǁTwitchAPIǁmetadata_video__mutmut_35, 
        'xǁTwitchAPIǁmetadata_video__mutmut_36': xǁTwitchAPIǁmetadata_video__mutmut_36, 
        'xǁTwitchAPIǁmetadata_video__mutmut_37': xǁTwitchAPIǁmetadata_video__mutmut_37, 
        'xǁTwitchAPIǁmetadata_video__mutmut_38': xǁTwitchAPIǁmetadata_video__mutmut_38, 
        'xǁTwitchAPIǁmetadata_video__mutmut_39': xǁTwitchAPIǁmetadata_video__mutmut_39, 
        'xǁTwitchAPIǁmetadata_video__mutmut_40': xǁTwitchAPIǁmetadata_video__mutmut_40, 
        'xǁTwitchAPIǁmetadata_video__mutmut_41': xǁTwitchAPIǁmetadata_video__mutmut_41, 
        'xǁTwitchAPIǁmetadata_video__mutmut_42': xǁTwitchAPIǁmetadata_video__mutmut_42, 
        'xǁTwitchAPIǁmetadata_video__mutmut_43': xǁTwitchAPIǁmetadata_video__mutmut_43, 
        'xǁTwitchAPIǁmetadata_video__mutmut_44': xǁTwitchAPIǁmetadata_video__mutmut_44, 
        'xǁTwitchAPIǁmetadata_video__mutmut_45': xǁTwitchAPIǁmetadata_video__mutmut_45, 
        'xǁTwitchAPIǁmetadata_video__mutmut_46': xǁTwitchAPIǁmetadata_video__mutmut_46, 
        'xǁTwitchAPIǁmetadata_video__mutmut_47': xǁTwitchAPIǁmetadata_video__mutmut_47, 
        'xǁTwitchAPIǁmetadata_video__mutmut_48': xǁTwitchAPIǁmetadata_video__mutmut_48, 
        'xǁTwitchAPIǁmetadata_video__mutmut_49': xǁTwitchAPIǁmetadata_video__mutmut_49, 
        'xǁTwitchAPIǁmetadata_video__mutmut_50': xǁTwitchAPIǁmetadata_video__mutmut_50, 
        'xǁTwitchAPIǁmetadata_video__mutmut_51': xǁTwitchAPIǁmetadata_video__mutmut_51, 
        'xǁTwitchAPIǁmetadata_video__mutmut_52': xǁTwitchAPIǁmetadata_video__mutmut_52, 
        'xǁTwitchAPIǁmetadata_video__mutmut_53': xǁTwitchAPIǁmetadata_video__mutmut_53, 
        'xǁTwitchAPIǁmetadata_video__mutmut_54': xǁTwitchAPIǁmetadata_video__mutmut_54, 
        'xǁTwitchAPIǁmetadata_video__mutmut_55': xǁTwitchAPIǁmetadata_video__mutmut_55, 
        'xǁTwitchAPIǁmetadata_video__mutmut_56': xǁTwitchAPIǁmetadata_video__mutmut_56, 
        'xǁTwitchAPIǁmetadata_video__mutmut_57': xǁTwitchAPIǁmetadata_video__mutmut_57, 
        'xǁTwitchAPIǁmetadata_video__mutmut_58': xǁTwitchAPIǁmetadata_video__mutmut_58, 
        'xǁTwitchAPIǁmetadata_video__mutmut_59': xǁTwitchAPIǁmetadata_video__mutmut_59, 
        'xǁTwitchAPIǁmetadata_video__mutmut_60': xǁTwitchAPIǁmetadata_video__mutmut_60, 
        'xǁTwitchAPIǁmetadata_video__mutmut_61': xǁTwitchAPIǁmetadata_video__mutmut_61, 
        'xǁTwitchAPIǁmetadata_video__mutmut_62': xǁTwitchAPIǁmetadata_video__mutmut_62, 
        'xǁTwitchAPIǁmetadata_video__mutmut_63': xǁTwitchAPIǁmetadata_video__mutmut_63, 
        'xǁTwitchAPIǁmetadata_video__mutmut_64': xǁTwitchAPIǁmetadata_video__mutmut_64, 
        'xǁTwitchAPIǁmetadata_video__mutmut_65': xǁTwitchAPIǁmetadata_video__mutmut_65, 
        'xǁTwitchAPIǁmetadata_video__mutmut_66': xǁTwitchAPIǁmetadata_video__mutmut_66, 
        'xǁTwitchAPIǁmetadata_video__mutmut_67': xǁTwitchAPIǁmetadata_video__mutmut_67, 
        'xǁTwitchAPIǁmetadata_video__mutmut_68': xǁTwitchAPIǁmetadata_video__mutmut_68, 
        'xǁTwitchAPIǁmetadata_video__mutmut_69': xǁTwitchAPIǁmetadata_video__mutmut_69, 
        'xǁTwitchAPIǁmetadata_video__mutmut_70': xǁTwitchAPIǁmetadata_video__mutmut_70, 
        'xǁTwitchAPIǁmetadata_video__mutmut_71': xǁTwitchAPIǁmetadata_video__mutmut_71, 
        'xǁTwitchAPIǁmetadata_video__mutmut_72': xǁTwitchAPIǁmetadata_video__mutmut_72, 
        'xǁTwitchAPIǁmetadata_video__mutmut_73': xǁTwitchAPIǁmetadata_video__mutmut_73, 
        'xǁTwitchAPIǁmetadata_video__mutmut_74': xǁTwitchAPIǁmetadata_video__mutmut_74, 
        'xǁTwitchAPIǁmetadata_video__mutmut_75': xǁTwitchAPIǁmetadata_video__mutmut_75, 
        'xǁTwitchAPIǁmetadata_video__mutmut_76': xǁTwitchAPIǁmetadata_video__mutmut_76, 
        'xǁTwitchAPIǁmetadata_video__mutmut_77': xǁTwitchAPIǁmetadata_video__mutmut_77, 
        'xǁTwitchAPIǁmetadata_video__mutmut_78': xǁTwitchAPIǁmetadata_video__mutmut_78, 
        'xǁTwitchAPIǁmetadata_video__mutmut_79': xǁTwitchAPIǁmetadata_video__mutmut_79, 
        'xǁTwitchAPIǁmetadata_video__mutmut_80': xǁTwitchAPIǁmetadata_video__mutmut_80, 
        'xǁTwitchAPIǁmetadata_video__mutmut_81': xǁTwitchAPIǁmetadata_video__mutmut_81, 
        'xǁTwitchAPIǁmetadata_video__mutmut_82': xǁTwitchAPIǁmetadata_video__mutmut_82, 
        'xǁTwitchAPIǁmetadata_video__mutmut_83': xǁTwitchAPIǁmetadata_video__mutmut_83, 
        'xǁTwitchAPIǁmetadata_video__mutmut_84': xǁTwitchAPIǁmetadata_video__mutmut_84, 
        'xǁTwitchAPIǁmetadata_video__mutmut_85': xǁTwitchAPIǁmetadata_video__mutmut_85, 
        'xǁTwitchAPIǁmetadata_video__mutmut_86': xǁTwitchAPIǁmetadata_video__mutmut_86, 
        'xǁTwitchAPIǁmetadata_video__mutmut_87': xǁTwitchAPIǁmetadata_video__mutmut_87, 
        'xǁTwitchAPIǁmetadata_video__mutmut_88': xǁTwitchAPIǁmetadata_video__mutmut_88
    }
    
    def metadata_video(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchAPIǁmetadata_video__mutmut_orig"), object.__getattribute__(self, "xǁTwitchAPIǁmetadata_video__mutmut_mutants"), args, kwargs, self)
        return result 
    
    metadata_video.__signature__ = _mutmut_signature(xǁTwitchAPIǁmetadata_video__mutmut_orig)
    xǁTwitchAPIǁmetadata_video__mutmut_orig.__name__ = 'xǁTwitchAPIǁmetadata_video'

    def xǁTwitchAPIǁmetadata_channel__mutmut_orig(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_1(self, channel):
        queries = None

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_2(self, channel):
        queries = [
            self._gql_persisted_query(
                None,
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_3(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                None,
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_4(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=None,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_5(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=None,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_6(self, channel):
        queries = [
            self._gql_persisted_query(
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_7(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_8(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_9(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_10(self, channel):
        queries = [
            self._gql_persisted_query(
                "XXChannelShellXX",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_11(self, channel):
        queries = [
            self._gql_persisted_query(
                "channelshell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_12(self, channel):
        queries = [
            self._gql_persisted_query(
                "CHANNELSHELL",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_13(self, channel):
        queries = [
            self._gql_persisted_query(
                "Channelshell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_14(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "XXc3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55XX",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_15(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "C3EA5A669EC074A58DF5C11CE3C27093FA38534C94286DC14B68A25D5ADCBF55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_16(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "C3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_17(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=True,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_18(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                None,
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_19(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                None,
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_20(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=None,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_21(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_22(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_23(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_24(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "XXStreamMetadataXX",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_25(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "streammetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_26(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "STREAMMETADATA",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_27(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "Streammetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_28(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "XX059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517fXX",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_29(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059C4653B788F5BDB2F5A2D2A24B0DDC3831A15079001A3D927556A96FB0517F",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_30(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            None,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_31(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=None,
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_32(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_33(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            )

    def xǁTwitchAPIǁmetadata_channel__mutmut_34(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                None,
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_35(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                None,
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_36(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_37(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_38(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    None,
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_39(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    None,
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_40(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_41(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_42(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        None,
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_43(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "XXdataXX": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_44(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "DATA": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_45(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "Data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_46(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "XXuserOrErrorXX": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_47(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userorerror": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_48(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "USERORERROR": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_49(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "Userorerror": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_50(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "XXdisplayNameXX": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_51(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayname": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_52(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "DISPLAYNAME": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_53(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "Displayname": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_54(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        None,
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_55(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "XXdataXX": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_56(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "DATA": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_57(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "Data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_58(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "XXuserXX": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_59(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "USER": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_60(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "User": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_61(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "XXlastBroadcastXX": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_62(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastbroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_63(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "LASTBROADCAST": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_64(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "Lastbroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_65(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "XXtitleXX": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_66(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "TITLE": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_67(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "Title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_68(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "XXstreamXX": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_69(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "STREAM": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_70(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "Stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_71(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "XXidXX": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_72(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "ID": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_73(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "Id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_74(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "XXgameXX": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_75(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "GAME": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_76(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "Game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_77(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "XXnameXX": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_78(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "NAME": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_79(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "Name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_80(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    None,
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_81(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    None,
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_82(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    None,
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_83(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    None,
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_84(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_85(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_86(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_87(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_88(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (2, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_89(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "XXdataXX", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_90(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "DATA", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_91(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "Data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_92(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "XXuserXX", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_93(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "USER", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_94(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "User", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_95(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "XXstreamXX", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_96(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "STREAM", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_97(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "Stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_98(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "XXidXX"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_99(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "ID"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_100(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "Id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_101(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (1, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_102(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "XXdataXX", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_103(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "DATA", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_104(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "Data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_105(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "XXuserOrErrorXX", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_106(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userorerror", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_107(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "USERORERROR", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_108(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "Userorerror", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_109(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "XXdisplayNameXX"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_110(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayname"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_111(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "DISPLAYNAME"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_112(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "Displayname"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_113(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (2, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_114(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "XXdataXX", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_115(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "DATA", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_116(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "Data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_117(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "XXuserXX", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_118(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "USER", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_119(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "User", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_120(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "XXstreamXX", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_121(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "STREAM", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_122(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "Stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_123(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "XXgameXX", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_124(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "GAME", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_125(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "Game", "name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_126(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "XXnameXX"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_127(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "NAME"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_128(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "Name"),
                    (1, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_129(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (2, "data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_130(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "XXdataXX", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_131(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "DATA", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_132(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "Data", "user", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_133(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "XXuserXX", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_134(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "USER", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_135(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "User", "lastBroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_136(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "XXlastBroadcastXX", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_137(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastbroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_138(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "LASTBROADCAST", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_139(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "Lastbroadcast", "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_140(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "XXtitleXX"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_141(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "TITLE"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_channel__mutmut_142(self, channel):
        queries = [
            self._gql_persisted_query(
                "ChannelShell",
                "c3ea5a669ec074a58df5c11ce3c27093fa38534c94286dc14b68a25d5adcbf55",
                login=channel,
                lcpVideosEnabled=False,
            ),
            self._gql_persisted_query(
                "StreamMetadata",
                "059c4653b788f5bdb2f5a2d2a24b0ddc3831a15079001a3d927556a96fb0517f",
                channelLogin=channel,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "userOrError": {
                                    "displayName": str,
                                },
                            },
                        },
                    ),
                    validate.all(
                        {
                            "data": {
                                "user": {
                                    "lastBroadcast": {
                                        "title": str,
                                    },
                                    "stream": {
                                        "id": str,
                                        "game": {
                                            "name": str,
                                        },
                                    },
                                },
                            },
                        },
                    ),
                ),
                validate.union_get(
                    (1, "data", "user", "stream", "id"),
                    (0, "data", "userOrError", "displayName"),
                    (1, "data", "user", "stream", "game", "name"),
                    (1, "data", "user", "lastBroadcast", "Title"),
                ),
            ),
        )
    
    xǁTwitchAPIǁmetadata_channel__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchAPIǁmetadata_channel__mutmut_1': xǁTwitchAPIǁmetadata_channel__mutmut_1, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_2': xǁTwitchAPIǁmetadata_channel__mutmut_2, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_3': xǁTwitchAPIǁmetadata_channel__mutmut_3, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_4': xǁTwitchAPIǁmetadata_channel__mutmut_4, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_5': xǁTwitchAPIǁmetadata_channel__mutmut_5, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_6': xǁTwitchAPIǁmetadata_channel__mutmut_6, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_7': xǁTwitchAPIǁmetadata_channel__mutmut_7, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_8': xǁTwitchAPIǁmetadata_channel__mutmut_8, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_9': xǁTwitchAPIǁmetadata_channel__mutmut_9, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_10': xǁTwitchAPIǁmetadata_channel__mutmut_10, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_11': xǁTwitchAPIǁmetadata_channel__mutmut_11, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_12': xǁTwitchAPIǁmetadata_channel__mutmut_12, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_13': xǁTwitchAPIǁmetadata_channel__mutmut_13, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_14': xǁTwitchAPIǁmetadata_channel__mutmut_14, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_15': xǁTwitchAPIǁmetadata_channel__mutmut_15, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_16': xǁTwitchAPIǁmetadata_channel__mutmut_16, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_17': xǁTwitchAPIǁmetadata_channel__mutmut_17, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_18': xǁTwitchAPIǁmetadata_channel__mutmut_18, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_19': xǁTwitchAPIǁmetadata_channel__mutmut_19, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_20': xǁTwitchAPIǁmetadata_channel__mutmut_20, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_21': xǁTwitchAPIǁmetadata_channel__mutmut_21, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_22': xǁTwitchAPIǁmetadata_channel__mutmut_22, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_23': xǁTwitchAPIǁmetadata_channel__mutmut_23, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_24': xǁTwitchAPIǁmetadata_channel__mutmut_24, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_25': xǁTwitchAPIǁmetadata_channel__mutmut_25, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_26': xǁTwitchAPIǁmetadata_channel__mutmut_26, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_27': xǁTwitchAPIǁmetadata_channel__mutmut_27, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_28': xǁTwitchAPIǁmetadata_channel__mutmut_28, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_29': xǁTwitchAPIǁmetadata_channel__mutmut_29, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_30': xǁTwitchAPIǁmetadata_channel__mutmut_30, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_31': xǁTwitchAPIǁmetadata_channel__mutmut_31, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_32': xǁTwitchAPIǁmetadata_channel__mutmut_32, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_33': xǁTwitchAPIǁmetadata_channel__mutmut_33, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_34': xǁTwitchAPIǁmetadata_channel__mutmut_34, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_35': xǁTwitchAPIǁmetadata_channel__mutmut_35, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_36': xǁTwitchAPIǁmetadata_channel__mutmut_36, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_37': xǁTwitchAPIǁmetadata_channel__mutmut_37, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_38': xǁTwitchAPIǁmetadata_channel__mutmut_38, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_39': xǁTwitchAPIǁmetadata_channel__mutmut_39, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_40': xǁTwitchAPIǁmetadata_channel__mutmut_40, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_41': xǁTwitchAPIǁmetadata_channel__mutmut_41, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_42': xǁTwitchAPIǁmetadata_channel__mutmut_42, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_43': xǁTwitchAPIǁmetadata_channel__mutmut_43, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_44': xǁTwitchAPIǁmetadata_channel__mutmut_44, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_45': xǁTwitchAPIǁmetadata_channel__mutmut_45, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_46': xǁTwitchAPIǁmetadata_channel__mutmut_46, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_47': xǁTwitchAPIǁmetadata_channel__mutmut_47, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_48': xǁTwitchAPIǁmetadata_channel__mutmut_48, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_49': xǁTwitchAPIǁmetadata_channel__mutmut_49, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_50': xǁTwitchAPIǁmetadata_channel__mutmut_50, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_51': xǁTwitchAPIǁmetadata_channel__mutmut_51, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_52': xǁTwitchAPIǁmetadata_channel__mutmut_52, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_53': xǁTwitchAPIǁmetadata_channel__mutmut_53, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_54': xǁTwitchAPIǁmetadata_channel__mutmut_54, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_55': xǁTwitchAPIǁmetadata_channel__mutmut_55, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_56': xǁTwitchAPIǁmetadata_channel__mutmut_56, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_57': xǁTwitchAPIǁmetadata_channel__mutmut_57, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_58': xǁTwitchAPIǁmetadata_channel__mutmut_58, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_59': xǁTwitchAPIǁmetadata_channel__mutmut_59, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_60': xǁTwitchAPIǁmetadata_channel__mutmut_60, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_61': xǁTwitchAPIǁmetadata_channel__mutmut_61, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_62': xǁTwitchAPIǁmetadata_channel__mutmut_62, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_63': xǁTwitchAPIǁmetadata_channel__mutmut_63, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_64': xǁTwitchAPIǁmetadata_channel__mutmut_64, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_65': xǁTwitchAPIǁmetadata_channel__mutmut_65, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_66': xǁTwitchAPIǁmetadata_channel__mutmut_66, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_67': xǁTwitchAPIǁmetadata_channel__mutmut_67, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_68': xǁTwitchAPIǁmetadata_channel__mutmut_68, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_69': xǁTwitchAPIǁmetadata_channel__mutmut_69, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_70': xǁTwitchAPIǁmetadata_channel__mutmut_70, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_71': xǁTwitchAPIǁmetadata_channel__mutmut_71, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_72': xǁTwitchAPIǁmetadata_channel__mutmut_72, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_73': xǁTwitchAPIǁmetadata_channel__mutmut_73, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_74': xǁTwitchAPIǁmetadata_channel__mutmut_74, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_75': xǁTwitchAPIǁmetadata_channel__mutmut_75, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_76': xǁTwitchAPIǁmetadata_channel__mutmut_76, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_77': xǁTwitchAPIǁmetadata_channel__mutmut_77, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_78': xǁTwitchAPIǁmetadata_channel__mutmut_78, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_79': xǁTwitchAPIǁmetadata_channel__mutmut_79, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_80': xǁTwitchAPIǁmetadata_channel__mutmut_80, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_81': xǁTwitchAPIǁmetadata_channel__mutmut_81, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_82': xǁTwitchAPIǁmetadata_channel__mutmut_82, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_83': xǁTwitchAPIǁmetadata_channel__mutmut_83, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_84': xǁTwitchAPIǁmetadata_channel__mutmut_84, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_85': xǁTwitchAPIǁmetadata_channel__mutmut_85, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_86': xǁTwitchAPIǁmetadata_channel__mutmut_86, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_87': xǁTwitchAPIǁmetadata_channel__mutmut_87, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_88': xǁTwitchAPIǁmetadata_channel__mutmut_88, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_89': xǁTwitchAPIǁmetadata_channel__mutmut_89, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_90': xǁTwitchAPIǁmetadata_channel__mutmut_90, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_91': xǁTwitchAPIǁmetadata_channel__mutmut_91, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_92': xǁTwitchAPIǁmetadata_channel__mutmut_92, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_93': xǁTwitchAPIǁmetadata_channel__mutmut_93, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_94': xǁTwitchAPIǁmetadata_channel__mutmut_94, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_95': xǁTwitchAPIǁmetadata_channel__mutmut_95, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_96': xǁTwitchAPIǁmetadata_channel__mutmut_96, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_97': xǁTwitchAPIǁmetadata_channel__mutmut_97, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_98': xǁTwitchAPIǁmetadata_channel__mutmut_98, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_99': xǁTwitchAPIǁmetadata_channel__mutmut_99, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_100': xǁTwitchAPIǁmetadata_channel__mutmut_100, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_101': xǁTwitchAPIǁmetadata_channel__mutmut_101, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_102': xǁTwitchAPIǁmetadata_channel__mutmut_102, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_103': xǁTwitchAPIǁmetadata_channel__mutmut_103, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_104': xǁTwitchAPIǁmetadata_channel__mutmut_104, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_105': xǁTwitchAPIǁmetadata_channel__mutmut_105, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_106': xǁTwitchAPIǁmetadata_channel__mutmut_106, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_107': xǁTwitchAPIǁmetadata_channel__mutmut_107, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_108': xǁTwitchAPIǁmetadata_channel__mutmut_108, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_109': xǁTwitchAPIǁmetadata_channel__mutmut_109, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_110': xǁTwitchAPIǁmetadata_channel__mutmut_110, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_111': xǁTwitchAPIǁmetadata_channel__mutmut_111, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_112': xǁTwitchAPIǁmetadata_channel__mutmut_112, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_113': xǁTwitchAPIǁmetadata_channel__mutmut_113, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_114': xǁTwitchAPIǁmetadata_channel__mutmut_114, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_115': xǁTwitchAPIǁmetadata_channel__mutmut_115, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_116': xǁTwitchAPIǁmetadata_channel__mutmut_116, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_117': xǁTwitchAPIǁmetadata_channel__mutmut_117, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_118': xǁTwitchAPIǁmetadata_channel__mutmut_118, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_119': xǁTwitchAPIǁmetadata_channel__mutmut_119, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_120': xǁTwitchAPIǁmetadata_channel__mutmut_120, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_121': xǁTwitchAPIǁmetadata_channel__mutmut_121, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_122': xǁTwitchAPIǁmetadata_channel__mutmut_122, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_123': xǁTwitchAPIǁmetadata_channel__mutmut_123, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_124': xǁTwitchAPIǁmetadata_channel__mutmut_124, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_125': xǁTwitchAPIǁmetadata_channel__mutmut_125, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_126': xǁTwitchAPIǁmetadata_channel__mutmut_126, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_127': xǁTwitchAPIǁmetadata_channel__mutmut_127, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_128': xǁTwitchAPIǁmetadata_channel__mutmut_128, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_129': xǁTwitchAPIǁmetadata_channel__mutmut_129, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_130': xǁTwitchAPIǁmetadata_channel__mutmut_130, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_131': xǁTwitchAPIǁmetadata_channel__mutmut_131, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_132': xǁTwitchAPIǁmetadata_channel__mutmut_132, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_133': xǁTwitchAPIǁmetadata_channel__mutmut_133, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_134': xǁTwitchAPIǁmetadata_channel__mutmut_134, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_135': xǁTwitchAPIǁmetadata_channel__mutmut_135, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_136': xǁTwitchAPIǁmetadata_channel__mutmut_136, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_137': xǁTwitchAPIǁmetadata_channel__mutmut_137, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_138': xǁTwitchAPIǁmetadata_channel__mutmut_138, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_139': xǁTwitchAPIǁmetadata_channel__mutmut_139, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_140': xǁTwitchAPIǁmetadata_channel__mutmut_140, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_141': xǁTwitchAPIǁmetadata_channel__mutmut_141, 
        'xǁTwitchAPIǁmetadata_channel__mutmut_142': xǁTwitchAPIǁmetadata_channel__mutmut_142
    }
    
    def metadata_channel(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchAPIǁmetadata_channel__mutmut_orig"), object.__getattribute__(self, "xǁTwitchAPIǁmetadata_channel__mutmut_mutants"), args, kwargs, self)
        return result 
    
    metadata_channel.__signature__ = _mutmut_signature(xǁTwitchAPIǁmetadata_channel__mutmut_orig)
    xǁTwitchAPIǁmetadata_channel__mutmut_orig.__name__ = 'xǁTwitchAPIǁmetadata_channel'

    def xǁTwitchAPIǁmetadata_clips__mutmut_orig(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_1(self, clipname):
        queries = None

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_2(self, clipname):
        queries = [
            self._gql_persisted_query(
                None,
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_3(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                None,
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_4(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=None,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_5(self, clipname):
        queries = [
            self._gql_persisted_query(
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_6(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_7(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_8(self, clipname):
        queries = [
            self._gql_persisted_query(
                "XXClipsViewXX",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_9(self, clipname):
        queries = [
            self._gql_persisted_query(
                "clipsview",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_10(self, clipname):
        queries = [
            self._gql_persisted_query(
                "CLIPSVIEW",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_11(self, clipname):
        queries = [
            self._gql_persisted_query(
                "Clipsview",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_12(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "XX4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8fXX",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_13(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480C1DCC2494A17BB6EF64B94A5213A956AFB8A45FE314C66B0D04079A93A8F",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_14(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                None,
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_15(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                None,
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_16(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=None,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_17(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_18(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_19(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_20(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "XXClipsTitleXX",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_21(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "clipstitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_22(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "CLIPSTITLE",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_23(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "Clipstitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_24(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "XXf6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4XX",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_25(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "F6CCA7F2FDFBFC2CECEA0C88452500DAE569191E58A265F97711F8F2A838F5B4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_26(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "F6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_27(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            None,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_28(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=None,
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_29(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_30(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            )

    def xǁTwitchAPIǁmetadata_clips__mutmut_31(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                None,
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_32(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                None,
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_33(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_34(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_35(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    None,
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_36(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    None,
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_37(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_38(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_39(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        None,
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_40(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        None,
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_41(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_42(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_43(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "XXdataXX": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_44(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "DATA": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_45(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "Data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_46(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "XXclipXX": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_47(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "CLIP": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_48(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "Clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_49(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "XXidXX": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_50(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "ID": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_51(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "Id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_52(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "XXbroadcasterXX": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_53(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "BROADCASTER": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_54(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "Broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_55(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"XXdisplayNameXX": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_56(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayname": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_57(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"DISPLAYNAME": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_58(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"Displayname": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_59(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "XXgameXX": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_60(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "GAME": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_61(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "Game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_62(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"XXnameXX": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_63(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"NAME": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_64(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"Name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_65(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(None),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_66(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("XXdataXX", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_67(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("DATA", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_68(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("Data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_69(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "XXclipXX")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_70(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "CLIP")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_71(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "Clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_72(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        None,
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_73(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        None,
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_74(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_75(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_76(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"XXdataXX": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_77(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"DATA": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_78(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"Data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_79(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"XXclipXX": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_80(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"CLIP": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_81(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"Clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_82(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"XXtitleXX": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_83(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"TITLE": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_84(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"Title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_85(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(None),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_86(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("XXdataXX", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_87(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("DATA", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_88(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("Data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_89(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "XXclipXX")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_90(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "CLIP")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_91(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "Clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_92(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    None,
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_93(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    None,
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_94(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    None,
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_95(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    None,
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_96(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_97(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_98(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_99(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_100(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (1, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_101(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "XXidXX"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_102(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "ID"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_103(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "Id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_104(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (1, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_105(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "XXbroadcasterXX", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_106(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "BROADCASTER", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_107(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "Broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_108(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "XXdisplayNameXX"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_109(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayname"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_110(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "DISPLAYNAME"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_111(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "Displayname"),
                    (0, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_112(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (1, "game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_113(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "XXgameXX", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_114(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "GAME", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_115(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "Game", "name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_116(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "XXnameXX"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_117(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "NAME"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_118(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "Name"),
                    (1, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_119(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (2, "title"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_120(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "XXtitleXX"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_121(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "TITLE"),
                ),
            ),
        )

    def xǁTwitchAPIǁmetadata_clips__mutmut_122(self, clipname):
        queries = [
            self._gql_persisted_query(
                "ClipsView",
                "4480c1dcc2494a17bb6ef64b94a5213a956afb8a45fe314c66b0d04079a93a8f",
                slug=clipname,
            ),
            self._gql_persisted_query(
                "ClipsTitle",
                "f6cca7f2fdfbfc2cecea0c88452500dae569191e58a265f97711f8f2a838f5b4",
                slug=clipname,
            ),
        ]

        return self.call(
            queries,
            schema=validate.all(
                validate.list(
                    validate.all(
                        {
                            "data": {
                                "clip": {
                                    "id": str,
                                    "broadcaster": {"displayName": str},
                                    "game": {"name": str},
                                },
                            },
                        },
                        validate.get(("data", "clip")),
                    ),
                    validate.all(
                        {"data": {"clip": {"title": str}}},
                        validate.get(("data", "clip")),
                    ),
                ),
                validate.union_get(
                    (0, "id"),
                    (0, "broadcaster", "displayName"),
                    (0, "game", "name"),
                    (1, "Title"),
                ),
            ),
        )
    
    xǁTwitchAPIǁmetadata_clips__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchAPIǁmetadata_clips__mutmut_1': xǁTwitchAPIǁmetadata_clips__mutmut_1, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_2': xǁTwitchAPIǁmetadata_clips__mutmut_2, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_3': xǁTwitchAPIǁmetadata_clips__mutmut_3, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_4': xǁTwitchAPIǁmetadata_clips__mutmut_4, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_5': xǁTwitchAPIǁmetadata_clips__mutmut_5, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_6': xǁTwitchAPIǁmetadata_clips__mutmut_6, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_7': xǁTwitchAPIǁmetadata_clips__mutmut_7, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_8': xǁTwitchAPIǁmetadata_clips__mutmut_8, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_9': xǁTwitchAPIǁmetadata_clips__mutmut_9, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_10': xǁTwitchAPIǁmetadata_clips__mutmut_10, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_11': xǁTwitchAPIǁmetadata_clips__mutmut_11, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_12': xǁTwitchAPIǁmetadata_clips__mutmut_12, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_13': xǁTwitchAPIǁmetadata_clips__mutmut_13, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_14': xǁTwitchAPIǁmetadata_clips__mutmut_14, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_15': xǁTwitchAPIǁmetadata_clips__mutmut_15, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_16': xǁTwitchAPIǁmetadata_clips__mutmut_16, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_17': xǁTwitchAPIǁmetadata_clips__mutmut_17, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_18': xǁTwitchAPIǁmetadata_clips__mutmut_18, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_19': xǁTwitchAPIǁmetadata_clips__mutmut_19, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_20': xǁTwitchAPIǁmetadata_clips__mutmut_20, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_21': xǁTwitchAPIǁmetadata_clips__mutmut_21, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_22': xǁTwitchAPIǁmetadata_clips__mutmut_22, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_23': xǁTwitchAPIǁmetadata_clips__mutmut_23, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_24': xǁTwitchAPIǁmetadata_clips__mutmut_24, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_25': xǁTwitchAPIǁmetadata_clips__mutmut_25, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_26': xǁTwitchAPIǁmetadata_clips__mutmut_26, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_27': xǁTwitchAPIǁmetadata_clips__mutmut_27, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_28': xǁTwitchAPIǁmetadata_clips__mutmut_28, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_29': xǁTwitchAPIǁmetadata_clips__mutmut_29, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_30': xǁTwitchAPIǁmetadata_clips__mutmut_30, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_31': xǁTwitchAPIǁmetadata_clips__mutmut_31, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_32': xǁTwitchAPIǁmetadata_clips__mutmut_32, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_33': xǁTwitchAPIǁmetadata_clips__mutmut_33, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_34': xǁTwitchAPIǁmetadata_clips__mutmut_34, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_35': xǁTwitchAPIǁmetadata_clips__mutmut_35, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_36': xǁTwitchAPIǁmetadata_clips__mutmut_36, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_37': xǁTwitchAPIǁmetadata_clips__mutmut_37, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_38': xǁTwitchAPIǁmetadata_clips__mutmut_38, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_39': xǁTwitchAPIǁmetadata_clips__mutmut_39, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_40': xǁTwitchAPIǁmetadata_clips__mutmut_40, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_41': xǁTwitchAPIǁmetadata_clips__mutmut_41, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_42': xǁTwitchAPIǁmetadata_clips__mutmut_42, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_43': xǁTwitchAPIǁmetadata_clips__mutmut_43, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_44': xǁTwitchAPIǁmetadata_clips__mutmut_44, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_45': xǁTwitchAPIǁmetadata_clips__mutmut_45, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_46': xǁTwitchAPIǁmetadata_clips__mutmut_46, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_47': xǁTwitchAPIǁmetadata_clips__mutmut_47, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_48': xǁTwitchAPIǁmetadata_clips__mutmut_48, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_49': xǁTwitchAPIǁmetadata_clips__mutmut_49, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_50': xǁTwitchAPIǁmetadata_clips__mutmut_50, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_51': xǁTwitchAPIǁmetadata_clips__mutmut_51, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_52': xǁTwitchAPIǁmetadata_clips__mutmut_52, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_53': xǁTwitchAPIǁmetadata_clips__mutmut_53, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_54': xǁTwitchAPIǁmetadata_clips__mutmut_54, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_55': xǁTwitchAPIǁmetadata_clips__mutmut_55, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_56': xǁTwitchAPIǁmetadata_clips__mutmut_56, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_57': xǁTwitchAPIǁmetadata_clips__mutmut_57, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_58': xǁTwitchAPIǁmetadata_clips__mutmut_58, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_59': xǁTwitchAPIǁmetadata_clips__mutmut_59, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_60': xǁTwitchAPIǁmetadata_clips__mutmut_60, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_61': xǁTwitchAPIǁmetadata_clips__mutmut_61, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_62': xǁTwitchAPIǁmetadata_clips__mutmut_62, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_63': xǁTwitchAPIǁmetadata_clips__mutmut_63, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_64': xǁTwitchAPIǁmetadata_clips__mutmut_64, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_65': xǁTwitchAPIǁmetadata_clips__mutmut_65, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_66': xǁTwitchAPIǁmetadata_clips__mutmut_66, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_67': xǁTwitchAPIǁmetadata_clips__mutmut_67, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_68': xǁTwitchAPIǁmetadata_clips__mutmut_68, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_69': xǁTwitchAPIǁmetadata_clips__mutmut_69, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_70': xǁTwitchAPIǁmetadata_clips__mutmut_70, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_71': xǁTwitchAPIǁmetadata_clips__mutmut_71, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_72': xǁTwitchAPIǁmetadata_clips__mutmut_72, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_73': xǁTwitchAPIǁmetadata_clips__mutmut_73, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_74': xǁTwitchAPIǁmetadata_clips__mutmut_74, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_75': xǁTwitchAPIǁmetadata_clips__mutmut_75, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_76': xǁTwitchAPIǁmetadata_clips__mutmut_76, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_77': xǁTwitchAPIǁmetadata_clips__mutmut_77, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_78': xǁTwitchAPIǁmetadata_clips__mutmut_78, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_79': xǁTwitchAPIǁmetadata_clips__mutmut_79, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_80': xǁTwitchAPIǁmetadata_clips__mutmut_80, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_81': xǁTwitchAPIǁmetadata_clips__mutmut_81, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_82': xǁTwitchAPIǁmetadata_clips__mutmut_82, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_83': xǁTwitchAPIǁmetadata_clips__mutmut_83, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_84': xǁTwitchAPIǁmetadata_clips__mutmut_84, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_85': xǁTwitchAPIǁmetadata_clips__mutmut_85, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_86': xǁTwitchAPIǁmetadata_clips__mutmut_86, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_87': xǁTwitchAPIǁmetadata_clips__mutmut_87, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_88': xǁTwitchAPIǁmetadata_clips__mutmut_88, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_89': xǁTwitchAPIǁmetadata_clips__mutmut_89, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_90': xǁTwitchAPIǁmetadata_clips__mutmut_90, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_91': xǁTwitchAPIǁmetadata_clips__mutmut_91, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_92': xǁTwitchAPIǁmetadata_clips__mutmut_92, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_93': xǁTwitchAPIǁmetadata_clips__mutmut_93, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_94': xǁTwitchAPIǁmetadata_clips__mutmut_94, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_95': xǁTwitchAPIǁmetadata_clips__mutmut_95, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_96': xǁTwitchAPIǁmetadata_clips__mutmut_96, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_97': xǁTwitchAPIǁmetadata_clips__mutmut_97, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_98': xǁTwitchAPIǁmetadata_clips__mutmut_98, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_99': xǁTwitchAPIǁmetadata_clips__mutmut_99, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_100': xǁTwitchAPIǁmetadata_clips__mutmut_100, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_101': xǁTwitchAPIǁmetadata_clips__mutmut_101, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_102': xǁTwitchAPIǁmetadata_clips__mutmut_102, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_103': xǁTwitchAPIǁmetadata_clips__mutmut_103, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_104': xǁTwitchAPIǁmetadata_clips__mutmut_104, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_105': xǁTwitchAPIǁmetadata_clips__mutmut_105, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_106': xǁTwitchAPIǁmetadata_clips__mutmut_106, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_107': xǁTwitchAPIǁmetadata_clips__mutmut_107, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_108': xǁTwitchAPIǁmetadata_clips__mutmut_108, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_109': xǁTwitchAPIǁmetadata_clips__mutmut_109, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_110': xǁTwitchAPIǁmetadata_clips__mutmut_110, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_111': xǁTwitchAPIǁmetadata_clips__mutmut_111, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_112': xǁTwitchAPIǁmetadata_clips__mutmut_112, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_113': xǁTwitchAPIǁmetadata_clips__mutmut_113, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_114': xǁTwitchAPIǁmetadata_clips__mutmut_114, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_115': xǁTwitchAPIǁmetadata_clips__mutmut_115, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_116': xǁTwitchAPIǁmetadata_clips__mutmut_116, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_117': xǁTwitchAPIǁmetadata_clips__mutmut_117, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_118': xǁTwitchAPIǁmetadata_clips__mutmut_118, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_119': xǁTwitchAPIǁmetadata_clips__mutmut_119, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_120': xǁTwitchAPIǁmetadata_clips__mutmut_120, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_121': xǁTwitchAPIǁmetadata_clips__mutmut_121, 
        'xǁTwitchAPIǁmetadata_clips__mutmut_122': xǁTwitchAPIǁmetadata_clips__mutmut_122
    }
    
    def metadata_clips(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchAPIǁmetadata_clips__mutmut_orig"), object.__getattribute__(self, "xǁTwitchAPIǁmetadata_clips__mutmut_mutants"), args, kwargs, self)
        return result 
    
    metadata_clips.__signature__ = _mutmut_signature(xǁTwitchAPIǁmetadata_clips__mutmut_orig)
    xǁTwitchAPIǁmetadata_clips__mutmut_orig.__name__ = 'xǁTwitchAPIǁmetadata_clips'

    def xǁTwitchAPIǁaccess_token__mutmut_orig(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_1(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = None
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_2(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            None,
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_3(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            None,
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_4(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=None,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_5(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=None,
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_6(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=None,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_7(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=None,
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_8(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_9(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_10(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_11(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_12(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_13(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_14(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_15(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "XXPlaybackAccessTokenXX",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_16(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "playbackaccesstoken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_17(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PLAYBACKACCESSTOKEN",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_18(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "Playbackaccesstoken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_19(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "XX0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712XX",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_20(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119DED1C13477966434E15800FF57DDACF13BA1911C129DC2200705B0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_21(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "XXXX",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_22(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_23(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_24(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "XXXX",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_25(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = None

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_26(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            None,
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_27(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            None,
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_28(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_29(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_30(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "XXvalueXX": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_31(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "VALUE": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_32(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "Value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_33(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "XXsignatureXX": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_34(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "SIGNATURE": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_35(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "Signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_36(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get(None, "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_37(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", None),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_38(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_39(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", ),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_40(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("XXsignatureXX", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_41(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("SIGNATURE", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_42(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("Signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_43(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "XXvalueXX"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_44(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "VALUE"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_45(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "Value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_46(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = None
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_47(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = None

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_48(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["XXDevice-IdXX"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_49(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["device-id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_50(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["DEVICE-ID"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_51(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_52(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["XXClient-IntegrityXX"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_53(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["client-integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_54(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["CLIENT-INTEGRITY"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_55(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_56(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            None,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_57(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=None,
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_58(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=None,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_59(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=None,
        )

    def xǁTwitchAPIǁaccess_token__mutmut_60(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_61(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_62(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_63(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            )

    def xǁTwitchAPIǁaccess_token__mutmut_64(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(201, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_65(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 401, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_66(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 402, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_67(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 404),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_68(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                None,
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_69(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                None,
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_70(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                None,
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_71(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_72(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_73(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_74(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    None,
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_75(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    None,
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_76(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    None,
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_77(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_78(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_79(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_80(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"XXerrorsXX": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_81(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"ERRORS": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_82(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"Errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_83(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"XXmessageXX": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_84(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"MESSAGE": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_85(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"Message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_86(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(None),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_87(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("XXerrorsXX", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_88(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("ERRORS", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_89(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("Errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_90(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 1, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_91(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "XXmessageXX")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_92(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "MESSAGE")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_93(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "Message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_94(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(None),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_95(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: None),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_96(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("XXerrorXX", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_97(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("ERROR", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_98(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("Error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_99(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    None,
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_100(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    None,
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_101(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    None,
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_102(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_103(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_104(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_105(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"XXerrorXX": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_106(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"ERROR": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_107(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"Error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_108(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "XXmessageXX": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_109(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "MESSAGE": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_110(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "Message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_111(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get(None, "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_112(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", None),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_113(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_114(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", ),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_115(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("XXerrorXX", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_116(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("ERROR", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_117(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("Error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_118(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "XXmessageXX"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_119(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "MESSAGE"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_120(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "Message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_121(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(None),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_122(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: None),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_123(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("XXerrorXX", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_124(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("ERROR", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_125(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("Error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_126(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    None,
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_127(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    None,
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_128(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    None,
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_129(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_130(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_131(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_132(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "XXdataXX": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_133(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "DATA": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_134(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "Data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_135(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            None,
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_136(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            None,
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_137(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_138(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_139(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                None,
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_140(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                None,
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_141(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_142(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_143(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"XXstreamPlaybackAccessTokenXX": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_144(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamplaybackaccesstoken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_145(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"STREAMPLAYBACKACCESSTOKEN": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_146(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"Streamplaybackaccesstoken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_147(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get(None),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_148(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("XXstreamPlaybackAccessTokenXX"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_149(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamplaybackaccesstoken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_150(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("STREAMPLAYBACKACCESSTOKEN"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_151(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("Streamplaybackaccesstoken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_152(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                None,
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_153(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                None,
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_154(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_155(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_156(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"XXvideoPlaybackAccessTokenXX": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_157(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoplaybackaccesstoken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_158(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"VIDEOPLAYBACKACCESSTOKEN": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_159(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"Videoplaybackaccesstoken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_160(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get(None),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_161(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("XXvideoPlaybackAccessTokenXX"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_162(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoplaybackaccesstoken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_163(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("VIDEOPLAYBACKACCESSTOKEN"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_164(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("Videoplaybackaccesstoken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_165(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get(None),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_166(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("XXdataXX"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_167(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("DATA"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_168(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("Data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_169(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(None),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_170(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: None),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_171(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("XXtokenXX", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_172(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("TOKEN", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_173(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("Token", *data) if data is not None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_174(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is None else ("token", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_175(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("XXtokenXX", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_176(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("TOKEN", None, None)),
                ),
            ),
        )

    def xǁTwitchAPIǁaccess_token__mutmut_177(self, is_live, channel_or_vod, client_integrity: tuple[str, str] | None = None):
        query = self._gql_persisted_query(
            "PlaybackAccessToken",
            "0828119ded1c13477966434e15800ff57ddacf13ba1911c129dc2200705b0712",
            isLive=is_live,
            login=channel_or_vod if is_live else "",
            isVod=not is_live,
            vodID=channel_or_vod if not is_live else "",
            **self.access_token_params,
        )
        subschema = validate.none_or_all(
            {
                "value": str,
                "signature": str,
            },
            validate.union_get("signature", "value"),
        )

        headers = {}
        if client_integrity:
            headers["Device-Id"], headers["Client-Integrity"] = client_integrity

        return self.call(
            query,
            acceptable_status=(200, 400, 401, 403),
            headers=headers,
            schema=validate.any(
                validate.all(
                    {"errors": [{"message": str}]},
                    validate.get(("errors", 0, "message")),
                    validate.transform(lambda data: ("error", None, data)),
                ),
                validate.all(
                    {"error": str, "message": str},
                    validate.union_get("error", "message"),
                    validate.transform(lambda data: ("error", *data)),
                ),
                validate.all(
                    {
                        "data": validate.any(
                            validate.all(
                                {"streamPlaybackAccessToken": subschema},
                                validate.get("streamPlaybackAccessToken"),
                            ),
                            validate.all(
                                {"videoPlaybackAccessToken": subschema},
                                validate.get("videoPlaybackAccessToken"),
                            ),
                        ),
                    },
                    validate.get("data"),
                    validate.transform(lambda data: ("token", *data) if data is not None else ("Token", None, None)),
                ),
            ),
        )
    
    xǁTwitchAPIǁaccess_token__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchAPIǁaccess_token__mutmut_1': xǁTwitchAPIǁaccess_token__mutmut_1, 
        'xǁTwitchAPIǁaccess_token__mutmut_2': xǁTwitchAPIǁaccess_token__mutmut_2, 
        'xǁTwitchAPIǁaccess_token__mutmut_3': xǁTwitchAPIǁaccess_token__mutmut_3, 
        'xǁTwitchAPIǁaccess_token__mutmut_4': xǁTwitchAPIǁaccess_token__mutmut_4, 
        'xǁTwitchAPIǁaccess_token__mutmut_5': xǁTwitchAPIǁaccess_token__mutmut_5, 
        'xǁTwitchAPIǁaccess_token__mutmut_6': xǁTwitchAPIǁaccess_token__mutmut_6, 
        'xǁTwitchAPIǁaccess_token__mutmut_7': xǁTwitchAPIǁaccess_token__mutmut_7, 
        'xǁTwitchAPIǁaccess_token__mutmut_8': xǁTwitchAPIǁaccess_token__mutmut_8, 
        'xǁTwitchAPIǁaccess_token__mutmut_9': xǁTwitchAPIǁaccess_token__mutmut_9, 
        'xǁTwitchAPIǁaccess_token__mutmut_10': xǁTwitchAPIǁaccess_token__mutmut_10, 
        'xǁTwitchAPIǁaccess_token__mutmut_11': xǁTwitchAPIǁaccess_token__mutmut_11, 
        'xǁTwitchAPIǁaccess_token__mutmut_12': xǁTwitchAPIǁaccess_token__mutmut_12, 
        'xǁTwitchAPIǁaccess_token__mutmut_13': xǁTwitchAPIǁaccess_token__mutmut_13, 
        'xǁTwitchAPIǁaccess_token__mutmut_14': xǁTwitchAPIǁaccess_token__mutmut_14, 
        'xǁTwitchAPIǁaccess_token__mutmut_15': xǁTwitchAPIǁaccess_token__mutmut_15, 
        'xǁTwitchAPIǁaccess_token__mutmut_16': xǁTwitchAPIǁaccess_token__mutmut_16, 
        'xǁTwitchAPIǁaccess_token__mutmut_17': xǁTwitchAPIǁaccess_token__mutmut_17, 
        'xǁTwitchAPIǁaccess_token__mutmut_18': xǁTwitchAPIǁaccess_token__mutmut_18, 
        'xǁTwitchAPIǁaccess_token__mutmut_19': xǁTwitchAPIǁaccess_token__mutmut_19, 
        'xǁTwitchAPIǁaccess_token__mutmut_20': xǁTwitchAPIǁaccess_token__mutmut_20, 
        'xǁTwitchAPIǁaccess_token__mutmut_21': xǁTwitchAPIǁaccess_token__mutmut_21, 
        'xǁTwitchAPIǁaccess_token__mutmut_22': xǁTwitchAPIǁaccess_token__mutmut_22, 
        'xǁTwitchAPIǁaccess_token__mutmut_23': xǁTwitchAPIǁaccess_token__mutmut_23, 
        'xǁTwitchAPIǁaccess_token__mutmut_24': xǁTwitchAPIǁaccess_token__mutmut_24, 
        'xǁTwitchAPIǁaccess_token__mutmut_25': xǁTwitchAPIǁaccess_token__mutmut_25, 
        'xǁTwitchAPIǁaccess_token__mutmut_26': xǁTwitchAPIǁaccess_token__mutmut_26, 
        'xǁTwitchAPIǁaccess_token__mutmut_27': xǁTwitchAPIǁaccess_token__mutmut_27, 
        'xǁTwitchAPIǁaccess_token__mutmut_28': xǁTwitchAPIǁaccess_token__mutmut_28, 
        'xǁTwitchAPIǁaccess_token__mutmut_29': xǁTwitchAPIǁaccess_token__mutmut_29, 
        'xǁTwitchAPIǁaccess_token__mutmut_30': xǁTwitchAPIǁaccess_token__mutmut_30, 
        'xǁTwitchAPIǁaccess_token__mutmut_31': xǁTwitchAPIǁaccess_token__mutmut_31, 
        'xǁTwitchAPIǁaccess_token__mutmut_32': xǁTwitchAPIǁaccess_token__mutmut_32, 
        'xǁTwitchAPIǁaccess_token__mutmut_33': xǁTwitchAPIǁaccess_token__mutmut_33, 
        'xǁTwitchAPIǁaccess_token__mutmut_34': xǁTwitchAPIǁaccess_token__mutmut_34, 
        'xǁTwitchAPIǁaccess_token__mutmut_35': xǁTwitchAPIǁaccess_token__mutmut_35, 
        'xǁTwitchAPIǁaccess_token__mutmut_36': xǁTwitchAPIǁaccess_token__mutmut_36, 
        'xǁTwitchAPIǁaccess_token__mutmut_37': xǁTwitchAPIǁaccess_token__mutmut_37, 
        'xǁTwitchAPIǁaccess_token__mutmut_38': xǁTwitchAPIǁaccess_token__mutmut_38, 
        'xǁTwitchAPIǁaccess_token__mutmut_39': xǁTwitchAPIǁaccess_token__mutmut_39, 
        'xǁTwitchAPIǁaccess_token__mutmut_40': xǁTwitchAPIǁaccess_token__mutmut_40, 
        'xǁTwitchAPIǁaccess_token__mutmut_41': xǁTwitchAPIǁaccess_token__mutmut_41, 
        'xǁTwitchAPIǁaccess_token__mutmut_42': xǁTwitchAPIǁaccess_token__mutmut_42, 
        'xǁTwitchAPIǁaccess_token__mutmut_43': xǁTwitchAPIǁaccess_token__mutmut_43, 
        'xǁTwitchAPIǁaccess_token__mutmut_44': xǁTwitchAPIǁaccess_token__mutmut_44, 
        'xǁTwitchAPIǁaccess_token__mutmut_45': xǁTwitchAPIǁaccess_token__mutmut_45, 
        'xǁTwitchAPIǁaccess_token__mutmut_46': xǁTwitchAPIǁaccess_token__mutmut_46, 
        'xǁTwitchAPIǁaccess_token__mutmut_47': xǁTwitchAPIǁaccess_token__mutmut_47, 
        'xǁTwitchAPIǁaccess_token__mutmut_48': xǁTwitchAPIǁaccess_token__mutmut_48, 
        'xǁTwitchAPIǁaccess_token__mutmut_49': xǁTwitchAPIǁaccess_token__mutmut_49, 
        'xǁTwitchAPIǁaccess_token__mutmut_50': xǁTwitchAPIǁaccess_token__mutmut_50, 
        'xǁTwitchAPIǁaccess_token__mutmut_51': xǁTwitchAPIǁaccess_token__mutmut_51, 
        'xǁTwitchAPIǁaccess_token__mutmut_52': xǁTwitchAPIǁaccess_token__mutmut_52, 
        'xǁTwitchAPIǁaccess_token__mutmut_53': xǁTwitchAPIǁaccess_token__mutmut_53, 
        'xǁTwitchAPIǁaccess_token__mutmut_54': xǁTwitchAPIǁaccess_token__mutmut_54, 
        'xǁTwitchAPIǁaccess_token__mutmut_55': xǁTwitchAPIǁaccess_token__mutmut_55, 
        'xǁTwitchAPIǁaccess_token__mutmut_56': xǁTwitchAPIǁaccess_token__mutmut_56, 
        'xǁTwitchAPIǁaccess_token__mutmut_57': xǁTwitchAPIǁaccess_token__mutmut_57, 
        'xǁTwitchAPIǁaccess_token__mutmut_58': xǁTwitchAPIǁaccess_token__mutmut_58, 
        'xǁTwitchAPIǁaccess_token__mutmut_59': xǁTwitchAPIǁaccess_token__mutmut_59, 
        'xǁTwitchAPIǁaccess_token__mutmut_60': xǁTwitchAPIǁaccess_token__mutmut_60, 
        'xǁTwitchAPIǁaccess_token__mutmut_61': xǁTwitchAPIǁaccess_token__mutmut_61, 
        'xǁTwitchAPIǁaccess_token__mutmut_62': xǁTwitchAPIǁaccess_token__mutmut_62, 
        'xǁTwitchAPIǁaccess_token__mutmut_63': xǁTwitchAPIǁaccess_token__mutmut_63, 
        'xǁTwitchAPIǁaccess_token__mutmut_64': xǁTwitchAPIǁaccess_token__mutmut_64, 
        'xǁTwitchAPIǁaccess_token__mutmut_65': xǁTwitchAPIǁaccess_token__mutmut_65, 
        'xǁTwitchAPIǁaccess_token__mutmut_66': xǁTwitchAPIǁaccess_token__mutmut_66, 
        'xǁTwitchAPIǁaccess_token__mutmut_67': xǁTwitchAPIǁaccess_token__mutmut_67, 
        'xǁTwitchAPIǁaccess_token__mutmut_68': xǁTwitchAPIǁaccess_token__mutmut_68, 
        'xǁTwitchAPIǁaccess_token__mutmut_69': xǁTwitchAPIǁaccess_token__mutmut_69, 
        'xǁTwitchAPIǁaccess_token__mutmut_70': xǁTwitchAPIǁaccess_token__mutmut_70, 
        'xǁTwitchAPIǁaccess_token__mutmut_71': xǁTwitchAPIǁaccess_token__mutmut_71, 
        'xǁTwitchAPIǁaccess_token__mutmut_72': xǁTwitchAPIǁaccess_token__mutmut_72, 
        'xǁTwitchAPIǁaccess_token__mutmut_73': xǁTwitchAPIǁaccess_token__mutmut_73, 
        'xǁTwitchAPIǁaccess_token__mutmut_74': xǁTwitchAPIǁaccess_token__mutmut_74, 
        'xǁTwitchAPIǁaccess_token__mutmut_75': xǁTwitchAPIǁaccess_token__mutmut_75, 
        'xǁTwitchAPIǁaccess_token__mutmut_76': xǁTwitchAPIǁaccess_token__mutmut_76, 
        'xǁTwitchAPIǁaccess_token__mutmut_77': xǁTwitchAPIǁaccess_token__mutmut_77, 
        'xǁTwitchAPIǁaccess_token__mutmut_78': xǁTwitchAPIǁaccess_token__mutmut_78, 
        'xǁTwitchAPIǁaccess_token__mutmut_79': xǁTwitchAPIǁaccess_token__mutmut_79, 
        'xǁTwitchAPIǁaccess_token__mutmut_80': xǁTwitchAPIǁaccess_token__mutmut_80, 
        'xǁTwitchAPIǁaccess_token__mutmut_81': xǁTwitchAPIǁaccess_token__mutmut_81, 
        'xǁTwitchAPIǁaccess_token__mutmut_82': xǁTwitchAPIǁaccess_token__mutmut_82, 
        'xǁTwitchAPIǁaccess_token__mutmut_83': xǁTwitchAPIǁaccess_token__mutmut_83, 
        'xǁTwitchAPIǁaccess_token__mutmut_84': xǁTwitchAPIǁaccess_token__mutmut_84, 
        'xǁTwitchAPIǁaccess_token__mutmut_85': xǁTwitchAPIǁaccess_token__mutmut_85, 
        'xǁTwitchAPIǁaccess_token__mutmut_86': xǁTwitchAPIǁaccess_token__mutmut_86, 
        'xǁTwitchAPIǁaccess_token__mutmut_87': xǁTwitchAPIǁaccess_token__mutmut_87, 
        'xǁTwitchAPIǁaccess_token__mutmut_88': xǁTwitchAPIǁaccess_token__mutmut_88, 
        'xǁTwitchAPIǁaccess_token__mutmut_89': xǁTwitchAPIǁaccess_token__mutmut_89, 
        'xǁTwitchAPIǁaccess_token__mutmut_90': xǁTwitchAPIǁaccess_token__mutmut_90, 
        'xǁTwitchAPIǁaccess_token__mutmut_91': xǁTwitchAPIǁaccess_token__mutmut_91, 
        'xǁTwitchAPIǁaccess_token__mutmut_92': xǁTwitchAPIǁaccess_token__mutmut_92, 
        'xǁTwitchAPIǁaccess_token__mutmut_93': xǁTwitchAPIǁaccess_token__mutmut_93, 
        'xǁTwitchAPIǁaccess_token__mutmut_94': xǁTwitchAPIǁaccess_token__mutmut_94, 
        'xǁTwitchAPIǁaccess_token__mutmut_95': xǁTwitchAPIǁaccess_token__mutmut_95, 
        'xǁTwitchAPIǁaccess_token__mutmut_96': xǁTwitchAPIǁaccess_token__mutmut_96, 
        'xǁTwitchAPIǁaccess_token__mutmut_97': xǁTwitchAPIǁaccess_token__mutmut_97, 
        'xǁTwitchAPIǁaccess_token__mutmut_98': xǁTwitchAPIǁaccess_token__mutmut_98, 
        'xǁTwitchAPIǁaccess_token__mutmut_99': xǁTwitchAPIǁaccess_token__mutmut_99, 
        'xǁTwitchAPIǁaccess_token__mutmut_100': xǁTwitchAPIǁaccess_token__mutmut_100, 
        'xǁTwitchAPIǁaccess_token__mutmut_101': xǁTwitchAPIǁaccess_token__mutmut_101, 
        'xǁTwitchAPIǁaccess_token__mutmut_102': xǁTwitchAPIǁaccess_token__mutmut_102, 
        'xǁTwitchAPIǁaccess_token__mutmut_103': xǁTwitchAPIǁaccess_token__mutmut_103, 
        'xǁTwitchAPIǁaccess_token__mutmut_104': xǁTwitchAPIǁaccess_token__mutmut_104, 
        'xǁTwitchAPIǁaccess_token__mutmut_105': xǁTwitchAPIǁaccess_token__mutmut_105, 
        'xǁTwitchAPIǁaccess_token__mutmut_106': xǁTwitchAPIǁaccess_token__mutmut_106, 
        'xǁTwitchAPIǁaccess_token__mutmut_107': xǁTwitchAPIǁaccess_token__mutmut_107, 
        'xǁTwitchAPIǁaccess_token__mutmut_108': xǁTwitchAPIǁaccess_token__mutmut_108, 
        'xǁTwitchAPIǁaccess_token__mutmut_109': xǁTwitchAPIǁaccess_token__mutmut_109, 
        'xǁTwitchAPIǁaccess_token__mutmut_110': xǁTwitchAPIǁaccess_token__mutmut_110, 
        'xǁTwitchAPIǁaccess_token__mutmut_111': xǁTwitchAPIǁaccess_token__mutmut_111, 
        'xǁTwitchAPIǁaccess_token__mutmut_112': xǁTwitchAPIǁaccess_token__mutmut_112, 
        'xǁTwitchAPIǁaccess_token__mutmut_113': xǁTwitchAPIǁaccess_token__mutmut_113, 
        'xǁTwitchAPIǁaccess_token__mutmut_114': xǁTwitchAPIǁaccess_token__mutmut_114, 
        'xǁTwitchAPIǁaccess_token__mutmut_115': xǁTwitchAPIǁaccess_token__mutmut_115, 
        'xǁTwitchAPIǁaccess_token__mutmut_116': xǁTwitchAPIǁaccess_token__mutmut_116, 
        'xǁTwitchAPIǁaccess_token__mutmut_117': xǁTwitchAPIǁaccess_token__mutmut_117, 
        'xǁTwitchAPIǁaccess_token__mutmut_118': xǁTwitchAPIǁaccess_token__mutmut_118, 
        'xǁTwitchAPIǁaccess_token__mutmut_119': xǁTwitchAPIǁaccess_token__mutmut_119, 
        'xǁTwitchAPIǁaccess_token__mutmut_120': xǁTwitchAPIǁaccess_token__mutmut_120, 
        'xǁTwitchAPIǁaccess_token__mutmut_121': xǁTwitchAPIǁaccess_token__mutmut_121, 
        'xǁTwitchAPIǁaccess_token__mutmut_122': xǁTwitchAPIǁaccess_token__mutmut_122, 
        'xǁTwitchAPIǁaccess_token__mutmut_123': xǁTwitchAPIǁaccess_token__mutmut_123, 
        'xǁTwitchAPIǁaccess_token__mutmut_124': xǁTwitchAPIǁaccess_token__mutmut_124, 
        'xǁTwitchAPIǁaccess_token__mutmut_125': xǁTwitchAPIǁaccess_token__mutmut_125, 
        'xǁTwitchAPIǁaccess_token__mutmut_126': xǁTwitchAPIǁaccess_token__mutmut_126, 
        'xǁTwitchAPIǁaccess_token__mutmut_127': xǁTwitchAPIǁaccess_token__mutmut_127, 
        'xǁTwitchAPIǁaccess_token__mutmut_128': xǁTwitchAPIǁaccess_token__mutmut_128, 
        'xǁTwitchAPIǁaccess_token__mutmut_129': xǁTwitchAPIǁaccess_token__mutmut_129, 
        'xǁTwitchAPIǁaccess_token__mutmut_130': xǁTwitchAPIǁaccess_token__mutmut_130, 
        'xǁTwitchAPIǁaccess_token__mutmut_131': xǁTwitchAPIǁaccess_token__mutmut_131, 
        'xǁTwitchAPIǁaccess_token__mutmut_132': xǁTwitchAPIǁaccess_token__mutmut_132, 
        'xǁTwitchAPIǁaccess_token__mutmut_133': xǁTwitchAPIǁaccess_token__mutmut_133, 
        'xǁTwitchAPIǁaccess_token__mutmut_134': xǁTwitchAPIǁaccess_token__mutmut_134, 
        'xǁTwitchAPIǁaccess_token__mutmut_135': xǁTwitchAPIǁaccess_token__mutmut_135, 
        'xǁTwitchAPIǁaccess_token__mutmut_136': xǁTwitchAPIǁaccess_token__mutmut_136, 
        'xǁTwitchAPIǁaccess_token__mutmut_137': xǁTwitchAPIǁaccess_token__mutmut_137, 
        'xǁTwitchAPIǁaccess_token__mutmut_138': xǁTwitchAPIǁaccess_token__mutmut_138, 
        'xǁTwitchAPIǁaccess_token__mutmut_139': xǁTwitchAPIǁaccess_token__mutmut_139, 
        'xǁTwitchAPIǁaccess_token__mutmut_140': xǁTwitchAPIǁaccess_token__mutmut_140, 
        'xǁTwitchAPIǁaccess_token__mutmut_141': xǁTwitchAPIǁaccess_token__mutmut_141, 
        'xǁTwitchAPIǁaccess_token__mutmut_142': xǁTwitchAPIǁaccess_token__mutmut_142, 
        'xǁTwitchAPIǁaccess_token__mutmut_143': xǁTwitchAPIǁaccess_token__mutmut_143, 
        'xǁTwitchAPIǁaccess_token__mutmut_144': xǁTwitchAPIǁaccess_token__mutmut_144, 
        'xǁTwitchAPIǁaccess_token__mutmut_145': xǁTwitchAPIǁaccess_token__mutmut_145, 
        'xǁTwitchAPIǁaccess_token__mutmut_146': xǁTwitchAPIǁaccess_token__mutmut_146, 
        'xǁTwitchAPIǁaccess_token__mutmut_147': xǁTwitchAPIǁaccess_token__mutmut_147, 
        'xǁTwitchAPIǁaccess_token__mutmut_148': xǁTwitchAPIǁaccess_token__mutmut_148, 
        'xǁTwitchAPIǁaccess_token__mutmut_149': xǁTwitchAPIǁaccess_token__mutmut_149, 
        'xǁTwitchAPIǁaccess_token__mutmut_150': xǁTwitchAPIǁaccess_token__mutmut_150, 
        'xǁTwitchAPIǁaccess_token__mutmut_151': xǁTwitchAPIǁaccess_token__mutmut_151, 
        'xǁTwitchAPIǁaccess_token__mutmut_152': xǁTwitchAPIǁaccess_token__mutmut_152, 
        'xǁTwitchAPIǁaccess_token__mutmut_153': xǁTwitchAPIǁaccess_token__mutmut_153, 
        'xǁTwitchAPIǁaccess_token__mutmut_154': xǁTwitchAPIǁaccess_token__mutmut_154, 
        'xǁTwitchAPIǁaccess_token__mutmut_155': xǁTwitchAPIǁaccess_token__mutmut_155, 
        'xǁTwitchAPIǁaccess_token__mutmut_156': xǁTwitchAPIǁaccess_token__mutmut_156, 
        'xǁTwitchAPIǁaccess_token__mutmut_157': xǁTwitchAPIǁaccess_token__mutmut_157, 
        'xǁTwitchAPIǁaccess_token__mutmut_158': xǁTwitchAPIǁaccess_token__mutmut_158, 
        'xǁTwitchAPIǁaccess_token__mutmut_159': xǁTwitchAPIǁaccess_token__mutmut_159, 
        'xǁTwitchAPIǁaccess_token__mutmut_160': xǁTwitchAPIǁaccess_token__mutmut_160, 
        'xǁTwitchAPIǁaccess_token__mutmut_161': xǁTwitchAPIǁaccess_token__mutmut_161, 
        'xǁTwitchAPIǁaccess_token__mutmut_162': xǁTwitchAPIǁaccess_token__mutmut_162, 
        'xǁTwitchAPIǁaccess_token__mutmut_163': xǁTwitchAPIǁaccess_token__mutmut_163, 
        'xǁTwitchAPIǁaccess_token__mutmut_164': xǁTwitchAPIǁaccess_token__mutmut_164, 
        'xǁTwitchAPIǁaccess_token__mutmut_165': xǁTwitchAPIǁaccess_token__mutmut_165, 
        'xǁTwitchAPIǁaccess_token__mutmut_166': xǁTwitchAPIǁaccess_token__mutmut_166, 
        'xǁTwitchAPIǁaccess_token__mutmut_167': xǁTwitchAPIǁaccess_token__mutmut_167, 
        'xǁTwitchAPIǁaccess_token__mutmut_168': xǁTwitchAPIǁaccess_token__mutmut_168, 
        'xǁTwitchAPIǁaccess_token__mutmut_169': xǁTwitchAPIǁaccess_token__mutmut_169, 
        'xǁTwitchAPIǁaccess_token__mutmut_170': xǁTwitchAPIǁaccess_token__mutmut_170, 
        'xǁTwitchAPIǁaccess_token__mutmut_171': xǁTwitchAPIǁaccess_token__mutmut_171, 
        'xǁTwitchAPIǁaccess_token__mutmut_172': xǁTwitchAPIǁaccess_token__mutmut_172, 
        'xǁTwitchAPIǁaccess_token__mutmut_173': xǁTwitchAPIǁaccess_token__mutmut_173, 
        'xǁTwitchAPIǁaccess_token__mutmut_174': xǁTwitchAPIǁaccess_token__mutmut_174, 
        'xǁTwitchAPIǁaccess_token__mutmut_175': xǁTwitchAPIǁaccess_token__mutmut_175, 
        'xǁTwitchAPIǁaccess_token__mutmut_176': xǁTwitchAPIǁaccess_token__mutmut_176, 
        'xǁTwitchAPIǁaccess_token__mutmut_177': xǁTwitchAPIǁaccess_token__mutmut_177
    }
    
    def access_token(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchAPIǁaccess_token__mutmut_orig"), object.__getattribute__(self, "xǁTwitchAPIǁaccess_token__mutmut_mutants"), args, kwargs, self)
        return result 
    
    access_token.__signature__ = _mutmut_signature(xǁTwitchAPIǁaccess_token__mutmut_orig)
    xǁTwitchAPIǁaccess_token__mutmut_orig.__name__ = 'xǁTwitchAPIǁaccess_token'

    def xǁTwitchAPIǁclips__mutmut_orig(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_1(self, clipname):
        query = None

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_2(self, clipname):
        query = self._gql_persisted_query(
            None,
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_3(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            None,
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_4(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=None,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_5(self, clipname):
        query = self._gql_persisted_query(
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_6(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_7(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_8(self, clipname):
        query = self._gql_persisted_query(
            "XXVideoAccessToken_ClipXX",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_9(self, clipname):
        query = self._gql_persisted_query(
            "videoaccesstoken_clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_10(self, clipname):
        query = self._gql_persisted_query(
            "VIDEOACCESSTOKEN_CLIP",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_11(self, clipname):
        query = self._gql_persisted_query(
            "Videoaccesstoken_clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_12(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "XX36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11XX",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_13(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36B89D2507FCE29E5CA551DF756D27C1CFE079E2609642B4390AA4C35796EB11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_14(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            None,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_15(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=None,
        )

    def xǁTwitchAPIǁclips__mutmut_16(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_17(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            )

    def xǁTwitchAPIǁclips__mutmut_18(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                None,
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_19(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                None,
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_20(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                None,
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_21(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_22(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_23(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                ),
        )

    def xǁTwitchAPIǁclips__mutmut_24(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "XXdataXX": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_25(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "DATA": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_26(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "Data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_27(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "XXclipXX": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_28(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "CLIP": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_29(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "Clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_30(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "XXplaybackAccessTokenXX": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_31(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackaccesstoken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_32(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "PLAYBACKACCESSTOKEN": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_33(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "Playbackaccesstoken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_34(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "XXsignatureXX": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_35(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "SIGNATURE": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_36(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "Signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_37(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "XXvalueXX": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_38(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "VALUE": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_39(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "Value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_40(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "XXvideoQualitiesXX": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_41(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoqualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_42(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "VIDEOQUALITIES": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_43(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "Videoqualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_44(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    None,
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_45(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    None,
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_46(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_47(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_48(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "XXframeRateXX": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_49(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "framerate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_50(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "FRAMERATE": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_51(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "Framerate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_52(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(None),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_53(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "XXqualityXX": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_54(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "QUALITY": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_55(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "Quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_56(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "XXsourceURLXX": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_57(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceurl": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_58(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "SOURCEURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_59(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "Sourceurl": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_60(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        None,
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_61(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: None,
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_62(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['XXqualityXX']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_63(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['QUALITY']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_64(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['Quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_65(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['XXframeRateXX']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_66(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['framerate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_67(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['FRAMERATE']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_68(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['Framerate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_69(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["XXsourceURLXX"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_70(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceurl"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_71(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["SOURCEURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_72(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["Sourceurl"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_73(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(None),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_74(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("XXdataXX", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_75(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("DATA", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_76(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("Data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_77(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "XXclipXX")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_78(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "CLIP")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_79(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "Clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_80(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    None,
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_81(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    None,
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_82(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    None,
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_83(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_84(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_85(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_86(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("XXplaybackAccessTokenXX", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_87(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackaccesstoken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_88(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("PLAYBACKACCESSTOKEN", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_89(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("Playbackaccesstoken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_90(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "XXsignatureXX"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_91(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "SIGNATURE"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_92(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "Signature"),
                    ("playbackAccessToken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_93(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("XXplaybackAccessTokenXX", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_94(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackaccesstoken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_95(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("PLAYBACKACCESSTOKEN", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_96(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("Playbackaccesstoken", "value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_97(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "XXvalueXX"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_98(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "VALUE"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_99(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "Value"),
                    "videoQualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_100(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "XXvideoQualitiesXX",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_101(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "videoqualities",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_102(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "VIDEOQUALITIES",
                ),
            ),
        )

    def xǁTwitchAPIǁclips__mutmut_103(self, clipname):
        query = self._gql_persisted_query(
            "VideoAccessToken_Clip",
            "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11",
            slug=clipname,
        )

        return self.call(
            query,
            schema=validate.all(
                {
                    "data": {
                        "clip": {
                            "playbackAccessToken": {
                                "signature": str,
                                "value": str,
                            },
                            "videoQualities": [
                                validate.all(
                                    {
                                        "frameRate": validate.transform(int),
                                        "quality": str,
                                        "sourceURL": validate.url(),
                                    },
                                    validate.transform(
                                        lambda q: (
                                            f"{q['quality']}p{q['frameRate']}",
                                            q["sourceURL"],
                                        ),
                                    ),
                                ),
                            ],
                        },
                    },
                },
                validate.get(("data", "clip")),
                validate.union_get(
                    ("playbackAccessToken", "signature"),
                    ("playbackAccessToken", "value"),
                    "Videoqualities",
                ),
            ),
        )
    
    xǁTwitchAPIǁclips__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁTwitchAPIǁclips__mutmut_1': xǁTwitchAPIǁclips__mutmut_1, 
        'xǁTwitchAPIǁclips__mutmut_2': xǁTwitchAPIǁclips__mutmut_2, 
        'xǁTwitchAPIǁclips__mutmut_3': xǁTwitchAPIǁclips__mutmut_3, 
        'xǁTwitchAPIǁclips__mutmut_4': xǁTwitchAPIǁclips__mutmut_4, 
        'xǁTwitchAPIǁclips__mutmut_5': xǁTwitchAPIǁclips__mutmut_5, 
        'xǁTwitchAPIǁclips__mutmut_6': xǁTwitchAPIǁclips__mutmut_6, 
        'xǁTwitchAPIǁclips__mutmut_7': xǁTwitchAPIǁclips__mutmut_7, 
        'xǁTwitchAPIǁclips__mutmut_8': xǁTwitchAPIǁclips__mutmut_8, 
        'xǁTwitchAPIǁclips__mutmut_9': xǁTwitchAPIǁclips__mutmut_9, 
        'xǁTwitchAPIǁclips__mutmut_10': xǁTwitchAPIǁclips__mutmut_10, 
        'xǁTwitchAPIǁclips__mutmut_11': xǁTwitchAPIǁclips__mutmut_11, 
        'xǁTwitchAPIǁclips__mutmut_12': xǁTwitchAPIǁclips__mutmut_12, 
        'xǁTwitchAPIǁclips__mutmut_13': xǁTwitchAPIǁclips__mutmut_13, 
        'xǁTwitchAPIǁclips__mutmut_14': xǁTwitchAPIǁclips__mutmut_14, 
        'xǁTwitchAPIǁclips__mutmut_15': xǁTwitchAPIǁclips__mutmut_15, 
        'xǁTwitchAPIǁclips__mutmut_16': xǁTwitchAPIǁclips__mutmut_16, 
        'xǁTwitchAPIǁclips__mutmut_17': xǁTwitchAPIǁclips__mutmut_17, 
        'xǁTwitchAPIǁclips__mutmut_18': xǁTwitchAPIǁclips__mutmut_18, 
        'xǁTwitchAPIǁclips__mutmut_19': xǁTwitchAPIǁclips__mutmut_19, 
        'xǁTwitchAPIǁclips__mutmut_20': xǁTwitchAPIǁclips__mutmut_20, 
        'xǁTwitchAPIǁclips__mutmut_21': xǁTwitchAPIǁclips__mutmut_21, 
        'xǁTwitchAPIǁclips__mutmut_22': xǁTwitchAPIǁclips__mutmut_22, 
        'xǁTwitchAPIǁclips__mutmut_23': xǁTwitchAPIǁclips__mutmut_23, 
        'xǁTwitchAPIǁclips__mutmut_24': xǁTwitchAPIǁclips__mutmut_24, 
        'xǁTwitchAPIǁclips__mutmut_25': xǁTwitchAPIǁclips__mutmut_25, 
        'xǁTwitchAPIǁclips__mutmut_26': xǁTwitchAPIǁclips__mutmut_26, 
        'xǁTwitchAPIǁclips__mutmut_27': xǁTwitchAPIǁclips__mutmut_27, 
        'xǁTwitchAPIǁclips__mutmut_28': xǁTwitchAPIǁclips__mutmut_28, 
        'xǁTwitchAPIǁclips__mutmut_29': xǁTwitchAPIǁclips__mutmut_29, 
        'xǁTwitchAPIǁclips__mutmut_30': xǁTwitchAPIǁclips__mutmut_30, 
        'xǁTwitchAPIǁclips__mutmut_31': xǁTwitchAPIǁclips__mutmut_31, 
        'xǁTwitchAPIǁclips__mutmut_32': xǁTwitchAPIǁclips__mutmut_32, 
        'xǁTwitchAPIǁclips__mutmut_33': xǁTwitchAPIǁclips__mutmut_33, 
        'xǁTwitchAPIǁclips__mutmut_34': xǁTwitchAPIǁclips__mutmut_34, 
        'xǁTwitchAPIǁclips__mutmut_35': xǁTwitchAPIǁclips__mutmut_35, 
        'xǁTwitchAPIǁclips__mutmut_36': xǁTwitchAPIǁclips__mutmut_36, 
        'xǁTwitchAPIǁclips__mutmut_37': xǁTwitchAPIǁclips__mutmut_37, 
        'xǁTwitchAPIǁclips__mutmut_38': xǁTwitchAPIǁclips__mutmut_38, 
        'xǁTwitchAPIǁclips__mutmut_39': xǁTwitchAPIǁclips__mutmut_39, 
        'xǁTwitchAPIǁclips__mutmut_40': xǁTwitchAPIǁclips__mutmut_40, 
        'xǁTwitchAPIǁclips__mutmut_41': xǁTwitchAPIǁclips__mutmut_41, 
        'xǁTwitchAPIǁclips__mutmut_42': xǁTwitchAPIǁclips__mutmut_42, 
        'xǁTwitchAPIǁclips__mutmut_43': xǁTwitchAPIǁclips__mutmut_43, 
        'xǁTwitchAPIǁclips__mutmut_44': xǁTwitchAPIǁclips__mutmut_44, 
        'xǁTwitchAPIǁclips__mutmut_45': xǁTwitchAPIǁclips__mutmut_45, 
        'xǁTwitchAPIǁclips__mutmut_46': xǁTwitchAPIǁclips__mutmut_46, 
        'xǁTwitchAPIǁclips__mutmut_47': xǁTwitchAPIǁclips__mutmut_47, 
        'xǁTwitchAPIǁclips__mutmut_48': xǁTwitchAPIǁclips__mutmut_48, 
        'xǁTwitchAPIǁclips__mutmut_49': xǁTwitchAPIǁclips__mutmut_49, 
        'xǁTwitchAPIǁclips__mutmut_50': xǁTwitchAPIǁclips__mutmut_50, 
        'xǁTwitchAPIǁclips__mutmut_51': xǁTwitchAPIǁclips__mutmut_51, 
        'xǁTwitchAPIǁclips__mutmut_52': xǁTwitchAPIǁclips__mutmut_52, 
        'xǁTwitchAPIǁclips__mutmut_53': xǁTwitchAPIǁclips__mutmut_53, 
        'xǁTwitchAPIǁclips__mutmut_54': xǁTwitchAPIǁclips__mutmut_54, 
        'xǁTwitchAPIǁclips__mutmut_55': xǁTwitchAPIǁclips__mutmut_55, 
        'xǁTwitchAPIǁclips__mutmut_56': xǁTwitchAPIǁclips__mutmut_56, 
        'xǁTwitchAPIǁclips__mutmut_57': xǁTwitchAPIǁclips__mutmut_57, 
        'xǁTwitchAPIǁclips__mutmut_58': xǁTwitchAPIǁclips__mutmut_58, 
        'xǁTwitchAPIǁclips__mutmut_59': xǁTwitchAPIǁclips__mutmut_59, 
        'xǁTwitchAPIǁclips__mutmut_60': xǁTwitchAPIǁclips__mutmut_60, 
        'xǁTwitchAPIǁclips__mutmut_61': xǁTwitchAPIǁclips__mutmut_61, 
        'xǁTwitchAPIǁclips__mutmut_62': xǁTwitchAPIǁclips__mutmut_62, 
        'xǁTwitchAPIǁclips__mutmut_63': xǁTwitchAPIǁclips__mutmut_63, 
        'xǁTwitchAPIǁclips__mutmut_64': xǁTwitchAPIǁclips__mutmut_64, 
        'xǁTwitchAPIǁclips__mutmut_65': xǁTwitchAPIǁclips__mutmut_65, 
        'xǁTwitchAPIǁclips__mutmut_66': xǁTwitchAPIǁclips__mutmut_66, 
        'xǁTwitchAPIǁclips__mutmut_67': xǁTwitchAPIǁclips__mutmut_67, 
        'xǁTwitchAPIǁclips__mutmut_68': xǁTwitchAPIǁclips__mutmut_68, 
        'xǁTwitchAPIǁclips__mutmut_69': xǁTwitchAPIǁclips__mutmut_69, 
        'xǁTwitchAPIǁclips__mutmut_70': xǁTwitchAPIǁclips__mutmut_70, 
        'xǁTwitchAPIǁclips__mutmut_71': xǁTwitchAPIǁclips__mutmut_71, 
        'xǁTwitchAPIǁclips__mutmut_72': xǁTwitchAPIǁclips__mutmut_72, 
        'xǁTwitchAPIǁclips__mutmut_73': xǁTwitchAPIǁclips__mutmut_73, 
        'xǁTwitchAPIǁclips__mutmut_74': xǁTwitchAPIǁclips__mutmut_74, 
        'xǁTwitchAPIǁclips__mutmut_75': xǁTwitchAPIǁclips__mutmut_75, 
        'xǁTwitchAPIǁclips__mutmut_76': xǁTwitchAPIǁclips__mutmut_76, 
        'xǁTwitchAPIǁclips__mutmut_77': xǁTwitchAPIǁclips__mutmut_77, 
        'xǁTwitchAPIǁclips__mutmut_78': xǁTwitchAPIǁclips__mutmut_78, 
        'xǁTwitchAPIǁclips__mutmut_79': xǁTwitchAPIǁclips__mutmut_79, 
        'xǁTwitchAPIǁclips__mutmut_80': xǁTwitchAPIǁclips__mutmut_80, 
        'xǁTwitchAPIǁclips__mutmut_81': xǁTwitchAPIǁclips__mutmut_81, 
        'xǁTwitchAPIǁclips__mutmut_82': xǁTwitchAPIǁclips__mutmut_82, 
        'xǁTwitchAPIǁclips__mutmut_83': xǁTwitchAPIǁclips__mutmut_83, 
        'xǁTwitchAPIǁclips__mutmut_84': xǁTwitchAPIǁclips__mutmut_84, 
        'xǁTwitchAPIǁclips__mutmut_85': xǁTwitchAPIǁclips__mutmut_85, 
        'xǁTwitchAPIǁclips__mutmut_86': xǁTwitchAPIǁclips__mutmut_86, 
        'xǁTwitchAPIǁclips__mutmut_87': xǁTwitchAPIǁclips__mutmut_87, 
        'xǁTwitchAPIǁclips__mutmut_88': xǁTwitchAPIǁclips__mutmut_88, 
        'xǁTwitchAPIǁclips__mutmut_89': xǁTwitchAPIǁclips__mutmut_89, 
        'xǁTwitchAPIǁclips__mutmut_90': xǁTwitchAPIǁclips__mutmut_90, 
        'xǁTwitchAPIǁclips__mutmut_91': xǁTwitchAPIǁclips__mutmut_91, 
        'xǁTwitchAPIǁclips__mutmut_92': xǁTwitchAPIǁclips__mutmut_92, 
        'xǁTwitchAPIǁclips__mutmut_93': xǁTwitchAPIǁclips__mutmut_93, 
        'xǁTwitchAPIǁclips__mutmut_94': xǁTwitchAPIǁclips__mutmut_94, 
        'xǁTwitchAPIǁclips__mutmut_95': xǁTwitchAPIǁclips__mutmut_95, 
        'xǁTwitchAPIǁclips__mutmut_96': xǁTwitchAPIǁclips__mutmut_96, 
        'xǁTwitchAPIǁclips__mutmut_97': xǁTwitchAPIǁclips__mutmut_97, 
        'xǁTwitchAPIǁclips__mutmut_98': xǁTwitchAPIǁclips__mutmut_98, 
        'xǁTwitchAPIǁclips__mutmut_99': xǁTwitchAPIǁclips__mutmut_99, 
        'xǁTwitchAPIǁclips__mutmut_100': xǁTwitchAPIǁclips__mutmut_100, 
        'xǁTwitchAPIǁclips__mutmut_101': xǁTwitchAPIǁclips__mutmut_101, 
        'xǁTwitchAPIǁclips__mutmut_102': xǁTwitchAPIǁclips__mutmut_102, 
        'xǁTwitchAPIǁclips__mutmut_103': xǁTwitchAPIǁclips__mutmut_103
    }
    
    def clips(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁTwitchAPIǁclips__mutmut_orig"), object.__getattribute__(self, "xǁTwitchAPIǁclips__mutmut_mutants"), args, kwargs, self)
        return result 
    
    clips.__signature__ = _mutmut_signature(xǁTwitchAPIǁclips__mutmut_orig)
    xǁTwitchAPIǁclips__mutmut_orig.__name__ = 'xǁTwitchAPIǁclips'


class TwitchClientIntegrity:
    URL_P_SCRIPT = "https://k.twitchcdn.net/149e9513-01fa-4fb0-aad4-566afd725d1b/2d206a39-8ed7-437e-a3be-862e0f06eea3/p.js"

    # language=javascript
    JS_INTEGRITY_TOKEN = """
    // noinspection JSIgnoredPromiseFromCall
    new Promise((resolve, reject) => {
        function configureKPSDK() {
            // noinspection JSUnresolvedVariable,JSUnresolvedFunction
            window.KPSDK.configure([{
                "protocol": "https:",
                "method": "POST",
                "domain": "gql.twitch.tv",
                "path": "/integrity"
            }]);
        }

        async function fetchIntegrity() {
            // noinspection JSUnresolvedReference
            const headers = Object.assign(HEADERS, {"x-device-id": "DEVICE_ID"});
            // window.fetch gets overridden and the patched function needs to be used
            const resp = await window.fetch("https://gql.twitch.tv/integrity", {
                "headers": headers,
                "body": null,
                "method": "POST",
                "mode": "cors",
                "credentials": "omit"
            });

            if (resp.status !== 200) {
                throw new Error(`Unexpected integrity response status code ${resp.status}`);
            }

            return JSON.stringify(await resp.json());
        }

        document.addEventListener("kpsdk-load", configureKPSDK, {once: true});
        document.addEventListener("kpsdk-ready", () => fetchIntegrity().then(resolve, reject), {once: true});

        const script = document.createElement("script");
        script.addEventListener("error", reject);
        script.src = "SCRIPT_SOURCE";
        document.body.appendChild(script);
    });
    """

    @classmethod
    def acquire(
        cls,
        session: Streamlink,
        channel: str,
        headers: Mapping[str, str],
        device_id: str,
    ) -> tuple[str, int] | None:
        from streamlink.compat import BaseExceptionGroup  # noqa: PLC0415
        from streamlink.webbrowser.cdp import CDPClient, CDPClientSession, devtools  # noqa: PLC0415

        url = f"https://www.twitch.tv/{channel}"
        js_get_integrity_token = cls.JS_INTEGRITY_TOKEN \
            .replace("SCRIPT_SOURCE", cls.URL_P_SCRIPT) \
            .replace("HEADERS", json_dumps(headers)) \
            .replace("DEVICE_ID", device_id)  # fmt: skip
        eval_timeout = session.get_option("webbrowser-timeout")
        # noinspection PyUnusedLocal
        client_integrity: str | None = None

        async def on_main(client_session: CDPClientSession, request: devtools.fetch.RequestPaused):
            async with client_session.alter_request(request) as cm:
                cm.body = "<!doctype html>"

        async def acquire_client_integrity_token(client: CDPClient):
            client_session: CDPClientSession
            async with client.session() as client_session:
                client_session.add_request_handler(on_main, url_pattern=url, on_request=True)
                async with client_session.navigate(url) as frame_id:
                    await client_session.loaded(frame_id)
                    return await client_session.evaluate(js_get_integrity_token, timeout=eval_timeout)

        try:
            client_integrity = CDPClient.launch(session, acquire_client_integrity_token)
        except BaseExceptionGroup:
            log.exception("Failed acquiring client integrity token")
        except Exception as err:
            log.error(err)

        if not client_integrity:
            return None

        schema = validate.Schema(
            validate.parse_json(),
            {"token": str, "expiration": int},
            validate.union_get("token", "expiration"),
        )
        token, expiration = schema.validate(client_integrity)

        return token, expiration / 1000


@pluginmatcher(
    name="player",
    pattern=re.compile(
        r"https?://player\.twitch\.tv/\?.+",
    ),
)
@pluginmatcher(
    name="clip",
    pattern=re.compile(
        r"https?://(?:clips\.twitch\.tv|(?:[\w-]+\.)?twitch\.tv/(?:[\w-]+/)?clip)/(?P<clip_id>[^/?]+)",
    ),
)
@pluginmatcher(
    name="vod",
    pattern=re.compile(
        r"https?://(?:[\w-]+\.)?twitch\.tv/(?:[\w-]+/)?v(?:ideos?)?/(?P<video_id>\d+)",
    ),
)
@pluginmatcher(
    name="live",
    pattern=re.compile(
        r"https?://(?:(?!clips\.)[\w-]+\.)?twitch\.tv/(?P<channel>(?!v(?:ideos?)?/|clip/)[^/?]+)/?(?:\?|$)",
    ),
)
@pluginargument(
    "disable-ads",
    action="store_true",
    help="""
        Skip embedded advertisement segments at the beginning or during a stream.
        Will cause these segments to be missing from the output.
    """,
)
@pluginargument(
    "disable-hosting",
    action="store_true",
    help=argparse.SUPPRESS,
)
@pluginargument(
    "disable-reruns",
    action="store_true",
    help=argparse.SUPPRESS,
)
@pluginargument(
    "low-latency",
    action="store_true",
    help="""
        Enables low latency streaming by prefetching HLS segments.
        Sets --hls-segment-stream-data to true and --hls-live-edge to 2, if it is higher.
        Reducing --hls-live-edge to `1` will result in the lowest latency possible, but will most likely cause buffering.

        In order to achieve true low latency streaming during playback, the player's caching/buffering settings will
        need to be adjusted and reduced to a value as low as possible, but still high enough to not cause any buffering.
        This depends on the stream's bitrate and the quality of the connection to Twitch's servers. Please refer to the
        player's own documentation for the required configuration. Player parameters can be set via --player-args.

        Note: Low latency streams have to be enabled by the broadcasters on Twitch themselves.
        Regular streams can cause buffering issues with this option enabled due to the reduced --hls-live-edge value.
    """,
)
@pluginargument(
    "api-header",
    metavar="KEY=VALUE",
    type="keyvalue",
    action="append",
    help="""
        A header to add to each Twitch API HTTP request.

        Can be repeated to add multiple headers.

        Useful for adding authentication data that can prevent ads. See the plugin-specific documentation for more information.
    """,
)
@pluginargument(
    "access-token-param",
    metavar="KEY=VALUE",
    type="keyvalue",
    action="append",
    help="""
        A parameter to add to the API request for acquiring the streaming access token.

        Can be repeated to add multiple parameters.
    """,
)
@pluginargument(
    "force-client-integrity",
    action="store_true",
    help="Don't attempt requesting the streaming access token without a client-integrity token.",
)
@pluginargument(
    "purge-client-integrity",
    action="store_true",
    help="Purge cached Twitch client-integrity token and acquire a new one.",
)
class Twitch(Plugin):
    _CACHE_KEY_CLIENT_INTEGRITY = "client-integrity"

    @classmethod
    def stream_weight(cls, stream):
        if stream == "source":
            return sys.maxsize, stream
        return super().stream_weight(stream)

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        params = parse_qsd(urlparse(self.url).query)

        self.channel = self.match["channel"] if self.matches["live"] else None
        self.video_id = self.match["video_id"] if self.matches["vod"] else None
        self.clip_id = self.match["clip_id"] if self.matches["clip"] else None

        if self.matches["player"]:
            self.channel = params.get("channel")
            self.video_id = params.get("video")

        try:
            self.time_offset = hours_minutes_seconds_float(params.get("t", "0"))
        except ValueError:
            self.time_offset = 0

        self.api = TwitchAPI(
            session=self.session,
            api_header=self.get_option("api-header"),
            access_token_param=self.get_option("access-token-param"),
        )
        self.usher = UsherService(session=self.session)

        self._checked_metadata = False

        def method_factory(parent_method):
            def inner():
                if not self._checked_metadata:
                    self._checked_metadata = True
                    self._get_metadata()
                return parent_method()

            return inner

        parent = super()
        for metadata in "id", "author", "category", "title":
            method = f"get_{metadata}"
            setattr(self, method, method_factory(getattr(parent, method)))

    def _get_metadata(self):
        try:
            if self.video_id:
                data = self.api.metadata_video(self.video_id)
            elif self.clip_id:
                data = self.api.metadata_clips(self.clip_id)
            elif self.channel:
                data = self.api.metadata_channel(self.channel)
            else:  # pragma: no cover
                return
            self.id, self.author, self.category, self.title = data
        except (PluginError, TypeError):
            pass

    def _client_integrity_token(self, channel: str) -> tuple[str, str] | None:
        if self.options.get("purge-client-integrity"):
            log.info("Removing cached client-integrity token...")
            self.cache.set(self._CACHE_KEY_CLIENT_INTEGRITY, None, 0)

        client_integrity = self.cache.get(self._CACHE_KEY_CLIENT_INTEGRITY)
        if client_integrity and isinstance(client_integrity, list) and len(client_integrity) == 2:
            log.info("Using cached client-integrity token")
            device_id, token = client_integrity
        else:
            log.info("Acquiring new client-integrity token...")
            device_id = random_token(32, CHOICES_ALPHA_NUM)
            client_integrity = TwitchClientIntegrity.acquire(
                self.session,
                channel,
                self.api.headers,
                device_id,
            )
            if not client_integrity:
                log.warning("No client-integrity token acquired")
                return None

            token, expiration = client_integrity
            self.cache.set(self._CACHE_KEY_CLIENT_INTEGRITY, [device_id, token], expires_at=fromtimestamp(expiration))

        return device_id, token

    def _access_token(self, is_live, channel_or_vod):
        response = ""
        data = (None, None)

        # if live, try without a client-integrity token first (the web player did the same on 2023-05-31)
        # if not live, we don't need a client-integrity token
        if not is_live or not self.options.get("force-client-integrity"):
            response, *data = self.api.access_token(is_live, channel_or_vod)

        # if live and the previous API response was erroneous, try again with a client-integrity token
        if is_live and response != "token":
            client_integrity = self._client_integrity_token(channel_or_vod)
            response, *data = self.api.access_token(is_live, channel_or_vod, client_integrity)

        # unknown API response error: abort
        if response != "token":
            error, message = data
            raise PluginError(f"{error or 'Error'}: {message or 'Unknown error'}")

        # access token response was empty: stream is offline or channel doesn't exist
        elif data[0] is None:
            raise NoStreamsError

        sig, token = data
        try:
            restricted_bitrates = self.api.parse_token(token)
        except PluginError:
            restricted_bitrates = []

        return sig, token, restricted_bitrates

    def _get_hls_streams_live(self):
        # only get the token once the channel has been resolved
        log.debug(f"Getting live HLS streams for {self.channel}")
        self.session.http.headers.update({
            "referer": "https://player.twitch.tv",
            "origin": "https://player.twitch.tv",
        })
        sig, token, restricted_bitrates = self._access_token(True, self.channel)
        url = self.usher.channel(self.channel, sig=sig, token=token, fast_bread=True)

        return self._get_hls_streams(url, restricted_bitrates)

    def _get_hls_streams_video(self):
        log.debug(f"Getting HLS streams for video ID {self.video_id}")
        sig, token, restricted_bitrates = self._access_token(False, self.video_id)
        url = self.usher.video(self.video_id, nauthsig=sig, nauth=token)

        # If the stream is a VOD that is still being recorded, the stream should start at the beginning of the recording
        return self._get_hls_streams(url, restricted_bitrates, force_restart=True)

    def _get_hls_streams(self, url, restricted_bitrates, **extra_params):
        try:
            streams = TwitchHLSStream.parse_variant_playlist(
                self.session,
                url,
                start_offset=self.time_offset,
                # Check if the media playlists are accessible:
                # This is a workaround for checking the GQL API for the channel's live status,
                # which can be delayed by up to a minute.
                check_streams=True,
                disable_ads=self.get_option("disable-ads"),
                low_latency=self.get_option("low-latency"),
                **extra_params,
            )
        except OSError as err:
            # TODO: fix the "err" attribute set by HTTPSession.request()
            orig = getattr(err, "err", None)
            if isinstance(orig, HTTPError) and orig.response.status_code >= 400:
                # The playlist's error response may include JSON data with an error message
                with suppress(PluginError):
                    error = validate.Schema(
                        validate.parse_json(),
                        [
                            {
                                "type": "error",
                                "error": str,
                            },
                        ],
                        validate.get((0, "error")),
                    ).validate(orig.response.text)
                    # Only log error messages if the channel is actually live
                    if self.get_id():
                        log.error(error or "Could not access HLS playlist")
                # Don't raise and simply return no streams on 4xx/5xx playlist responses
                return
            raise PluginError(err) from err

        for name in restricted_bitrates:
            if name not in streams:
                log.warning(f"The quality '{name}' is not available since it requires a subscription.")

        return streams

    def _get_clips(self):
        try:
            sig, token, streams = self.api.clips(self.clip_id)
        except (PluginError, TypeError):
            return

        for quality, stream in streams:
            yield quality, HTTPStream(self.session, update_qsd(stream, {"sig": sig, "token": token}))

    def _get_streams(self):
        if self.video_id:
            return self._get_hls_streams_video()
        elif self.clip_id:
            return self._get_clips()
        elif self.channel:
            return self._get_hls_streams_live()


__plugin__ = Twitch
