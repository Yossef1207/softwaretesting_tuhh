from __future__ import annotations

import copy
import logging
import math
import re
from collections import defaultdict
from collections.abc import Callable, Iterator, Sequence
from contextlib import contextmanager
from datetime import datetime, timedelta
from itertools import count, repeat
from typing import TYPE_CHECKING, Any, ClassVar, Literal, TypeVar, overload
from urllib.parse import urljoin, urlparse, urlunparse

from isodate import Duration, parse_datetime, parse_duration  # type: ignore[import]

# noinspection PyProtectedMember
from lxml.etree import _Attrib, _Element

from streamlink.stream.dash.segment import DASHSegment, TimelineSegment
from streamlink.utils.times import UTC, fromtimestamp, now


if TYPE_CHECKING:
    from typing_extensions import TypeAlias


log = logging.getLogger(__name__)

EPOCH_START = fromtimestamp(0)
ONE_SECOND = timedelta(seconds=1)
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_yield_from_trampoline(orig, mutants, call_args, call_kwargs, self_arg = None):
    """Forward call to original or mutated function, depending on the environment"""
    import os
    mutant_under_test = os.environ['MUTANT_UNDER_TEST']
    if mutant_under_test == 'fail':
        from mutmut.__main__ import MutmutProgrammaticFailException
        raise MutmutProgrammaticFailException('Failed programmatically')      
    elif mutant_under_test == 'stats':
        from mutmut.__main__ import record_trampoline_hit
        record_trampoline_hit(orig.__module__ + '.' + orig.__name__)
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    prefix = orig.__module__ + '.' + orig.__name__ + '__mutmut_'
    if not mutant_under_test.startswith(prefix):
        result = yield from orig(*call_args, **call_kwargs)
        return result  # for the yield case
    mutant_name = mutant_under_test.rpartition('.')[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = yield from mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = yield from mutants[mutant_name](*call_args, **call_kwargs)
    return result


def _identity(x):
    return x


def x_datetime_to_seconds__mutmut_orig(dt):
    return (dt - EPOCH_START).total_seconds()


def x_datetime_to_seconds__mutmut_1(dt):
    return (dt + EPOCH_START).total_seconds()

x_datetime_to_seconds__mutmut_mutants : ClassVar[MutantDict] = {
'x_datetime_to_seconds__mutmut_1': x_datetime_to_seconds__mutmut_1
}

def datetime_to_seconds(*args, **kwargs):
    result = _mutmut_trampoline(x_datetime_to_seconds__mutmut_orig, x_datetime_to_seconds__mutmut_mutants, args, kwargs)
    return result 

datetime_to_seconds.__signature__ = _mutmut_signature(x_datetime_to_seconds__mutmut_orig)
x_datetime_to_seconds__mutmut_orig.__name__ = 'x_datetime_to_seconds'


def x_count_dt__mutmut_orig(firstval: datetime | None = None, step: timedelta = ONE_SECOND) -> Iterator[datetime]:
    current = now() if firstval is None else firstval
    while True:
        yield current
        current += step


def x_count_dt__mutmut_1(firstval: datetime | None = None, step: timedelta = ONE_SECOND) -> Iterator[datetime]:
    current = None
    while True:
        yield current
        current += step


def x_count_dt__mutmut_2(firstval: datetime | None = None, step: timedelta = ONE_SECOND) -> Iterator[datetime]:
    current = now() if firstval is not None else firstval
    while True:
        yield current
        current += step


def x_count_dt__mutmut_3(firstval: datetime | None = None, step: timedelta = ONE_SECOND) -> Iterator[datetime]:
    current = now() if firstval is None else firstval
    while False:
        yield current
        current += step


def x_count_dt__mutmut_4(firstval: datetime | None = None, step: timedelta = ONE_SECOND) -> Iterator[datetime]:
    current = now() if firstval is None else firstval
    while True:
        yield current
        current = step


def x_count_dt__mutmut_5(firstval: datetime | None = None, step: timedelta = ONE_SECOND) -> Iterator[datetime]:
    current = now() if firstval is None else firstval
    while True:
        yield current
        current -= step

x_count_dt__mutmut_mutants : ClassVar[MutantDict] = {
'x_count_dt__mutmut_1': x_count_dt__mutmut_1, 
    'x_count_dt__mutmut_2': x_count_dt__mutmut_2, 
    'x_count_dt__mutmut_3': x_count_dt__mutmut_3, 
    'x_count_dt__mutmut_4': x_count_dt__mutmut_4, 
    'x_count_dt__mutmut_5': x_count_dt__mutmut_5
}

def count_dt(*args, **kwargs):
    result = yield from _mutmut_yield_from_trampoline(x_count_dt__mutmut_orig, x_count_dt__mutmut_mutants, args, kwargs)
    return result 

count_dt.__signature__ = _mutmut_signature(x_count_dt__mutmut_orig)
x_count_dt__mutmut_orig.__name__ = 'x_count_dt'


@contextmanager
def freeze_timeline(mpd):
    timelines = copy.copy(mpd.timelines)
    yield
    mpd.timelines = timelines


_re_segment_template = re.compile(r"(.*?)\$(\w+)(?:%([\w.]+))?\$")


class MPDParsers:
    @staticmethod
    def bool_str(v: str) -> bool:
        return v.lower() == "true"

    @staticmethod
    def type(mpdtype: Literal["static", "dynamic"]) -> Literal["static", "dynamic"]:
        if mpdtype not in ("static", "dynamic"):
            raise MPDParsingError("@type must be static or dynamic")
        return mpdtype

    @staticmethod
    def duration(anchor: datetime | None = None) -> Callable[[str], timedelta]:
        def duration_to_timedelta(duration: str) -> timedelta:
            parsed: timedelta | Duration = parse_duration(duration)
            if isinstance(parsed, Duration):
                return parsed.totimedelta(start=anchor or now())
            return parsed

        return duration_to_timedelta

    @staticmethod
    def datetime(dt: str) -> datetime:
        return parse_datetime(dt).replace(tzinfo=UTC)

    @staticmethod
    def segment_template(url_template: str) -> Callable[..., str]:
        end = 0
        res = ""
        for m in _re_segment_template.finditer(url_template):
            _, end = m.span()
            res += f"{m[1]}{{{m[2]}{f':{m[3]}' if m[3] else ''}}}"

        return f"{res}{url_template[end:]}".format

    @staticmethod
    def frame_rate(frame_rate: str) -> float:
        if "/" not in frame_rate:
            return float(frame_rate)

        a, b = frame_rate.split("/")
        return float(a) / float(b)

    @staticmethod
    def timedelta(timescale: float = 1):
        def _timedelta(seconds):
            return timedelta(seconds=int(float(seconds) / float(timescale)))

        return _timedelta

    @staticmethod
    def range(range_spec: str) -> tuple[int, int | None]:
        r = range_spec.split("-")
        if len(r) != 2:
            raise MPDParsingError("Invalid byte-range-spec")

        start, end = int(r[0]), r[1] and int(r[1]) or None
        return start, end and ((end - start) + 1)


class MPDParsingError(Exception):
    pass


TMPDNode_co = TypeVar("TMPDNode_co", bound="MPDNode", covariant=True)
TAttrDefault = TypeVar("TAttrDefault", Any, None)
TAttrParseResult = TypeVar("TAttrParseResult")

TTimelineIdent: TypeAlias = "tuple[str | None, str | None, str]"


class MPDNode:
    __tag__: ClassVar[str]

    parent: MPDNode

    def xǁMPDNodeǁ__init____mutmut_orig(self, node: _Element, root: MPD, parent: MPDNode, **kwargs) -> None:
        self.node = node
        self.root = root
        self.parent = parent
        self._base_url = kwargs.get("base_url")
        self.attributes: set[str] = set()
        if self.__tag__ and self.node.tag.lower() != self.__tag__.lower():
            raise MPDParsingError(f"Root tag did not match the expected tag: {self.__tag__}")

    def xǁMPDNodeǁ__init____mutmut_1(self, node: _Element, root: MPD, parent: MPDNode, **kwargs) -> None:
        self.node = None
        self.root = root
        self.parent = parent
        self._base_url = kwargs.get("base_url")
        self.attributes: set[str] = set()
        if self.__tag__ and self.node.tag.lower() != self.__tag__.lower():
            raise MPDParsingError(f"Root tag did not match the expected tag: {self.__tag__}")

    def xǁMPDNodeǁ__init____mutmut_2(self, node: _Element, root: MPD, parent: MPDNode, **kwargs) -> None:
        self.node = node
        self.root = None
        self.parent = parent
        self._base_url = kwargs.get("base_url")
        self.attributes: set[str] = set()
        if self.__tag__ and self.node.tag.lower() != self.__tag__.lower():
            raise MPDParsingError(f"Root tag did not match the expected tag: {self.__tag__}")

    def xǁMPDNodeǁ__init____mutmut_3(self, node: _Element, root: MPD, parent: MPDNode, **kwargs) -> None:
        self.node = node
        self.root = root
        self.parent = None
        self._base_url = kwargs.get("base_url")
        self.attributes: set[str] = set()
        if self.__tag__ and self.node.tag.lower() != self.__tag__.lower():
            raise MPDParsingError(f"Root tag did not match the expected tag: {self.__tag__}")

    def xǁMPDNodeǁ__init____mutmut_4(self, node: _Element, root: MPD, parent: MPDNode, **kwargs) -> None:
        self.node = node
        self.root = root
        self.parent = parent
        self._base_url = None
        self.attributes: set[str] = set()
        if self.__tag__ and self.node.tag.lower() != self.__tag__.lower():
            raise MPDParsingError(f"Root tag did not match the expected tag: {self.__tag__}")

    def xǁMPDNodeǁ__init____mutmut_5(self, node: _Element, root: MPD, parent: MPDNode, **kwargs) -> None:
        self.node = node
        self.root = root
        self.parent = parent
        self._base_url = kwargs.get(None)
        self.attributes: set[str] = set()
        if self.__tag__ and self.node.tag.lower() != self.__tag__.lower():
            raise MPDParsingError(f"Root tag did not match the expected tag: {self.__tag__}")

    def xǁMPDNodeǁ__init____mutmut_6(self, node: _Element, root: MPD, parent: MPDNode, **kwargs) -> None:
        self.node = node
        self.root = root
        self.parent = parent
        self._base_url = kwargs.get("XXbase_urlXX")
        self.attributes: set[str] = set()
        if self.__tag__ and self.node.tag.lower() != self.__tag__.lower():
            raise MPDParsingError(f"Root tag did not match the expected tag: {self.__tag__}")

    def xǁMPDNodeǁ__init____mutmut_7(self, node: _Element, root: MPD, parent: MPDNode, **kwargs) -> None:
        self.node = node
        self.root = root
        self.parent = parent
        self._base_url = kwargs.get("BASE_URL")
        self.attributes: set[str] = set()
        if self.__tag__ and self.node.tag.lower() != self.__tag__.lower():
            raise MPDParsingError(f"Root tag did not match the expected tag: {self.__tag__}")

    def xǁMPDNodeǁ__init____mutmut_8(self, node: _Element, root: MPD, parent: MPDNode, **kwargs) -> None:
        self.node = node
        self.root = root
        self.parent = parent
        self._base_url = kwargs.get("Base_url")
        self.attributes: set[str] = set()
        if self.__tag__ and self.node.tag.lower() != self.__tag__.lower():
            raise MPDParsingError(f"Root tag did not match the expected tag: {self.__tag__}")

    def xǁMPDNodeǁ__init____mutmut_9(self, node: _Element, root: MPD, parent: MPDNode, **kwargs) -> None:
        self.node = node
        self.root = root
        self.parent = parent
        self._base_url = kwargs.get("base_url")
        self.attributes: set[str] = None
        if self.__tag__ and self.node.tag.lower() != self.__tag__.lower():
            raise MPDParsingError(f"Root tag did not match the expected tag: {self.__tag__}")

    def xǁMPDNodeǁ__init____mutmut_10(self, node: _Element, root: MPD, parent: MPDNode, **kwargs) -> None:
        self.node = node
        self.root = root
        self.parent = parent
        self._base_url = kwargs.get("base_url")
        self.attributes: set[str] = set()
        if self.__tag__ or self.node.tag.lower() != self.__tag__.lower():
            raise MPDParsingError(f"Root tag did not match the expected tag: {self.__tag__}")

    def xǁMPDNodeǁ__init____mutmut_11(self, node: _Element, root: MPD, parent: MPDNode, **kwargs) -> None:
        self.node = node
        self.root = root
        self.parent = parent
        self._base_url = kwargs.get("base_url")
        self.attributes: set[str] = set()
        if self.__tag__ and self.node.tag.upper() != self.__tag__.lower():
            raise MPDParsingError(f"Root tag did not match the expected tag: {self.__tag__}")

    def xǁMPDNodeǁ__init____mutmut_12(self, node: _Element, root: MPD, parent: MPDNode, **kwargs) -> None:
        self.node = node
        self.root = root
        self.parent = parent
        self._base_url = kwargs.get("base_url")
        self.attributes: set[str] = set()
        if self.__tag__ and self.node.tag.lower() == self.__tag__.lower():
            raise MPDParsingError(f"Root tag did not match the expected tag: {self.__tag__}")

    def xǁMPDNodeǁ__init____mutmut_13(self, node: _Element, root: MPD, parent: MPDNode, **kwargs) -> None:
        self.node = node
        self.root = root
        self.parent = parent
        self._base_url = kwargs.get("base_url")
        self.attributes: set[str] = set()
        if self.__tag__ and self.node.tag.lower() != self.__tag__.upper():
            raise MPDParsingError(f"Root tag did not match the expected tag: {self.__tag__}")

    def xǁMPDNodeǁ__init____mutmut_14(self, node: _Element, root: MPD, parent: MPDNode, **kwargs) -> None:
        self.node = node
        self.root = root
        self.parent = parent
        self._base_url = kwargs.get("base_url")
        self.attributes: set[str] = set()
        if self.__tag__ and self.node.tag.lower() != self.__tag__.lower():
            raise MPDParsingError(None)
    
    xǁMPDNodeǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁMPDNodeǁ__init____mutmut_1': xǁMPDNodeǁ__init____mutmut_1, 
        'xǁMPDNodeǁ__init____mutmut_2': xǁMPDNodeǁ__init____mutmut_2, 
        'xǁMPDNodeǁ__init____mutmut_3': xǁMPDNodeǁ__init____mutmut_3, 
        'xǁMPDNodeǁ__init____mutmut_4': xǁMPDNodeǁ__init____mutmut_4, 
        'xǁMPDNodeǁ__init____mutmut_5': xǁMPDNodeǁ__init____mutmut_5, 
        'xǁMPDNodeǁ__init____mutmut_6': xǁMPDNodeǁ__init____mutmut_6, 
        'xǁMPDNodeǁ__init____mutmut_7': xǁMPDNodeǁ__init____mutmut_7, 
        'xǁMPDNodeǁ__init____mutmut_8': xǁMPDNodeǁ__init____mutmut_8, 
        'xǁMPDNodeǁ__init____mutmut_9': xǁMPDNodeǁ__init____mutmut_9, 
        'xǁMPDNodeǁ__init____mutmut_10': xǁMPDNodeǁ__init____mutmut_10, 
        'xǁMPDNodeǁ__init____mutmut_11': xǁMPDNodeǁ__init____mutmut_11, 
        'xǁMPDNodeǁ__init____mutmut_12': xǁMPDNodeǁ__init____mutmut_12, 
        'xǁMPDNodeǁ__init____mutmut_13': xǁMPDNodeǁ__init____mutmut_13, 
        'xǁMPDNodeǁ__init____mutmut_14': xǁMPDNodeǁ__init____mutmut_14
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁMPDNodeǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁMPDNodeǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁMPDNodeǁ__init____mutmut_orig)
    xǁMPDNodeǁ__init____mutmut_orig.__name__ = 'xǁMPDNodeǁ__init__'

    @property
    def attrib(self) -> _Attrib:
        return self.node.attrib

    @property
    def text(self) -> str | None:
        return self.node.text

    def xǁMPDNodeǁ__str____mutmut_orig(self):
        return f"<{self.__tag__} {' '.join(f'@{attr}={getattr(self, attr)}' for attr in self.attributes)}>"

    def xǁMPDNodeǁ__str____mutmut_1(self):
        return f"<{self.__tag__} {' '.join(None)}>"

    def xǁMPDNodeǁ__str____mutmut_2(self):
        return f"<{self.__tag__} {'XX XX'.join(f'@{attr}={getattr(self, attr)}' for attr in self.attributes)}>"

    def xǁMPDNodeǁ__str____mutmut_3(self):
        return f"<{self.__tag__} {' '.join(f'@{attr}={getattr(None, attr)}' for attr in self.attributes)}>"

    def xǁMPDNodeǁ__str____mutmut_4(self):
        return f"<{self.__tag__} {' '.join(f'@{attr}={getattr(self, None)}' for attr in self.attributes)}>"

    def xǁMPDNodeǁ__str____mutmut_5(self):
        return f"<{self.__tag__} {' '.join(f'@{attr}={getattr(attr)}' for attr in self.attributes)}>"

    def xǁMPDNodeǁ__str____mutmut_6(self):
        return f"<{self.__tag__} {' '.join(f'@{attr}={getattr(self, )}' for attr in self.attributes)}>"
    
    xǁMPDNodeǁ__str____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁMPDNodeǁ__str____mutmut_1': xǁMPDNodeǁ__str____mutmut_1, 
        'xǁMPDNodeǁ__str____mutmut_2': xǁMPDNodeǁ__str____mutmut_2, 
        'xǁMPDNodeǁ__str____mutmut_3': xǁMPDNodeǁ__str____mutmut_3, 
        'xǁMPDNodeǁ__str____mutmut_4': xǁMPDNodeǁ__str____mutmut_4, 
        'xǁMPDNodeǁ__str____mutmut_5': xǁMPDNodeǁ__str____mutmut_5, 
        'xǁMPDNodeǁ__str____mutmut_6': xǁMPDNodeǁ__str____mutmut_6
    }
    
    def __str__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁMPDNodeǁ__str____mutmut_orig"), object.__getattribute__(self, "xǁMPDNodeǁ__str____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __str__.__signature__ = _mutmut_signature(xǁMPDNodeǁ__str____mutmut_orig)
    xǁMPDNodeǁ__str____mutmut_orig.__name__ = 'xǁMPDNodeǁ__str__'

    @overload
    def attr(  # type: ignore[misc]  # "Overloaded function signatures 1 and 2 overlap with incompatible return types"
        self,
        key: str,
        parser: None = None,
        default: None = None,
        required: bool = False,
        inherited: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
    ) -> str | None:  # pragma: no cover
        pass

    @overload
    def attr(
        self,
        key: str,
        parser: None,
        default: TAttrDefault,
        required: bool = False,
        inherited: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
    ) -> TAttrDefault:  # pragma: no cover
        pass

    @overload
    def attr(
        self,
        key: str,
        parser: Callable[[Any], TAttrParseResult],
        default: None = None,
        required: bool = False,
        inherited: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
    ) -> TAttrParseResult | None:  # pragma: no cover
        pass

    @overload
    def attr(
        self,
        key: str,
        parser: Callable[[Any], TAttrParseResult],
        default: TAttrDefault,
        required: bool = False,
        inherited: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
    ) -> TAttrParseResult | TAttrDefault:  # pragma: no cover
        pass

    def xǁMPDNodeǁattr__mutmut_orig(self, key, parser=None, default=None, required=False, inherited=None):
        self.attributes.add(key)
        if key in self.attrib:
            value = self.attrib.get(key)
            if parser and callable(parser):
                return parser(value)
            else:
                return value
        elif inherited:
            value = self.walk_back_get_attr(key, inherited)
            if value is not None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(f"Could not find required attribute {self.__tag__}@{key} ")

        return default

    def xǁMPDNodeǁattr__mutmut_1(self, key, parser=None, default=None, required=True, inherited=None):
        self.attributes.add(key)
        if key in self.attrib:
            value = self.attrib.get(key)
            if parser and callable(parser):
                return parser(value)
            else:
                return value
        elif inherited:
            value = self.walk_back_get_attr(key, inherited)
            if value is not None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(f"Could not find required attribute {self.__tag__}@{key} ")

        return default

    def xǁMPDNodeǁattr__mutmut_2(self, key, parser=None, default=None, required=False, inherited=None):
        self.attributes.add(None)
        if key in self.attrib:
            value = self.attrib.get(key)
            if parser and callable(parser):
                return parser(value)
            else:
                return value
        elif inherited:
            value = self.walk_back_get_attr(key, inherited)
            if value is not None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(f"Could not find required attribute {self.__tag__}@{key} ")

        return default

    def xǁMPDNodeǁattr__mutmut_3(self, key, parser=None, default=None, required=False, inherited=None):
        self.attributes.add(key)
        if key not in self.attrib:
            value = self.attrib.get(key)
            if parser and callable(parser):
                return parser(value)
            else:
                return value
        elif inherited:
            value = self.walk_back_get_attr(key, inherited)
            if value is not None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(f"Could not find required attribute {self.__tag__}@{key} ")

        return default

    def xǁMPDNodeǁattr__mutmut_4(self, key, parser=None, default=None, required=False, inherited=None):
        self.attributes.add(key)
        if key in self.attrib:
            value = None
            if parser and callable(parser):
                return parser(value)
            else:
                return value
        elif inherited:
            value = self.walk_back_get_attr(key, inherited)
            if value is not None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(f"Could not find required attribute {self.__tag__}@{key} ")

        return default

    def xǁMPDNodeǁattr__mutmut_5(self, key, parser=None, default=None, required=False, inherited=None):
        self.attributes.add(key)
        if key in self.attrib:
            value = self.attrib.get(None)
            if parser and callable(parser):
                return parser(value)
            else:
                return value
        elif inherited:
            value = self.walk_back_get_attr(key, inherited)
            if value is not None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(f"Could not find required attribute {self.__tag__}@{key} ")

        return default

    def xǁMPDNodeǁattr__mutmut_6(self, key, parser=None, default=None, required=False, inherited=None):
        self.attributes.add(key)
        if key in self.attrib:
            value = self.attrib.get(key)
            if parser or callable(parser):
                return parser(value)
            else:
                return value
        elif inherited:
            value = self.walk_back_get_attr(key, inherited)
            if value is not None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(f"Could not find required attribute {self.__tag__}@{key} ")

        return default

    def xǁMPDNodeǁattr__mutmut_7(self, key, parser=None, default=None, required=False, inherited=None):
        self.attributes.add(key)
        if key in self.attrib:
            value = self.attrib.get(key)
            if parser and callable(None):
                return parser(value)
            else:
                return value
        elif inherited:
            value = self.walk_back_get_attr(key, inherited)
            if value is not None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(f"Could not find required attribute {self.__tag__}@{key} ")

        return default

    def xǁMPDNodeǁattr__mutmut_8(self, key, parser=None, default=None, required=False, inherited=None):
        self.attributes.add(key)
        if key in self.attrib:
            value = self.attrib.get(key)
            if parser and callable(parser):
                return parser(None)
            else:
                return value
        elif inherited:
            value = self.walk_back_get_attr(key, inherited)
            if value is not None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(f"Could not find required attribute {self.__tag__}@{key} ")

        return default

    def xǁMPDNodeǁattr__mutmut_9(self, key, parser=None, default=None, required=False, inherited=None):
        self.attributes.add(key)
        if key in self.attrib:
            value = self.attrib.get(key)
            if parser and callable(parser):
                return parser(value)
            else:
                return value
        elif inherited:
            value = None
            if value is not None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(f"Could not find required attribute {self.__tag__}@{key} ")

        return default

    def xǁMPDNodeǁattr__mutmut_10(self, key, parser=None, default=None, required=False, inherited=None):
        self.attributes.add(key)
        if key in self.attrib:
            value = self.attrib.get(key)
            if parser and callable(parser):
                return parser(value)
            else:
                return value
        elif inherited:
            value = self.walk_back_get_attr(None, inherited)
            if value is not None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(f"Could not find required attribute {self.__tag__}@{key} ")

        return default

    def xǁMPDNodeǁattr__mutmut_11(self, key, parser=None, default=None, required=False, inherited=None):
        self.attributes.add(key)
        if key in self.attrib:
            value = self.attrib.get(key)
            if parser and callable(parser):
                return parser(value)
            else:
                return value
        elif inherited:
            value = self.walk_back_get_attr(key, None)
            if value is not None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(f"Could not find required attribute {self.__tag__}@{key} ")

        return default

    def xǁMPDNodeǁattr__mutmut_12(self, key, parser=None, default=None, required=False, inherited=None):
        self.attributes.add(key)
        if key in self.attrib:
            value = self.attrib.get(key)
            if parser and callable(parser):
                return parser(value)
            else:
                return value
        elif inherited:
            value = self.walk_back_get_attr(inherited)
            if value is not None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(f"Could not find required attribute {self.__tag__}@{key} ")

        return default

    def xǁMPDNodeǁattr__mutmut_13(self, key, parser=None, default=None, required=False, inherited=None):
        self.attributes.add(key)
        if key in self.attrib:
            value = self.attrib.get(key)
            if parser and callable(parser):
                return parser(value)
            else:
                return value
        elif inherited:
            value = self.walk_back_get_attr(key, )
            if value is not None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(f"Could not find required attribute {self.__tag__}@{key} ")

        return default

    def xǁMPDNodeǁattr__mutmut_14(self, key, parser=None, default=None, required=False, inherited=None):
        self.attributes.add(key)
        if key in self.attrib:
            value = self.attrib.get(key)
            if parser and callable(parser):
                return parser(value)
            else:
                return value
        elif inherited:
            value = self.walk_back_get_attr(key, inherited)
            if value is None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(f"Could not find required attribute {self.__tag__}@{key} ")

        return default

    def xǁMPDNodeǁattr__mutmut_15(self, key, parser=None, default=None, required=False, inherited=None):
        self.attributes.add(key)
        if key in self.attrib:
            value = self.attrib.get(key)
            if parser and callable(parser):
                return parser(value)
            else:
                return value
        elif inherited:
            value = self.walk_back_get_attr(key, inherited)
            if value is not None:
                return value

        if required:  # pragma: no cover
            raise MPDParsingError(None)

        return default
    
    xǁMPDNodeǁattr__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁMPDNodeǁattr__mutmut_1': xǁMPDNodeǁattr__mutmut_1, 
        'xǁMPDNodeǁattr__mutmut_2': xǁMPDNodeǁattr__mutmut_2, 
        'xǁMPDNodeǁattr__mutmut_3': xǁMPDNodeǁattr__mutmut_3, 
        'xǁMPDNodeǁattr__mutmut_4': xǁMPDNodeǁattr__mutmut_4, 
        'xǁMPDNodeǁattr__mutmut_5': xǁMPDNodeǁattr__mutmut_5, 
        'xǁMPDNodeǁattr__mutmut_6': xǁMPDNodeǁattr__mutmut_6, 
        'xǁMPDNodeǁattr__mutmut_7': xǁMPDNodeǁattr__mutmut_7, 
        'xǁMPDNodeǁattr__mutmut_8': xǁMPDNodeǁattr__mutmut_8, 
        'xǁMPDNodeǁattr__mutmut_9': xǁMPDNodeǁattr__mutmut_9, 
        'xǁMPDNodeǁattr__mutmut_10': xǁMPDNodeǁattr__mutmut_10, 
        'xǁMPDNodeǁattr__mutmut_11': xǁMPDNodeǁattr__mutmut_11, 
        'xǁMPDNodeǁattr__mutmut_12': xǁMPDNodeǁattr__mutmut_12, 
        'xǁMPDNodeǁattr__mutmut_13': xǁMPDNodeǁattr__mutmut_13, 
        'xǁMPDNodeǁattr__mutmut_14': xǁMPDNodeǁattr__mutmut_14, 
        'xǁMPDNodeǁattr__mutmut_15': xǁMPDNodeǁattr__mutmut_15
    }
    
    def attr(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁMPDNodeǁattr__mutmut_orig"), object.__getattribute__(self, "xǁMPDNodeǁattr__mutmut_mutants"), args, kwargs, self)
        return result 
    
    attr.__signature__ = _mutmut_signature(xǁMPDNodeǁattr__mutmut_orig)
    xǁMPDNodeǁattr__mutmut_orig.__name__ = 'xǁMPDNodeǁattr'

    def xǁMPDNodeǁchildren__mutmut_orig(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_1(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 1,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_2(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = None
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_3(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(None)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_4(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) <= minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_5(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum and (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_6(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum or len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_7(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) >= maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_8(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(None)

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_9(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum and 'unbound'})")

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_10(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'XXunboundXX'})")

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_11(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'UNBOUND'})")

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_12(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'Unbound'})")

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_13(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(None, root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_14(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=None, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_15(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, parent=None, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_16(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, parent=self, i=None, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_17(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=None, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_18(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_19(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_20(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_21(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, parent=self, base_url=self.base_url, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_22(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, parent=self, i=i, **kwargs)
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_23(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=self.base_url, )
            for i, child in enumerate(children)
        ]  # fmt: skip

    def xǁMPDNodeǁchildren__mutmut_24(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        maximum: int | None = None,
        **kwargs,
    ) -> list[TMPDNode_co]:
        children = self.node.findall(cls.__tag__)
        if len(children) < minimum or (maximum and len(children) > maximum):
            raise MPDParsingError(f"Expected to find {self.__tag__}/{cls.__tag__} required [{minimum}..{maximum or 'unbound'})")

        return [
            cls(child, root=self.root, parent=self, i=i, base_url=self.base_url, **kwargs)
            for i, child in enumerate(None)
        ]  # fmt: skip
    
    xǁMPDNodeǁchildren__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁMPDNodeǁchildren__mutmut_1': xǁMPDNodeǁchildren__mutmut_1, 
        'xǁMPDNodeǁchildren__mutmut_2': xǁMPDNodeǁchildren__mutmut_2, 
        'xǁMPDNodeǁchildren__mutmut_3': xǁMPDNodeǁchildren__mutmut_3, 
        'xǁMPDNodeǁchildren__mutmut_4': xǁMPDNodeǁchildren__mutmut_4, 
        'xǁMPDNodeǁchildren__mutmut_5': xǁMPDNodeǁchildren__mutmut_5, 
        'xǁMPDNodeǁchildren__mutmut_6': xǁMPDNodeǁchildren__mutmut_6, 
        'xǁMPDNodeǁchildren__mutmut_7': xǁMPDNodeǁchildren__mutmut_7, 
        'xǁMPDNodeǁchildren__mutmut_8': xǁMPDNodeǁchildren__mutmut_8, 
        'xǁMPDNodeǁchildren__mutmut_9': xǁMPDNodeǁchildren__mutmut_9, 
        'xǁMPDNodeǁchildren__mutmut_10': xǁMPDNodeǁchildren__mutmut_10, 
        'xǁMPDNodeǁchildren__mutmut_11': xǁMPDNodeǁchildren__mutmut_11, 
        'xǁMPDNodeǁchildren__mutmut_12': xǁMPDNodeǁchildren__mutmut_12, 
        'xǁMPDNodeǁchildren__mutmut_13': xǁMPDNodeǁchildren__mutmut_13, 
        'xǁMPDNodeǁchildren__mutmut_14': xǁMPDNodeǁchildren__mutmut_14, 
        'xǁMPDNodeǁchildren__mutmut_15': xǁMPDNodeǁchildren__mutmut_15, 
        'xǁMPDNodeǁchildren__mutmut_16': xǁMPDNodeǁchildren__mutmut_16, 
        'xǁMPDNodeǁchildren__mutmut_17': xǁMPDNodeǁchildren__mutmut_17, 
        'xǁMPDNodeǁchildren__mutmut_18': xǁMPDNodeǁchildren__mutmut_18, 
        'xǁMPDNodeǁchildren__mutmut_19': xǁMPDNodeǁchildren__mutmut_19, 
        'xǁMPDNodeǁchildren__mutmut_20': xǁMPDNodeǁchildren__mutmut_20, 
        'xǁMPDNodeǁchildren__mutmut_21': xǁMPDNodeǁchildren__mutmut_21, 
        'xǁMPDNodeǁchildren__mutmut_22': xǁMPDNodeǁchildren__mutmut_22, 
        'xǁMPDNodeǁchildren__mutmut_23': xǁMPDNodeǁchildren__mutmut_23, 
        'xǁMPDNodeǁchildren__mutmut_24': xǁMPDNodeǁchildren__mutmut_24
    }
    
    def children(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁMPDNodeǁchildren__mutmut_orig"), object.__getattribute__(self, "xǁMPDNodeǁchildren__mutmut_mutants"), args, kwargs, self)
        return result 
    
    children.__signature__ = _mutmut_signature(xǁMPDNodeǁchildren__mutmut_orig)
    xǁMPDNodeǁchildren__mutmut_orig.__name__ = 'xǁMPDNodeǁchildren'

    def xǁMPDNodeǁonly_child__mutmut_orig(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        **kwargs,
    ) -> TMPDNode_co | None:
        children = self.children(cls, minimum=minimum, maximum=1, **kwargs)
        return children[0] if len(children) else None

    def xǁMPDNodeǁonly_child__mutmut_1(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 1,
        **kwargs,
    ) -> TMPDNode_co | None:
        children = self.children(cls, minimum=minimum, maximum=1, **kwargs)
        return children[0] if len(children) else None

    def xǁMPDNodeǁonly_child__mutmut_2(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        **kwargs,
    ) -> TMPDNode_co | None:
        children = None
        return children[0] if len(children) else None

    def xǁMPDNodeǁonly_child__mutmut_3(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        **kwargs,
    ) -> TMPDNode_co | None:
        children = self.children(None, minimum=minimum, maximum=1, **kwargs)
        return children[0] if len(children) else None

    def xǁMPDNodeǁonly_child__mutmut_4(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        **kwargs,
    ) -> TMPDNode_co | None:
        children = self.children(cls, minimum=None, maximum=1, **kwargs)
        return children[0] if len(children) else None

    def xǁMPDNodeǁonly_child__mutmut_5(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        **kwargs,
    ) -> TMPDNode_co | None:
        children = self.children(cls, minimum=minimum, maximum=None, **kwargs)
        return children[0] if len(children) else None

    def xǁMPDNodeǁonly_child__mutmut_6(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        **kwargs,
    ) -> TMPDNode_co | None:
        children = self.children(minimum=minimum, maximum=1, **kwargs)
        return children[0] if len(children) else None

    def xǁMPDNodeǁonly_child__mutmut_7(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        **kwargs,
    ) -> TMPDNode_co | None:
        children = self.children(cls, maximum=1, **kwargs)
        return children[0] if len(children) else None

    def xǁMPDNodeǁonly_child__mutmut_8(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        **kwargs,
    ) -> TMPDNode_co | None:
        children = self.children(cls, minimum=minimum, **kwargs)
        return children[0] if len(children) else None

    def xǁMPDNodeǁonly_child__mutmut_9(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        **kwargs,
    ) -> TMPDNode_co | None:
        children = self.children(cls, minimum=minimum, maximum=1, )
        return children[0] if len(children) else None

    def xǁMPDNodeǁonly_child__mutmut_10(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        **kwargs,
    ) -> TMPDNode_co | None:
        children = self.children(cls, minimum=minimum, maximum=2, **kwargs)
        return children[0] if len(children) else None

    def xǁMPDNodeǁonly_child__mutmut_11(
        self,
        cls: type[TMPDNode_co],
        minimum: int = 0,
        **kwargs,
    ) -> TMPDNode_co | None:
        children = self.children(cls, minimum=minimum, maximum=1, **kwargs)
        return children[1] if len(children) else None
    
    xǁMPDNodeǁonly_child__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁMPDNodeǁonly_child__mutmut_1': xǁMPDNodeǁonly_child__mutmut_1, 
        'xǁMPDNodeǁonly_child__mutmut_2': xǁMPDNodeǁonly_child__mutmut_2, 
        'xǁMPDNodeǁonly_child__mutmut_3': xǁMPDNodeǁonly_child__mutmut_3, 
        'xǁMPDNodeǁonly_child__mutmut_4': xǁMPDNodeǁonly_child__mutmut_4, 
        'xǁMPDNodeǁonly_child__mutmut_5': xǁMPDNodeǁonly_child__mutmut_5, 
        'xǁMPDNodeǁonly_child__mutmut_6': xǁMPDNodeǁonly_child__mutmut_6, 
        'xǁMPDNodeǁonly_child__mutmut_7': xǁMPDNodeǁonly_child__mutmut_7, 
        'xǁMPDNodeǁonly_child__mutmut_8': xǁMPDNodeǁonly_child__mutmut_8, 
        'xǁMPDNodeǁonly_child__mutmut_9': xǁMPDNodeǁonly_child__mutmut_9, 
        'xǁMPDNodeǁonly_child__mutmut_10': xǁMPDNodeǁonly_child__mutmut_10, 
        'xǁMPDNodeǁonly_child__mutmut_11': xǁMPDNodeǁonly_child__mutmut_11
    }
    
    def only_child(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁMPDNodeǁonly_child__mutmut_orig"), object.__getattribute__(self, "xǁMPDNodeǁonly_child__mutmut_mutants"), args, kwargs, self)
        return result 
    
    only_child.__signature__ = _mutmut_signature(xǁMPDNodeǁonly_child__mutmut_orig)
    xǁMPDNodeǁonly_child__mutmut_orig.__name__ = 'xǁMPDNodeǁonly_child'

    def xǁMPDNodeǁwalk_back__mutmut_orig(
        self,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Iterator[MPDNode]:
        node = self.parent
        while node:
            if cls is None or isinstance(node, cls):  # type: ignore[arg-type]
                n = mapper(node)  # type: ignore[arg-type]
                if n is not None:
                    yield n
            node = node.parent

    def xǁMPDNodeǁwalk_back__mutmut_1(
        self,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Iterator[MPDNode]:
        node = None
        while node:
            if cls is None or isinstance(node, cls):  # type: ignore[arg-type]
                n = mapper(node)  # type: ignore[arg-type]
                if n is not None:
                    yield n
            node = node.parent

    def xǁMPDNodeǁwalk_back__mutmut_2(
        self,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Iterator[MPDNode]:
        node = self.parent
        while node:
            if cls is not None or isinstance(node, cls):  # type: ignore[arg-type]
                n = mapper(node)  # type: ignore[arg-type]
                if n is not None:
                    yield n
            node = node.parent

    def xǁMPDNodeǁwalk_back__mutmut_3(
        self,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Iterator[MPDNode]:
        node = self.parent
        while node:
            if cls is None and isinstance(node, cls):  # type: ignore[arg-type]
                n = mapper(node)  # type: ignore[arg-type]
                if n is not None:
                    yield n
            node = node.parent

    def xǁMPDNodeǁwalk_back__mutmut_4(
        self,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Iterator[MPDNode]:
        node = self.parent
        while node:
            if cls is None or isinstance(node, cls):  # type: ignore[arg-type]
                n = None  # type: ignore[arg-type]
                if n is not None:
                    yield n
            node = node.parent

    def xǁMPDNodeǁwalk_back__mutmut_5(
        self,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Iterator[MPDNode]:
        node = self.parent
        while node:
            if cls is None or isinstance(node, cls):  # type: ignore[arg-type]
                n = mapper(None)  # type: ignore[arg-type]
                if n is not None:
                    yield n
            node = node.parent

    def xǁMPDNodeǁwalk_back__mutmut_6(
        self,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Iterator[MPDNode]:
        node = self.parent
        while node:
            if cls is None or isinstance(node, cls):  # type: ignore[arg-type]
                n = mapper(node)  # type: ignore[arg-type]
                if n is None:
                    yield n
            node = node.parent

    def xǁMPDNodeǁwalk_back__mutmut_7(
        self,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Iterator[MPDNode]:
        node = self.parent
        while node:
            if cls is None or isinstance(node, cls):  # type: ignore[arg-type]
                n = mapper(node)  # type: ignore[arg-type]
                if n is not None:
                    yield n
            node = None
    
    xǁMPDNodeǁwalk_back__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁMPDNodeǁwalk_back__mutmut_1': xǁMPDNodeǁwalk_back__mutmut_1, 
        'xǁMPDNodeǁwalk_back__mutmut_2': xǁMPDNodeǁwalk_back__mutmut_2, 
        'xǁMPDNodeǁwalk_back__mutmut_3': xǁMPDNodeǁwalk_back__mutmut_3, 
        'xǁMPDNodeǁwalk_back__mutmut_4': xǁMPDNodeǁwalk_back__mutmut_4, 
        'xǁMPDNodeǁwalk_back__mutmut_5': xǁMPDNodeǁwalk_back__mutmut_5, 
        'xǁMPDNodeǁwalk_back__mutmut_6': xǁMPDNodeǁwalk_back__mutmut_6, 
        'xǁMPDNodeǁwalk_back__mutmut_7': xǁMPDNodeǁwalk_back__mutmut_7
    }
    
    def walk_back(self, *args, **kwargs):
        result = yield from _mutmut_yield_from_trampoline(object.__getattribute__(self, "xǁMPDNodeǁwalk_back__mutmut_orig"), object.__getattribute__(self, "xǁMPDNodeǁwalk_back__mutmut_mutants"), args, kwargs, self)
        return result 
    
    walk_back.__signature__ = _mutmut_signature(xǁMPDNodeǁwalk_back__mutmut_orig)
    xǁMPDNodeǁwalk_back__mutmut_orig.__name__ = 'xǁMPDNodeǁwalk_back'

    def xǁMPDNodeǁwalk_back_get_attr__mutmut_orig(
        self,
        attr: str,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Any | None:
        for ancestor in self.walk_back(cls, mapper):
            value = getattr(ancestor, attr, None)
            if value is not None:
                return value

    def xǁMPDNodeǁwalk_back_get_attr__mutmut_1(
        self,
        attr: str,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Any | None:
        for ancestor in self.walk_back(None, mapper):
            value = getattr(ancestor, attr, None)
            if value is not None:
                return value

    def xǁMPDNodeǁwalk_back_get_attr__mutmut_2(
        self,
        attr: str,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Any | None:
        for ancestor in self.walk_back(cls, None):
            value = getattr(ancestor, attr, None)
            if value is not None:
                return value

    def xǁMPDNodeǁwalk_back_get_attr__mutmut_3(
        self,
        attr: str,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Any | None:
        for ancestor in self.walk_back(mapper):
            value = getattr(ancestor, attr, None)
            if value is not None:
                return value

    def xǁMPDNodeǁwalk_back_get_attr__mutmut_4(
        self,
        attr: str,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Any | None:
        for ancestor in self.walk_back(cls, ):
            value = getattr(ancestor, attr, None)
            if value is not None:
                return value

    def xǁMPDNodeǁwalk_back_get_attr__mutmut_5(
        self,
        attr: str,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Any | None:
        for ancestor in self.walk_back(cls, mapper):
            value = None
            if value is not None:
                return value

    def xǁMPDNodeǁwalk_back_get_attr__mutmut_6(
        self,
        attr: str,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Any | None:
        for ancestor in self.walk_back(cls, mapper):
            value = getattr(None, attr, None)
            if value is not None:
                return value

    def xǁMPDNodeǁwalk_back_get_attr__mutmut_7(
        self,
        attr: str,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Any | None:
        for ancestor in self.walk_back(cls, mapper):
            value = getattr(ancestor, None, None)
            if value is not None:
                return value

    def xǁMPDNodeǁwalk_back_get_attr__mutmut_8(
        self,
        attr: str,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Any | None:
        for ancestor in self.walk_back(cls, mapper):
            value = getattr(attr, None)
            if value is not None:
                return value

    def xǁMPDNodeǁwalk_back_get_attr__mutmut_9(
        self,
        attr: str,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Any | None:
        for ancestor in self.walk_back(cls, mapper):
            value = getattr(ancestor, None)
            if value is not None:
                return value

    def xǁMPDNodeǁwalk_back_get_attr__mutmut_10(
        self,
        attr: str,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Any | None:
        for ancestor in self.walk_back(cls, mapper):
            value = getattr(ancestor, attr, )
            if value is not None:
                return value

    def xǁMPDNodeǁwalk_back_get_attr__mutmut_11(
        self,
        attr: str,
        cls: type[TMPDNode_co] | Sequence[type[TMPDNode_co]] | None = None,
        mapper: Callable[[MPDNode], MPDNode | None] = _identity,
    ) -> Any | None:
        for ancestor in self.walk_back(cls, mapper):
            value = getattr(ancestor, attr, None)
            if value is None:
                return value
    
    xǁMPDNodeǁwalk_back_get_attr__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁMPDNodeǁwalk_back_get_attr__mutmut_1': xǁMPDNodeǁwalk_back_get_attr__mutmut_1, 
        'xǁMPDNodeǁwalk_back_get_attr__mutmut_2': xǁMPDNodeǁwalk_back_get_attr__mutmut_2, 
        'xǁMPDNodeǁwalk_back_get_attr__mutmut_3': xǁMPDNodeǁwalk_back_get_attr__mutmut_3, 
        'xǁMPDNodeǁwalk_back_get_attr__mutmut_4': xǁMPDNodeǁwalk_back_get_attr__mutmut_4, 
        'xǁMPDNodeǁwalk_back_get_attr__mutmut_5': xǁMPDNodeǁwalk_back_get_attr__mutmut_5, 
        'xǁMPDNodeǁwalk_back_get_attr__mutmut_6': xǁMPDNodeǁwalk_back_get_attr__mutmut_6, 
        'xǁMPDNodeǁwalk_back_get_attr__mutmut_7': xǁMPDNodeǁwalk_back_get_attr__mutmut_7, 
        'xǁMPDNodeǁwalk_back_get_attr__mutmut_8': xǁMPDNodeǁwalk_back_get_attr__mutmut_8, 
        'xǁMPDNodeǁwalk_back_get_attr__mutmut_9': xǁMPDNodeǁwalk_back_get_attr__mutmut_9, 
        'xǁMPDNodeǁwalk_back_get_attr__mutmut_10': xǁMPDNodeǁwalk_back_get_attr__mutmut_10, 
        'xǁMPDNodeǁwalk_back_get_attr__mutmut_11': xǁMPDNodeǁwalk_back_get_attr__mutmut_11
    }
    
    def walk_back_get_attr(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁMPDNodeǁwalk_back_get_attr__mutmut_orig"), object.__getattribute__(self, "xǁMPDNodeǁwalk_back_get_attr__mutmut_mutants"), args, kwargs, self)
        return result 
    
    walk_back_get_attr.__signature__ = _mutmut_signature(xǁMPDNodeǁwalk_back_get_attr__mutmut_orig)
    xǁMPDNodeǁwalk_back_get_attr__mutmut_orig.__name__ = 'xǁMPDNodeǁwalk_back_get_attr'

    @property
    def base_url(self):
        base_url = self._base_url
        if hasattr(self, "baseURLs") and len(self.baseURLs):
            base_url = urljoin(base_url, self.baseURLs[0].url)
        return base_url


class MPD(MPDNode):
    """
    Represents the MPD as a whole

    Should validate the XML input and provide methods to get segment URLs for each Period, AdaptationSet and Representation.
    """

    __tag__ = "MPD"

    parent: None  # type: ignore[assignment]
    timelines: dict[TTimelineIdent, int]

    DEFAULT_MINBUFFERTIME = 3.0
    DEFAULT_LIVE_EDGE_SEGMENTS = 3

    def xǁMPDǁ__init____mutmut_orig(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_1(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = None
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_2(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["XXrootXX"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_3(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["ROOT"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_4(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["Root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_5(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = ""
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_6(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["XXparentXX"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_7(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["PARENT"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_8(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["Parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_9(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(**kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_10(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, )

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_11(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = None
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_12(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = None
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_13(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(None)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_14(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: None)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_15(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: +1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_16(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -2)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_17(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(None)

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_18(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop(None, {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_19(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", None))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_20(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop({}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_21(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", ))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_22(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("XXtimelinesXX", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_23(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("TIMELINES", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_24(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("Timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_25(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = None
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_26(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr(None)
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_27(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("XXidXX")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_28(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("ID")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_29(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("Id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_30(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = None
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_31(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            None,
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_32(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=None,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_33(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_34(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_35(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "XXprofilesXX",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_36(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "PROFILES",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_37(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "Profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_38(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=False,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_39(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = None
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_40(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            None,
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_41(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=None,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_42(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default=None,
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_43(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_44(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_45(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_46(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "XXtypeXX",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_47(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "TYPE",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_48(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "Type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_49(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="XXstaticXX",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_50(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="STATIC",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_51(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="Static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_52(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = None
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_53(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            None,
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_54(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=None,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_55(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=None,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_56(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_57(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_58(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_59(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "XXpublishTimeXX",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_60(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishtime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_61(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "PUBLISHTIME",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_62(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "Publishtime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_63(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = None
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_64(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            None,
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_65(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=None,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_66(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=None,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_67(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_68(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_69(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_70(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "XXavailabilityStartTimeXX",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_71(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilitystarttime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_72(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "AVAILABILITYSTARTTIME",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_73(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "Availabilitystarttime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_74(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = None
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_75(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            None,
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_76(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=None,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_77(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_78(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_79(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "XXavailabilityEndTimeXX",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_80(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityendtime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_81(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "AVAILABILITYENDTIME",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_82(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "Availabilityendtime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_83(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = None
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_84(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            None,
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_85(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=None,
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_86(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=None,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_87(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_88(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_89(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_90(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "XXminBufferTimeXX",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_91(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minbuffertime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_92(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "MINBUFFERTIME",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_93(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "Minbuffertime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_94(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(None),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_95(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=False,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_96(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = None
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_97(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            None,
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_98(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=None,
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_99(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=None,
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_100(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_101(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_102(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_103(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "XXminimumUpdatePeriodXX",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_104(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumupdateperiod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_105(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "MINIMUMUPDATEPERIOD",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_106(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "Minimumupdateperiod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_107(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(None),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_108(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = None
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_109(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            None,
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_110(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=None,
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_111(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_112(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_113(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "XXtimeShiftBufferDepthXX",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_114(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeshiftbufferdepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_115(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "TIMESHIFTBUFFERDEPTH",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_116(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "Timeshiftbufferdepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_117(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(None),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_118(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = None
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_119(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            None,
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_120(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=None,
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_121(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=None,
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_122(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_123(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_124(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_125(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "XXmediaPresentationDurationXX",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_126(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediapresentationduration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_127(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "MEDIAPRESENTATIONDURATION",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_128(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "Mediapresentationduration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_129(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(None),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_130(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = None

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_131(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            None,
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_132(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=None,
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_133(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=None,
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_134(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_135(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_136(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_137(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "XXsuggestedPresentationDelayXX",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_138(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedpresentationdelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_139(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "SUGGESTEDPRESENTATIONDELAY",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_140(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "Suggestedpresentationdelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_141(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(None),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_142(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=None,
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_143(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    None,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_144(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    None,
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_145(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_146(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_147(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = None
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_148(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(None)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_149(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_150(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[1] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_151(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = None
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_152(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text and ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_153(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or "XXXX"
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_154(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = None
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_155(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(None)
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_156(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(None))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_157(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[3]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_158(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = None
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_159(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[3], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_160(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit(None, 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_161(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", None)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_162(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit(1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_163(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", )
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_164(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].split("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_165(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[3].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_166(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("XX/XX", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_167(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 2)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_168(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = None

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_169(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(None)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_170(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = None
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_171(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(None)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_172(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = None
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_173(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(None, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_174(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=None)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_175(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_176(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, )
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_177(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=2)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_178(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = None
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_179(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is None}
        self.programInformation = self.children(ProgramInformation)

    def xǁMPDǁ__init____mutmut_180(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = None

    def xǁMPDǁ__init____mutmut_181(self, *args, url: str | None = None, **kwargs) -> None:
        # top level has no parent
        kwargs["root"] = self
        kwargs["parent"] = None
        super().__init__(*args, **kwargs)

        # parser attributes
        self.url = url
        self.timelines = defaultdict(lambda: -1)
        self.timelines.update(kwargs.pop("timelines", {}))

        self.id = self.attr("id")
        self.profiles = self.attr(
            "profiles",
            required=True,
        )
        self.type = self.attr(
            "type",
            parser=MPDParsers.type,
            default="static",
        )
        self.publishTime = self.attr(
            "publishTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityStartTime = self.attr(
            "availabilityStartTime",
            parser=MPDParsers.datetime,
            default=EPOCH_START,
        )
        self.availabilityEndTime = self.attr(
            "availabilityEndTime",
            parser=MPDParsers.datetime,
        )
        self.minBufferTime: timedelta = self.attr(  # type: ignore[assignment]
            "minBufferTime",
            parser=MPDParsers.duration(self.publishTime),
            required=True,
        )
        self.minimumUpdatePeriod = self.attr(
            "minimumUpdatePeriod",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.timeShiftBufferDepth = self.attr(
            "timeShiftBufferDepth",
            parser=MPDParsers.duration(self.publishTime),
        )
        self.mediaPresentationDuration = self.attr(
            "mediaPresentationDuration",
            parser=MPDParsers.duration(self.publishTime),
            default=timedelta(),
        )
        self.suggestedPresentationDelay = self.attr(
            "suggestedPresentationDelay",
            parser=MPDParsers.duration(self.publishTime),
            # if there is no delay, use a delay of 3 seconds, but respect the manifest's minBufferTime
            # TODO: add a customizable parameter for this
            default=timedelta(
                seconds=max(
                    self.DEFAULT_MINBUFFERTIME,
                    self.minBufferTime.total_seconds(),
                ),
            ),
        )

        # parse children
        location = self.children(Location)
        self.location = location[0] if location else None
        if self.location:
            self.url = self.location.text or ""
            urlp = list(urlparse(self.url))
            if urlp[2]:
                urlp[2], _ = urlp[2].rsplit("/", 1)
            self._base_url = urlunparse(urlp)

        self.baseURLs = self.children(BaseURL)
        self.periods = self.children(Period, minimum=1)
        self.periods_map = {period.id: period for period in self.periods if period.id is not None}
        self.programInformation = self.children(None)
    
    xǁMPDǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁMPDǁ__init____mutmut_1': xǁMPDǁ__init____mutmut_1, 
        'xǁMPDǁ__init____mutmut_2': xǁMPDǁ__init____mutmut_2, 
        'xǁMPDǁ__init____mutmut_3': xǁMPDǁ__init____mutmut_3, 
        'xǁMPDǁ__init____mutmut_4': xǁMPDǁ__init____mutmut_4, 
        'xǁMPDǁ__init____mutmut_5': xǁMPDǁ__init____mutmut_5, 
        'xǁMPDǁ__init____mutmut_6': xǁMPDǁ__init____mutmut_6, 
        'xǁMPDǁ__init____mutmut_7': xǁMPDǁ__init____mutmut_7, 
        'xǁMPDǁ__init____mutmut_8': xǁMPDǁ__init____mutmut_8, 
        'xǁMPDǁ__init____mutmut_9': xǁMPDǁ__init____mutmut_9, 
        'xǁMPDǁ__init____mutmut_10': xǁMPDǁ__init____mutmut_10, 
        'xǁMPDǁ__init____mutmut_11': xǁMPDǁ__init____mutmut_11, 
        'xǁMPDǁ__init____mutmut_12': xǁMPDǁ__init____mutmut_12, 
        'xǁMPDǁ__init____mutmut_13': xǁMPDǁ__init____mutmut_13, 
        'xǁMPDǁ__init____mutmut_14': xǁMPDǁ__init____mutmut_14, 
        'xǁMPDǁ__init____mutmut_15': xǁMPDǁ__init____mutmut_15, 
        'xǁMPDǁ__init____mutmut_16': xǁMPDǁ__init____mutmut_16, 
        'xǁMPDǁ__init____mutmut_17': xǁMPDǁ__init____mutmut_17, 
        'xǁMPDǁ__init____mutmut_18': xǁMPDǁ__init____mutmut_18, 
        'xǁMPDǁ__init____mutmut_19': xǁMPDǁ__init____mutmut_19, 
        'xǁMPDǁ__init____mutmut_20': xǁMPDǁ__init____mutmut_20, 
        'xǁMPDǁ__init____mutmut_21': xǁMPDǁ__init____mutmut_21, 
        'xǁMPDǁ__init____mutmut_22': xǁMPDǁ__init____mutmut_22, 
        'xǁMPDǁ__init____mutmut_23': xǁMPDǁ__init____mutmut_23, 
        'xǁMPDǁ__init____mutmut_24': xǁMPDǁ__init____mutmut_24, 
        'xǁMPDǁ__init____mutmut_25': xǁMPDǁ__init____mutmut_25, 
        'xǁMPDǁ__init____mutmut_26': xǁMPDǁ__init____mutmut_26, 
        'xǁMPDǁ__init____mutmut_27': xǁMPDǁ__init____mutmut_27, 
        'xǁMPDǁ__init____mutmut_28': xǁMPDǁ__init____mutmut_28, 
        'xǁMPDǁ__init____mutmut_29': xǁMPDǁ__init____mutmut_29, 
        'xǁMPDǁ__init____mutmut_30': xǁMPDǁ__init____mutmut_30, 
        'xǁMPDǁ__init____mutmut_31': xǁMPDǁ__init____mutmut_31, 
        'xǁMPDǁ__init____mutmut_32': xǁMPDǁ__init____mutmut_32, 
        'xǁMPDǁ__init____mutmut_33': xǁMPDǁ__init____mutmut_33, 
        'xǁMPDǁ__init____mutmut_34': xǁMPDǁ__init____mutmut_34, 
        'xǁMPDǁ__init____mutmut_35': xǁMPDǁ__init____mutmut_35, 
        'xǁMPDǁ__init____mutmut_36': xǁMPDǁ__init____mutmut_36, 
        'xǁMPDǁ__init____mutmut_37': xǁMPDǁ__init____mutmut_37, 
        'xǁMPDǁ__init____mutmut_38': xǁMPDǁ__init____mutmut_38, 
        'xǁMPDǁ__init____mutmut_39': xǁMPDǁ__init____mutmut_39, 
        'xǁMPDǁ__init____mutmut_40': xǁMPDǁ__init____mutmut_40, 
        'xǁMPDǁ__init____mutmut_41': xǁMPDǁ__init____mutmut_41, 
        'xǁMPDǁ__init____mutmut_42': xǁMPDǁ__init____mutmut_42, 
        'xǁMPDǁ__init____mutmut_43': xǁMPDǁ__init____mutmut_43, 
        'xǁMPDǁ__init____mutmut_44': xǁMPDǁ__init____mutmut_44, 
        'xǁMPDǁ__init____mutmut_45': xǁMPDǁ__init____mutmut_45, 
        'xǁMPDǁ__init____mutmut_46': xǁMPDǁ__init____mutmut_46, 
        'xǁMPDǁ__init____mutmut_47': xǁMPDǁ__init____mutmut_47, 
        'xǁMPDǁ__init____mutmut_48': xǁMPDǁ__init____mutmut_48, 
        'xǁMPDǁ__init____mutmut_49': xǁMPDǁ__init____mutmut_49, 
        'xǁMPDǁ__init____mutmut_50': xǁMPDǁ__init____mutmut_50, 
        'xǁMPDǁ__init____mutmut_51': xǁMPDǁ__init____mutmut_51, 
        'xǁMPDǁ__init____mutmut_52': xǁMPDǁ__init____mutmut_52, 
        'xǁMPDǁ__init____mutmut_53': xǁMPDǁ__init____mutmut_53, 
        'xǁMPDǁ__init____mutmut_54': xǁMPDǁ__init____mutmut_54, 
        'xǁMPDǁ__init____mutmut_55': xǁMPDǁ__init____mutmut_55, 
        'xǁMPDǁ__init____mutmut_56': xǁMPDǁ__init____mutmut_56, 
        'xǁMPDǁ__init____mutmut_57': xǁMPDǁ__init____mutmut_57, 
        'xǁMPDǁ__init____mutmut_58': xǁMPDǁ__init____mutmut_58, 
        'xǁMPDǁ__init____mutmut_59': xǁMPDǁ__init____mutmut_59, 
        'xǁMPDǁ__init____mutmut_60': xǁMPDǁ__init____mutmut_60, 
        'xǁMPDǁ__init____mutmut_61': xǁMPDǁ__init____mutmut_61, 
        'xǁMPDǁ__init____mutmut_62': xǁMPDǁ__init____mutmut_62, 
        'xǁMPDǁ__init____mutmut_63': xǁMPDǁ__init____mutmut_63, 
        'xǁMPDǁ__init____mutmut_64': xǁMPDǁ__init____mutmut_64, 
        'xǁMPDǁ__init____mutmut_65': xǁMPDǁ__init____mutmut_65, 
        'xǁMPDǁ__init____mutmut_66': xǁMPDǁ__init____mutmut_66, 
        'xǁMPDǁ__init____mutmut_67': xǁMPDǁ__init____mutmut_67, 
        'xǁMPDǁ__init____mutmut_68': xǁMPDǁ__init____mutmut_68, 
        'xǁMPDǁ__init____mutmut_69': xǁMPDǁ__init____mutmut_69, 
        'xǁMPDǁ__init____mutmut_70': xǁMPDǁ__init____mutmut_70, 
        'xǁMPDǁ__init____mutmut_71': xǁMPDǁ__init____mutmut_71, 
        'xǁMPDǁ__init____mutmut_72': xǁMPDǁ__init____mutmut_72, 
        'xǁMPDǁ__init____mutmut_73': xǁMPDǁ__init____mutmut_73, 
        'xǁMPDǁ__init____mutmut_74': xǁMPDǁ__init____mutmut_74, 
        'xǁMPDǁ__init____mutmut_75': xǁMPDǁ__init____mutmut_75, 
        'xǁMPDǁ__init____mutmut_76': xǁMPDǁ__init____mutmut_76, 
        'xǁMPDǁ__init____mutmut_77': xǁMPDǁ__init____mutmut_77, 
        'xǁMPDǁ__init____mutmut_78': xǁMPDǁ__init____mutmut_78, 
        'xǁMPDǁ__init____mutmut_79': xǁMPDǁ__init____mutmut_79, 
        'xǁMPDǁ__init____mutmut_80': xǁMPDǁ__init____mutmut_80, 
        'xǁMPDǁ__init____mutmut_81': xǁMPDǁ__init____mutmut_81, 
        'xǁMPDǁ__init____mutmut_82': xǁMPDǁ__init____mutmut_82, 
        'xǁMPDǁ__init____mutmut_83': xǁMPDǁ__init____mutmut_83, 
        'xǁMPDǁ__init____mutmut_84': xǁMPDǁ__init____mutmut_84, 
        'xǁMPDǁ__init____mutmut_85': xǁMPDǁ__init____mutmut_85, 
        'xǁMPDǁ__init____mutmut_86': xǁMPDǁ__init____mutmut_86, 
        'xǁMPDǁ__init____mutmut_87': xǁMPDǁ__init____mutmut_87, 
        'xǁMPDǁ__init____mutmut_88': xǁMPDǁ__init____mutmut_88, 
        'xǁMPDǁ__init____mutmut_89': xǁMPDǁ__init____mutmut_89, 
        'xǁMPDǁ__init____mutmut_90': xǁMPDǁ__init____mutmut_90, 
        'xǁMPDǁ__init____mutmut_91': xǁMPDǁ__init____mutmut_91, 
        'xǁMPDǁ__init____mutmut_92': xǁMPDǁ__init____mutmut_92, 
        'xǁMPDǁ__init____mutmut_93': xǁMPDǁ__init____mutmut_93, 
        'xǁMPDǁ__init____mutmut_94': xǁMPDǁ__init____mutmut_94, 
        'xǁMPDǁ__init____mutmut_95': xǁMPDǁ__init____mutmut_95, 
        'xǁMPDǁ__init____mutmut_96': xǁMPDǁ__init____mutmut_96, 
        'xǁMPDǁ__init____mutmut_97': xǁMPDǁ__init____mutmut_97, 
        'xǁMPDǁ__init____mutmut_98': xǁMPDǁ__init____mutmut_98, 
        'xǁMPDǁ__init____mutmut_99': xǁMPDǁ__init____mutmut_99, 
        'xǁMPDǁ__init____mutmut_100': xǁMPDǁ__init____mutmut_100, 
        'xǁMPDǁ__init____mutmut_101': xǁMPDǁ__init____mutmut_101, 
        'xǁMPDǁ__init____mutmut_102': xǁMPDǁ__init____mutmut_102, 
        'xǁMPDǁ__init____mutmut_103': xǁMPDǁ__init____mutmut_103, 
        'xǁMPDǁ__init____mutmut_104': xǁMPDǁ__init____mutmut_104, 
        'xǁMPDǁ__init____mutmut_105': xǁMPDǁ__init____mutmut_105, 
        'xǁMPDǁ__init____mutmut_106': xǁMPDǁ__init____mutmut_106, 
        'xǁMPDǁ__init____mutmut_107': xǁMPDǁ__init____mutmut_107, 
        'xǁMPDǁ__init____mutmut_108': xǁMPDǁ__init____mutmut_108, 
        'xǁMPDǁ__init____mutmut_109': xǁMPDǁ__init____mutmut_109, 
        'xǁMPDǁ__init____mutmut_110': xǁMPDǁ__init____mutmut_110, 
        'xǁMPDǁ__init____mutmut_111': xǁMPDǁ__init____mutmut_111, 
        'xǁMPDǁ__init____mutmut_112': xǁMPDǁ__init____mutmut_112, 
        'xǁMPDǁ__init____mutmut_113': xǁMPDǁ__init____mutmut_113, 
        'xǁMPDǁ__init____mutmut_114': xǁMPDǁ__init____mutmut_114, 
        'xǁMPDǁ__init____mutmut_115': xǁMPDǁ__init____mutmut_115, 
        'xǁMPDǁ__init____mutmut_116': xǁMPDǁ__init____mutmut_116, 
        'xǁMPDǁ__init____mutmut_117': xǁMPDǁ__init____mutmut_117, 
        'xǁMPDǁ__init____mutmut_118': xǁMPDǁ__init____mutmut_118, 
        'xǁMPDǁ__init____mutmut_119': xǁMPDǁ__init____mutmut_119, 
        'xǁMPDǁ__init____mutmut_120': xǁMPDǁ__init____mutmut_120, 
        'xǁMPDǁ__init____mutmut_121': xǁMPDǁ__init____mutmut_121, 
        'xǁMPDǁ__init____mutmut_122': xǁMPDǁ__init____mutmut_122, 
        'xǁMPDǁ__init____mutmut_123': xǁMPDǁ__init____mutmut_123, 
        'xǁMPDǁ__init____mutmut_124': xǁMPDǁ__init____mutmut_124, 
        'xǁMPDǁ__init____mutmut_125': xǁMPDǁ__init____mutmut_125, 
        'xǁMPDǁ__init____mutmut_126': xǁMPDǁ__init____mutmut_126, 
        'xǁMPDǁ__init____mutmut_127': xǁMPDǁ__init____mutmut_127, 
        'xǁMPDǁ__init____mutmut_128': xǁMPDǁ__init____mutmut_128, 
        'xǁMPDǁ__init____mutmut_129': xǁMPDǁ__init____mutmut_129, 
        'xǁMPDǁ__init____mutmut_130': xǁMPDǁ__init____mutmut_130, 
        'xǁMPDǁ__init____mutmut_131': xǁMPDǁ__init____mutmut_131, 
        'xǁMPDǁ__init____mutmut_132': xǁMPDǁ__init____mutmut_132, 
        'xǁMPDǁ__init____mutmut_133': xǁMPDǁ__init____mutmut_133, 
        'xǁMPDǁ__init____mutmut_134': xǁMPDǁ__init____mutmut_134, 
        'xǁMPDǁ__init____mutmut_135': xǁMPDǁ__init____mutmut_135, 
        'xǁMPDǁ__init____mutmut_136': xǁMPDǁ__init____mutmut_136, 
        'xǁMPDǁ__init____mutmut_137': xǁMPDǁ__init____mutmut_137, 
        'xǁMPDǁ__init____mutmut_138': xǁMPDǁ__init____mutmut_138, 
        'xǁMPDǁ__init____mutmut_139': xǁMPDǁ__init____mutmut_139, 
        'xǁMPDǁ__init____mutmut_140': xǁMPDǁ__init____mutmut_140, 
        'xǁMPDǁ__init____mutmut_141': xǁMPDǁ__init____mutmut_141, 
        'xǁMPDǁ__init____mutmut_142': xǁMPDǁ__init____mutmut_142, 
        'xǁMPDǁ__init____mutmut_143': xǁMPDǁ__init____mutmut_143, 
        'xǁMPDǁ__init____mutmut_144': xǁMPDǁ__init____mutmut_144, 
        'xǁMPDǁ__init____mutmut_145': xǁMPDǁ__init____mutmut_145, 
        'xǁMPDǁ__init____mutmut_146': xǁMPDǁ__init____mutmut_146, 
        'xǁMPDǁ__init____mutmut_147': xǁMPDǁ__init____mutmut_147, 
        'xǁMPDǁ__init____mutmut_148': xǁMPDǁ__init____mutmut_148, 
        'xǁMPDǁ__init____mutmut_149': xǁMPDǁ__init____mutmut_149, 
        'xǁMPDǁ__init____mutmut_150': xǁMPDǁ__init____mutmut_150, 
        'xǁMPDǁ__init____mutmut_151': xǁMPDǁ__init____mutmut_151, 
        'xǁMPDǁ__init____mutmut_152': xǁMPDǁ__init____mutmut_152, 
        'xǁMPDǁ__init____mutmut_153': xǁMPDǁ__init____mutmut_153, 
        'xǁMPDǁ__init____mutmut_154': xǁMPDǁ__init____mutmut_154, 
        'xǁMPDǁ__init____mutmut_155': xǁMPDǁ__init____mutmut_155, 
        'xǁMPDǁ__init____mutmut_156': xǁMPDǁ__init____mutmut_156, 
        'xǁMPDǁ__init____mutmut_157': xǁMPDǁ__init____mutmut_157, 
        'xǁMPDǁ__init____mutmut_158': xǁMPDǁ__init____mutmut_158, 
        'xǁMPDǁ__init____mutmut_159': xǁMPDǁ__init____mutmut_159, 
        'xǁMPDǁ__init____mutmut_160': xǁMPDǁ__init____mutmut_160, 
        'xǁMPDǁ__init____mutmut_161': xǁMPDǁ__init____mutmut_161, 
        'xǁMPDǁ__init____mutmut_162': xǁMPDǁ__init____mutmut_162, 
        'xǁMPDǁ__init____mutmut_163': xǁMPDǁ__init____mutmut_163, 
        'xǁMPDǁ__init____mutmut_164': xǁMPDǁ__init____mutmut_164, 
        'xǁMPDǁ__init____mutmut_165': xǁMPDǁ__init____mutmut_165, 
        'xǁMPDǁ__init____mutmut_166': xǁMPDǁ__init____mutmut_166, 
        'xǁMPDǁ__init____mutmut_167': xǁMPDǁ__init____mutmut_167, 
        'xǁMPDǁ__init____mutmut_168': xǁMPDǁ__init____mutmut_168, 
        'xǁMPDǁ__init____mutmut_169': xǁMPDǁ__init____mutmut_169, 
        'xǁMPDǁ__init____mutmut_170': xǁMPDǁ__init____mutmut_170, 
        'xǁMPDǁ__init____mutmut_171': xǁMPDǁ__init____mutmut_171, 
        'xǁMPDǁ__init____mutmut_172': xǁMPDǁ__init____mutmut_172, 
        'xǁMPDǁ__init____mutmut_173': xǁMPDǁ__init____mutmut_173, 
        'xǁMPDǁ__init____mutmut_174': xǁMPDǁ__init____mutmut_174, 
        'xǁMPDǁ__init____mutmut_175': xǁMPDǁ__init____mutmut_175, 
        'xǁMPDǁ__init____mutmut_176': xǁMPDǁ__init____mutmut_176, 
        'xǁMPDǁ__init____mutmut_177': xǁMPDǁ__init____mutmut_177, 
        'xǁMPDǁ__init____mutmut_178': xǁMPDǁ__init____mutmut_178, 
        'xǁMPDǁ__init____mutmut_179': xǁMPDǁ__init____mutmut_179, 
        'xǁMPDǁ__init____mutmut_180': xǁMPDǁ__init____mutmut_180, 
        'xǁMPDǁ__init____mutmut_181': xǁMPDǁ__init____mutmut_181
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁMPDǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁMPDǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁMPDǁ__init____mutmut_orig)
    xǁMPDǁ__init____mutmut_orig.__name__ = 'xǁMPDǁ__init__'

    def xǁMPDǁget_representation__mutmut_orig(self, ident: TTimelineIdent) -> Representation | None:
        """
        Find the first Representation instance with a matching ident
        """
        for period in self.periods:
            for adaptationset in period.adaptationSets:
                for representation in adaptationset.representations:
                    if representation.ident == ident:
                        return representation

    def xǁMPDǁget_representation__mutmut_1(self, ident: TTimelineIdent) -> Representation | None:
        """
        Find the first Representation instance with a matching ident
        """
        for period in self.periods:
            for adaptationset in period.adaptationSets:
                for representation in adaptationset.representations:
                    if representation.ident != ident:
                        return representation
    
    xǁMPDǁget_representation__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁMPDǁget_representation__mutmut_1': xǁMPDǁget_representation__mutmut_1
    }
    
    def get_representation(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁMPDǁget_representation__mutmut_orig"), object.__getattribute__(self, "xǁMPDǁget_representation__mutmut_mutants"), args, kwargs, self)
        return result 
    
    get_representation.__signature__ = _mutmut_signature(xǁMPDǁget_representation__mutmut_orig)
    xǁMPDǁget_representation__mutmut_orig.__name__ = 'xǁMPDǁget_representation'


class ProgramInformation(MPDNode):
    __tag__ = "ProgramInformation"


class BaseURL(MPDNode):
    __tag__ = "BaseURL"

    def xǁBaseURLǁ__init____mutmut_orig(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.url = (self.text or "").strip()

    def xǁBaseURLǁ__init____mutmut_1(self, *args, **kwargs) -> None:
        super().__init__(**kwargs)

        self.url = (self.text or "").strip()

    def xǁBaseURLǁ__init____mutmut_2(self, *args, **kwargs) -> None:
        super().__init__(*args, )

        self.url = (self.text or "").strip()

    def xǁBaseURLǁ__init____mutmut_3(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.url = None

    def xǁBaseURLǁ__init____mutmut_4(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.url = (self.text and "").strip()

    def xǁBaseURLǁ__init____mutmut_5(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.url = (self.text or "XXXX").strip()
    
    xǁBaseURLǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁBaseURLǁ__init____mutmut_1': xǁBaseURLǁ__init____mutmut_1, 
        'xǁBaseURLǁ__init____mutmut_2': xǁBaseURLǁ__init____mutmut_2, 
        'xǁBaseURLǁ__init____mutmut_3': xǁBaseURLǁ__init____mutmut_3, 
        'xǁBaseURLǁ__init____mutmut_4': xǁBaseURLǁ__init____mutmut_4, 
        'xǁBaseURLǁ__init____mutmut_5': xǁBaseURLǁ__init____mutmut_5
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁBaseURLǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁBaseURLǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁBaseURLǁ__init____mutmut_orig)
    xǁBaseURLǁ__init____mutmut_orig.__name__ = 'xǁBaseURLǁ__init__'


class Location(MPDNode):
    __tag__ = "Location"


class Period(MPDNode):
    __tag__ = "Period"

    def xǁPeriodǁ__init____mutmut_orig(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_1(self, *args, **kwargs) -> None:
        super().__init__(**kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_2(self, *args, **kwargs) -> None:
        super().__init__(*args, )

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_3(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = None
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_4(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get(None, 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_5(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", None)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_6(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get(0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_7(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", )
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_8(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("XXiXX", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_9(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("I", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_10(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("I", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_11(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 1)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_12(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = None
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_13(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr(None)
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_14(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("XXidXX")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_15(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("ID")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_16(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("Id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_17(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = None
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_18(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            None,
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_19(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=None,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_20(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_21(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_22(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "XXbitstreamSwitchingXX",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_23(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamswitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_24(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "BITSTREAMSWITCHING",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_25(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "Bitstreamswitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_26(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = None
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_27(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            None,
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_28(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=None,
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_29(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=None,
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_30(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_31(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_32(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_33(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "XXdurationXX",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_34(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "DURATION",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_35(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "Duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_36(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(None),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_37(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = None

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_38(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            None,
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_39(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=None,
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_40(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=None,
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_41(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_42(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_43(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_44(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "XXstartXX",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_45(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "START",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_46(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "Start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_47(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(None),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_48(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = None
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_49(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type != "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_50(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "XXdynamicXX" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_51(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "DYNAMIC" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_52(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "Dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_53(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = None

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_54(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime - offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_55(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = None
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_56(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(None)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_57(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = None
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_58(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(None, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_59(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=None)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_60(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_61(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, )
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_62(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = None
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_63(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(None, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_64(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=None)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_65(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_66(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, )
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_67(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = None
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_68(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(None, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_69(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=None)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_70(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_71(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, )
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_72(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = None
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_73(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(None, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_74(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=None)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_75(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_76(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, )
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_77(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=2)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_78(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = None
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_79(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(None)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_80(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = None
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_81(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(None)
        self.subset = self.children(Subset)

    def xǁPeriodǁ__init____mutmut_82(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = None

    def xǁPeriodǁ__init____mutmut_83(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.i = kwargs.get("i", 0)
        self.id = self.attr("id")
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )
        self.duration = self.attr(
            "duration",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )
        self.start = self.attr(
            "start",
            parser=MPDParsers.duration(self.root.publishTime),
            default=timedelta(),
        )

        # anchor time for segment availability
        offset = self.start if self.root.type == "dynamic" else timedelta()
        self.availabilityStartTime = self.root.availabilityStartTime + offset

        # TODO: Early Access Periods

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self)
        self.segmentList = self.only_child(SegmentList, period=self)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self)
        self.adaptationSets = self.children(AdaptationSet, minimum=1)
        self.assetIdentifier = self.only_child(AssetIdentifier)
        self.eventStream = self.children(EventStream)
        self.subset = self.children(None)
    
    xǁPeriodǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁPeriodǁ__init____mutmut_1': xǁPeriodǁ__init____mutmut_1, 
        'xǁPeriodǁ__init____mutmut_2': xǁPeriodǁ__init____mutmut_2, 
        'xǁPeriodǁ__init____mutmut_3': xǁPeriodǁ__init____mutmut_3, 
        'xǁPeriodǁ__init____mutmut_4': xǁPeriodǁ__init____mutmut_4, 
        'xǁPeriodǁ__init____mutmut_5': xǁPeriodǁ__init____mutmut_5, 
        'xǁPeriodǁ__init____mutmut_6': xǁPeriodǁ__init____mutmut_6, 
        'xǁPeriodǁ__init____mutmut_7': xǁPeriodǁ__init____mutmut_7, 
        'xǁPeriodǁ__init____mutmut_8': xǁPeriodǁ__init____mutmut_8, 
        'xǁPeriodǁ__init____mutmut_9': xǁPeriodǁ__init____mutmut_9, 
        'xǁPeriodǁ__init____mutmut_10': xǁPeriodǁ__init____mutmut_10, 
        'xǁPeriodǁ__init____mutmut_11': xǁPeriodǁ__init____mutmut_11, 
        'xǁPeriodǁ__init____mutmut_12': xǁPeriodǁ__init____mutmut_12, 
        'xǁPeriodǁ__init____mutmut_13': xǁPeriodǁ__init____mutmut_13, 
        'xǁPeriodǁ__init____mutmut_14': xǁPeriodǁ__init____mutmut_14, 
        'xǁPeriodǁ__init____mutmut_15': xǁPeriodǁ__init____mutmut_15, 
        'xǁPeriodǁ__init____mutmut_16': xǁPeriodǁ__init____mutmut_16, 
        'xǁPeriodǁ__init____mutmut_17': xǁPeriodǁ__init____mutmut_17, 
        'xǁPeriodǁ__init____mutmut_18': xǁPeriodǁ__init____mutmut_18, 
        'xǁPeriodǁ__init____mutmut_19': xǁPeriodǁ__init____mutmut_19, 
        'xǁPeriodǁ__init____mutmut_20': xǁPeriodǁ__init____mutmut_20, 
        'xǁPeriodǁ__init____mutmut_21': xǁPeriodǁ__init____mutmut_21, 
        'xǁPeriodǁ__init____mutmut_22': xǁPeriodǁ__init____mutmut_22, 
        'xǁPeriodǁ__init____mutmut_23': xǁPeriodǁ__init____mutmut_23, 
        'xǁPeriodǁ__init____mutmut_24': xǁPeriodǁ__init____mutmut_24, 
        'xǁPeriodǁ__init____mutmut_25': xǁPeriodǁ__init____mutmut_25, 
        'xǁPeriodǁ__init____mutmut_26': xǁPeriodǁ__init____mutmut_26, 
        'xǁPeriodǁ__init____mutmut_27': xǁPeriodǁ__init____mutmut_27, 
        'xǁPeriodǁ__init____mutmut_28': xǁPeriodǁ__init____mutmut_28, 
        'xǁPeriodǁ__init____mutmut_29': xǁPeriodǁ__init____mutmut_29, 
        'xǁPeriodǁ__init____mutmut_30': xǁPeriodǁ__init____mutmut_30, 
        'xǁPeriodǁ__init____mutmut_31': xǁPeriodǁ__init____mutmut_31, 
        'xǁPeriodǁ__init____mutmut_32': xǁPeriodǁ__init____mutmut_32, 
        'xǁPeriodǁ__init____mutmut_33': xǁPeriodǁ__init____mutmut_33, 
        'xǁPeriodǁ__init____mutmut_34': xǁPeriodǁ__init____mutmut_34, 
        'xǁPeriodǁ__init____mutmut_35': xǁPeriodǁ__init____mutmut_35, 
        'xǁPeriodǁ__init____mutmut_36': xǁPeriodǁ__init____mutmut_36, 
        'xǁPeriodǁ__init____mutmut_37': xǁPeriodǁ__init____mutmut_37, 
        'xǁPeriodǁ__init____mutmut_38': xǁPeriodǁ__init____mutmut_38, 
        'xǁPeriodǁ__init____mutmut_39': xǁPeriodǁ__init____mutmut_39, 
        'xǁPeriodǁ__init____mutmut_40': xǁPeriodǁ__init____mutmut_40, 
        'xǁPeriodǁ__init____mutmut_41': xǁPeriodǁ__init____mutmut_41, 
        'xǁPeriodǁ__init____mutmut_42': xǁPeriodǁ__init____mutmut_42, 
        'xǁPeriodǁ__init____mutmut_43': xǁPeriodǁ__init____mutmut_43, 
        'xǁPeriodǁ__init____mutmut_44': xǁPeriodǁ__init____mutmut_44, 
        'xǁPeriodǁ__init____mutmut_45': xǁPeriodǁ__init____mutmut_45, 
        'xǁPeriodǁ__init____mutmut_46': xǁPeriodǁ__init____mutmut_46, 
        'xǁPeriodǁ__init____mutmut_47': xǁPeriodǁ__init____mutmut_47, 
        'xǁPeriodǁ__init____mutmut_48': xǁPeriodǁ__init____mutmut_48, 
        'xǁPeriodǁ__init____mutmut_49': xǁPeriodǁ__init____mutmut_49, 
        'xǁPeriodǁ__init____mutmut_50': xǁPeriodǁ__init____mutmut_50, 
        'xǁPeriodǁ__init____mutmut_51': xǁPeriodǁ__init____mutmut_51, 
        'xǁPeriodǁ__init____mutmut_52': xǁPeriodǁ__init____mutmut_52, 
        'xǁPeriodǁ__init____mutmut_53': xǁPeriodǁ__init____mutmut_53, 
        'xǁPeriodǁ__init____mutmut_54': xǁPeriodǁ__init____mutmut_54, 
        'xǁPeriodǁ__init____mutmut_55': xǁPeriodǁ__init____mutmut_55, 
        'xǁPeriodǁ__init____mutmut_56': xǁPeriodǁ__init____mutmut_56, 
        'xǁPeriodǁ__init____mutmut_57': xǁPeriodǁ__init____mutmut_57, 
        'xǁPeriodǁ__init____mutmut_58': xǁPeriodǁ__init____mutmut_58, 
        'xǁPeriodǁ__init____mutmut_59': xǁPeriodǁ__init____mutmut_59, 
        'xǁPeriodǁ__init____mutmut_60': xǁPeriodǁ__init____mutmut_60, 
        'xǁPeriodǁ__init____mutmut_61': xǁPeriodǁ__init____mutmut_61, 
        'xǁPeriodǁ__init____mutmut_62': xǁPeriodǁ__init____mutmut_62, 
        'xǁPeriodǁ__init____mutmut_63': xǁPeriodǁ__init____mutmut_63, 
        'xǁPeriodǁ__init____mutmut_64': xǁPeriodǁ__init____mutmut_64, 
        'xǁPeriodǁ__init____mutmut_65': xǁPeriodǁ__init____mutmut_65, 
        'xǁPeriodǁ__init____mutmut_66': xǁPeriodǁ__init____mutmut_66, 
        'xǁPeriodǁ__init____mutmut_67': xǁPeriodǁ__init____mutmut_67, 
        'xǁPeriodǁ__init____mutmut_68': xǁPeriodǁ__init____mutmut_68, 
        'xǁPeriodǁ__init____mutmut_69': xǁPeriodǁ__init____mutmut_69, 
        'xǁPeriodǁ__init____mutmut_70': xǁPeriodǁ__init____mutmut_70, 
        'xǁPeriodǁ__init____mutmut_71': xǁPeriodǁ__init____mutmut_71, 
        'xǁPeriodǁ__init____mutmut_72': xǁPeriodǁ__init____mutmut_72, 
        'xǁPeriodǁ__init____mutmut_73': xǁPeriodǁ__init____mutmut_73, 
        'xǁPeriodǁ__init____mutmut_74': xǁPeriodǁ__init____mutmut_74, 
        'xǁPeriodǁ__init____mutmut_75': xǁPeriodǁ__init____mutmut_75, 
        'xǁPeriodǁ__init____mutmut_76': xǁPeriodǁ__init____mutmut_76, 
        'xǁPeriodǁ__init____mutmut_77': xǁPeriodǁ__init____mutmut_77, 
        'xǁPeriodǁ__init____mutmut_78': xǁPeriodǁ__init____mutmut_78, 
        'xǁPeriodǁ__init____mutmut_79': xǁPeriodǁ__init____mutmut_79, 
        'xǁPeriodǁ__init____mutmut_80': xǁPeriodǁ__init____mutmut_80, 
        'xǁPeriodǁ__init____mutmut_81': xǁPeriodǁ__init____mutmut_81, 
        'xǁPeriodǁ__init____mutmut_82': xǁPeriodǁ__init____mutmut_82, 
        'xǁPeriodǁ__init____mutmut_83': xǁPeriodǁ__init____mutmut_83
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁPeriodǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁPeriodǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁPeriodǁ__init____mutmut_orig)
    xǁPeriodǁ__init____mutmut_orig.__name__ = 'xǁPeriodǁ__init__'


class AssetIdentifier(MPDNode):
    __tag__ = "AssetIdentifier"


class Subset(MPDNode):
    __tag__ = "Subset"


class EventStream(MPDNode):
    __tag__ = "EventStream"


class _RepresentationBaseType(MPDNode):
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_orig(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_1(self, *args, **kwargs) -> None:
        super().__init__(**kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_2(self, *args, **kwargs) -> None:
        super().__init__(*args, )

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_3(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = None

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_4(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            None,
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_5(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=None,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_6(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=None,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_7(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_8(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_9(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_10(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "XXmimeTypeXX",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_11(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimetype",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_12(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "MIMETYPE",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_13(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "Mimetype",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_14(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(None) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_15(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is not Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_16(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = None
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_17(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            None,
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_18(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=None,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_19(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_20(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_21(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "XXprofilesXX",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_22(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "PROFILES",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_23(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "Profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_24(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = None
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_25(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            None,
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_26(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=None,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_27(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=None,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_28(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_29(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_30(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_31(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "XXwidthXX",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_32(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "WIDTH",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_33(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "Width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_34(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = None
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_35(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            None,
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_36(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=None,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_37(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=None,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_38(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_39(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_40(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_41(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "XXheightXX",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_42(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "HEIGHT",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_43(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "Height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_44(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = None
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_45(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            None,
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_46(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=None,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_47(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_48(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_49(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "XXsarXX",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_50(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "SAR",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_51(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "Sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_52(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = None
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_53(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            None,
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_54(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=None,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_55(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=None,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_56(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_57(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_58(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_59(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "XXframeRateXX",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_60(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "framerate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_61(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "FRAMERATE",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_62(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "Framerate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_63(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = None
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_64(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            None,
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_65(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=None,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_66(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=None,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_67(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_68(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_69(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_70(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "XXaudioSamplingRateXX",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_71(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audiosamplingrate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_72(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "AUDIOSAMPLINGRATE",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_73(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "Audiosamplingrate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_74(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = None
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_75(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            None,
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_76(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=None,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_77(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_78(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_79(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "XXcodecsXX",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_80(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "CODECS",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_81(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "Codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_82(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = None

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_83(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            None,
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_84(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=None,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_85(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_86(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_87(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "XXscanTypeXX",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_88(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scantype",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_89(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "SCANTYPE",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_90(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "Scantype",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(ContentProtection)
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_91(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = None
    def xǁ_RepresentationBaseTypeǁ__init____mutmut_92(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        # mimeType must be set on the AdaptationSet or Representation
        self.mimeType: str = self.attr(  # type: ignore[assignment]
            "mimeType",
            required=type(self) is Representation,
            inherited=_RepresentationBaseType,
        )

        self.profiles = self.attr(
            "profiles",
            inherited=_RepresentationBaseType,
        )
        self.width = self.attr(
            "width",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.height = self.attr(
            "height",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.sar = self.attr(
            "sar",
            inherited=_RepresentationBaseType,
        )
        self.frameRate = self.attr(
            "frameRate",
            parser=MPDParsers.frame_rate,
            inherited=_RepresentationBaseType,
        )
        self.audioSamplingRate = self.attr(
            "audioSamplingRate",
            parser=int,
            inherited=_RepresentationBaseType,
        )
        self.codecs = self.attr(
            "codecs",
            inherited=_RepresentationBaseType,
        )
        self.scanType = self.attr(
            "scanType",
            inherited=_RepresentationBaseType,
        )

        self.contentProtections = self.children(None)
    
    xǁ_RepresentationBaseTypeǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_RepresentationBaseTypeǁ__init____mutmut_1': xǁ_RepresentationBaseTypeǁ__init____mutmut_1, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_2': xǁ_RepresentationBaseTypeǁ__init____mutmut_2, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_3': xǁ_RepresentationBaseTypeǁ__init____mutmut_3, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_4': xǁ_RepresentationBaseTypeǁ__init____mutmut_4, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_5': xǁ_RepresentationBaseTypeǁ__init____mutmut_5, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_6': xǁ_RepresentationBaseTypeǁ__init____mutmut_6, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_7': xǁ_RepresentationBaseTypeǁ__init____mutmut_7, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_8': xǁ_RepresentationBaseTypeǁ__init____mutmut_8, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_9': xǁ_RepresentationBaseTypeǁ__init____mutmut_9, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_10': xǁ_RepresentationBaseTypeǁ__init____mutmut_10, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_11': xǁ_RepresentationBaseTypeǁ__init____mutmut_11, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_12': xǁ_RepresentationBaseTypeǁ__init____mutmut_12, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_13': xǁ_RepresentationBaseTypeǁ__init____mutmut_13, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_14': xǁ_RepresentationBaseTypeǁ__init____mutmut_14, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_15': xǁ_RepresentationBaseTypeǁ__init____mutmut_15, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_16': xǁ_RepresentationBaseTypeǁ__init____mutmut_16, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_17': xǁ_RepresentationBaseTypeǁ__init____mutmut_17, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_18': xǁ_RepresentationBaseTypeǁ__init____mutmut_18, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_19': xǁ_RepresentationBaseTypeǁ__init____mutmut_19, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_20': xǁ_RepresentationBaseTypeǁ__init____mutmut_20, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_21': xǁ_RepresentationBaseTypeǁ__init____mutmut_21, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_22': xǁ_RepresentationBaseTypeǁ__init____mutmut_22, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_23': xǁ_RepresentationBaseTypeǁ__init____mutmut_23, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_24': xǁ_RepresentationBaseTypeǁ__init____mutmut_24, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_25': xǁ_RepresentationBaseTypeǁ__init____mutmut_25, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_26': xǁ_RepresentationBaseTypeǁ__init____mutmut_26, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_27': xǁ_RepresentationBaseTypeǁ__init____mutmut_27, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_28': xǁ_RepresentationBaseTypeǁ__init____mutmut_28, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_29': xǁ_RepresentationBaseTypeǁ__init____mutmut_29, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_30': xǁ_RepresentationBaseTypeǁ__init____mutmut_30, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_31': xǁ_RepresentationBaseTypeǁ__init____mutmut_31, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_32': xǁ_RepresentationBaseTypeǁ__init____mutmut_32, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_33': xǁ_RepresentationBaseTypeǁ__init____mutmut_33, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_34': xǁ_RepresentationBaseTypeǁ__init____mutmut_34, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_35': xǁ_RepresentationBaseTypeǁ__init____mutmut_35, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_36': xǁ_RepresentationBaseTypeǁ__init____mutmut_36, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_37': xǁ_RepresentationBaseTypeǁ__init____mutmut_37, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_38': xǁ_RepresentationBaseTypeǁ__init____mutmut_38, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_39': xǁ_RepresentationBaseTypeǁ__init____mutmut_39, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_40': xǁ_RepresentationBaseTypeǁ__init____mutmut_40, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_41': xǁ_RepresentationBaseTypeǁ__init____mutmut_41, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_42': xǁ_RepresentationBaseTypeǁ__init____mutmut_42, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_43': xǁ_RepresentationBaseTypeǁ__init____mutmut_43, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_44': xǁ_RepresentationBaseTypeǁ__init____mutmut_44, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_45': xǁ_RepresentationBaseTypeǁ__init____mutmut_45, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_46': xǁ_RepresentationBaseTypeǁ__init____mutmut_46, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_47': xǁ_RepresentationBaseTypeǁ__init____mutmut_47, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_48': xǁ_RepresentationBaseTypeǁ__init____mutmut_48, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_49': xǁ_RepresentationBaseTypeǁ__init____mutmut_49, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_50': xǁ_RepresentationBaseTypeǁ__init____mutmut_50, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_51': xǁ_RepresentationBaseTypeǁ__init____mutmut_51, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_52': xǁ_RepresentationBaseTypeǁ__init____mutmut_52, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_53': xǁ_RepresentationBaseTypeǁ__init____mutmut_53, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_54': xǁ_RepresentationBaseTypeǁ__init____mutmut_54, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_55': xǁ_RepresentationBaseTypeǁ__init____mutmut_55, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_56': xǁ_RepresentationBaseTypeǁ__init____mutmut_56, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_57': xǁ_RepresentationBaseTypeǁ__init____mutmut_57, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_58': xǁ_RepresentationBaseTypeǁ__init____mutmut_58, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_59': xǁ_RepresentationBaseTypeǁ__init____mutmut_59, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_60': xǁ_RepresentationBaseTypeǁ__init____mutmut_60, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_61': xǁ_RepresentationBaseTypeǁ__init____mutmut_61, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_62': xǁ_RepresentationBaseTypeǁ__init____mutmut_62, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_63': xǁ_RepresentationBaseTypeǁ__init____mutmut_63, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_64': xǁ_RepresentationBaseTypeǁ__init____mutmut_64, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_65': xǁ_RepresentationBaseTypeǁ__init____mutmut_65, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_66': xǁ_RepresentationBaseTypeǁ__init____mutmut_66, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_67': xǁ_RepresentationBaseTypeǁ__init____mutmut_67, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_68': xǁ_RepresentationBaseTypeǁ__init____mutmut_68, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_69': xǁ_RepresentationBaseTypeǁ__init____mutmut_69, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_70': xǁ_RepresentationBaseTypeǁ__init____mutmut_70, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_71': xǁ_RepresentationBaseTypeǁ__init____mutmut_71, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_72': xǁ_RepresentationBaseTypeǁ__init____mutmut_72, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_73': xǁ_RepresentationBaseTypeǁ__init____mutmut_73, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_74': xǁ_RepresentationBaseTypeǁ__init____mutmut_74, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_75': xǁ_RepresentationBaseTypeǁ__init____mutmut_75, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_76': xǁ_RepresentationBaseTypeǁ__init____mutmut_76, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_77': xǁ_RepresentationBaseTypeǁ__init____mutmut_77, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_78': xǁ_RepresentationBaseTypeǁ__init____mutmut_78, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_79': xǁ_RepresentationBaseTypeǁ__init____mutmut_79, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_80': xǁ_RepresentationBaseTypeǁ__init____mutmut_80, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_81': xǁ_RepresentationBaseTypeǁ__init____mutmut_81, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_82': xǁ_RepresentationBaseTypeǁ__init____mutmut_82, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_83': xǁ_RepresentationBaseTypeǁ__init____mutmut_83, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_84': xǁ_RepresentationBaseTypeǁ__init____mutmut_84, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_85': xǁ_RepresentationBaseTypeǁ__init____mutmut_85, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_86': xǁ_RepresentationBaseTypeǁ__init____mutmut_86, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_87': xǁ_RepresentationBaseTypeǁ__init____mutmut_87, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_88': xǁ_RepresentationBaseTypeǁ__init____mutmut_88, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_89': xǁ_RepresentationBaseTypeǁ__init____mutmut_89, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_90': xǁ_RepresentationBaseTypeǁ__init____mutmut_90, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_91': xǁ_RepresentationBaseTypeǁ__init____mutmut_91, 
        'xǁ_RepresentationBaseTypeǁ__init____mutmut_92': xǁ_RepresentationBaseTypeǁ__init____mutmut_92
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_RepresentationBaseTypeǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁ_RepresentationBaseTypeǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁ_RepresentationBaseTypeǁ__init____mutmut_orig)
    xǁ_RepresentationBaseTypeǁ__init____mutmut_orig.__name__ = 'xǁ_RepresentationBaseTypeǁ__init__'


class AdaptationSet(_RepresentationBaseType):
    __tag__ = "AdaptationSet"

    parent: Period

    def xǁAdaptationSetǁ__init____mutmut_orig(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_1(self, *args, **kwargs) -> None:
        super().__init__(**kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_2(self, *args, **kwargs) -> None:
        super().__init__(*args, )

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_3(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = None
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_4(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr(None)
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_5(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("XXidXX")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_6(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("ID")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_7(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("Id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_8(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = None
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_9(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr(None)
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_10(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("XXgroupXX")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_11(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("GROUP")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_12(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("Group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_13(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = None
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_14(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr(None)
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_15(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("XXlangXX")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_16(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("LANG")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_17(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("Lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_18(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = None
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_19(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr(None)
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_20(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("XXcontentTypeXX")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_21(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contenttype")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_22(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("CONTENTTYPE")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_23(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("Contenttype")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_24(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = None
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_25(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr(None)
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_26(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("XXparXX")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_27(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("PAR")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_28(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("Par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_29(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = None
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_30(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr(None, parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_31(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=None)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_32(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr(parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_33(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", )
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_34(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("XXminBandwidthXX", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_35(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minbandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_36(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("MINBANDWIDTH", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_37(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("Minbandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_38(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = None
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_39(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr(None, parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_40(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=None)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_41(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr(parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_42(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", )
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_43(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("XXmaxBandwidthXX", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_44(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxbandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_45(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("MAXBANDWIDTH", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_46(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("Maxbandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_47(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = None
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_48(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr(None, parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_49(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=None)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_50(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr(parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_51(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", )
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_52(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("XXminWidthXX", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_53(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minwidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_54(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("MINWIDTH", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_55(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("Minwidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_56(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = None
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_57(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr(None, parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_58(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=None)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_59(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr(parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_60(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", )
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_61(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("XXmaxWidthXX", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_62(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxwidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_63(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("MAXWIDTH", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_64(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("Maxwidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_65(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = None
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_66(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr(None, parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_67(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=None)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_68(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr(parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_69(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", )
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_70(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("XXminHeightXX", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_71(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minheight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_72(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("MINHEIGHT", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_73(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("Minheight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_74(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = None
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_75(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr(None, parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_76(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=None)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_77(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr(parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_78(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", )
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_79(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("XXmaxHeightXX", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_80(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxheight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_81(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("MAXHEIGHT", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_82(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("Maxheight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_83(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = None
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_84(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr(None, parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_85(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=None)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_86(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr(parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_87(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", )
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_88(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("XXminFrameRateXX", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_89(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minframerate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_90(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("MINFRAMERATE", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_91(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("Minframerate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_92(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = None
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_93(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr(None, parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_94(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=None)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_95(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr(parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_96(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", )
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_97(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("XXmaxFrameRateXX", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_98(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxframerate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_99(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("MAXFRAMERATE", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_100(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("Maxframerate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_101(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = None
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_102(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            None,
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_103(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=None,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_104(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=None,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_105(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_106(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_107(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_108(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "XXsegmentAlignmentXX",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_109(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentalignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_110(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "SEGMENTALIGNMENT",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_111(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "Segmentalignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_112(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=True,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_113(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = None
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_114(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            None,
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_115(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=None,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_116(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=None,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_117(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_118(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_119(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_120(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "XXsubsegmentAlignmentXX",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_121(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentalignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_122(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "SUBSEGMENTALIGNMENT",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_123(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "Subsegmentalignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_124(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=True,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_125(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = None
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_126(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            None,
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_127(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=None,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_128(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=None,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_129(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_130(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_131(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_132(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "XXsubsegmentStartsWithSAPXX",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_133(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentstartswithsap",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_134(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "SUBSEGMENTSTARTSWITHSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_135(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "Subsegmentstartswithsap",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_136(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=1,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_137(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = None

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_138(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            None,
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_139(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=None,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_140(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_141(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_142(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "XXbitstreamSwitchingXX",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_143(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamswitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_144(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "BITSTREAMSWITCHING",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_145(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "Bitstreamswitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_146(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = None
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_147(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(None)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_148(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = None
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_149(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(None, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_150(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=None)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_151(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_152(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, )
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_153(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = None
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_154(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(None, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_155(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=None)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_156(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_157(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, )
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_158(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = None
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_159(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(None, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_160(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=None)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_161(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_162(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, )
        self.representations = self.children(Representation, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_163(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = None

    def xǁAdaptationSetǁ__init____mutmut_164(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(None, minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_165(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=None, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_166(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, period=None)

    def xǁAdaptationSetǁ__init____mutmut_167(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(minimum=1, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_168(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, period=self.parent)

    def xǁAdaptationSetǁ__init____mutmut_169(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=1, )

    def xǁAdaptationSetǁ__init____mutmut_170(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.id = self.attr("id")
        self.group = self.attr("group")
        self.lang = self.attr("lang")
        self.contentType = self.attr("contentType")
        self.par = self.attr("par")
        self.minBandwidth = self.attr("minBandwidth", parser=int)
        self.maxBandwidth = self.attr("maxBandwidth", parser=int)
        self.minWidth = self.attr("minWidth", parser=int)
        self.maxWidth = self.attr("maxWidth", parser=int)
        self.minHeight = self.attr("minHeight", parser=int)
        self.maxHeight = self.attr("maxHeight", parser=int)
        self.minFrameRate = self.attr("minFrameRate", parser=MPDParsers.frame_rate)
        self.maxFrameRate = self.attr("maxFrameRate", parser=MPDParsers.frame_rate)
        self.segmentAlignment = self.attr(
            "segmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentAlignment = self.attr(
            "subsegmentAlignment",
            parser=MPDParsers.bool_str,
            default=False,
        )
        self.subsegmentStartsWithSAP = self.attr(
            "subsegmentStartsWithSAP",
            parser=int,
            default=0,
        )
        self.bitstreamSwitching = self.attr(
            "bitstreamSwitching",
            parser=MPDParsers.bool_str,
        )

        self.baseURLs = self.children(BaseURL)
        self.segmentBase = self.only_child(SegmentBase, period=self.parent)
        self.segmentList = self.only_child(SegmentList, period=self.parent)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.parent)
        self.representations = self.children(Representation, minimum=2, period=self.parent)
    
    xǁAdaptationSetǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁAdaptationSetǁ__init____mutmut_1': xǁAdaptationSetǁ__init____mutmut_1, 
        'xǁAdaptationSetǁ__init____mutmut_2': xǁAdaptationSetǁ__init____mutmut_2, 
        'xǁAdaptationSetǁ__init____mutmut_3': xǁAdaptationSetǁ__init____mutmut_3, 
        'xǁAdaptationSetǁ__init____mutmut_4': xǁAdaptationSetǁ__init____mutmut_4, 
        'xǁAdaptationSetǁ__init____mutmut_5': xǁAdaptationSetǁ__init____mutmut_5, 
        'xǁAdaptationSetǁ__init____mutmut_6': xǁAdaptationSetǁ__init____mutmut_6, 
        'xǁAdaptationSetǁ__init____mutmut_7': xǁAdaptationSetǁ__init____mutmut_7, 
        'xǁAdaptationSetǁ__init____mutmut_8': xǁAdaptationSetǁ__init____mutmut_8, 
        'xǁAdaptationSetǁ__init____mutmut_9': xǁAdaptationSetǁ__init____mutmut_9, 
        'xǁAdaptationSetǁ__init____mutmut_10': xǁAdaptationSetǁ__init____mutmut_10, 
        'xǁAdaptationSetǁ__init____mutmut_11': xǁAdaptationSetǁ__init____mutmut_11, 
        'xǁAdaptationSetǁ__init____mutmut_12': xǁAdaptationSetǁ__init____mutmut_12, 
        'xǁAdaptationSetǁ__init____mutmut_13': xǁAdaptationSetǁ__init____mutmut_13, 
        'xǁAdaptationSetǁ__init____mutmut_14': xǁAdaptationSetǁ__init____mutmut_14, 
        'xǁAdaptationSetǁ__init____mutmut_15': xǁAdaptationSetǁ__init____mutmut_15, 
        'xǁAdaptationSetǁ__init____mutmut_16': xǁAdaptationSetǁ__init____mutmut_16, 
        'xǁAdaptationSetǁ__init____mutmut_17': xǁAdaptationSetǁ__init____mutmut_17, 
        'xǁAdaptationSetǁ__init____mutmut_18': xǁAdaptationSetǁ__init____mutmut_18, 
        'xǁAdaptationSetǁ__init____mutmut_19': xǁAdaptationSetǁ__init____mutmut_19, 
        'xǁAdaptationSetǁ__init____mutmut_20': xǁAdaptationSetǁ__init____mutmut_20, 
        'xǁAdaptationSetǁ__init____mutmut_21': xǁAdaptationSetǁ__init____mutmut_21, 
        'xǁAdaptationSetǁ__init____mutmut_22': xǁAdaptationSetǁ__init____mutmut_22, 
        'xǁAdaptationSetǁ__init____mutmut_23': xǁAdaptationSetǁ__init____mutmut_23, 
        'xǁAdaptationSetǁ__init____mutmut_24': xǁAdaptationSetǁ__init____mutmut_24, 
        'xǁAdaptationSetǁ__init____mutmut_25': xǁAdaptationSetǁ__init____mutmut_25, 
        'xǁAdaptationSetǁ__init____mutmut_26': xǁAdaptationSetǁ__init____mutmut_26, 
        'xǁAdaptationSetǁ__init____mutmut_27': xǁAdaptationSetǁ__init____mutmut_27, 
        'xǁAdaptationSetǁ__init____mutmut_28': xǁAdaptationSetǁ__init____mutmut_28, 
        'xǁAdaptationSetǁ__init____mutmut_29': xǁAdaptationSetǁ__init____mutmut_29, 
        'xǁAdaptationSetǁ__init____mutmut_30': xǁAdaptationSetǁ__init____mutmut_30, 
        'xǁAdaptationSetǁ__init____mutmut_31': xǁAdaptationSetǁ__init____mutmut_31, 
        'xǁAdaptationSetǁ__init____mutmut_32': xǁAdaptationSetǁ__init____mutmut_32, 
        'xǁAdaptationSetǁ__init____mutmut_33': xǁAdaptationSetǁ__init____mutmut_33, 
        'xǁAdaptationSetǁ__init____mutmut_34': xǁAdaptationSetǁ__init____mutmut_34, 
        'xǁAdaptationSetǁ__init____mutmut_35': xǁAdaptationSetǁ__init____mutmut_35, 
        'xǁAdaptationSetǁ__init____mutmut_36': xǁAdaptationSetǁ__init____mutmut_36, 
        'xǁAdaptationSetǁ__init____mutmut_37': xǁAdaptationSetǁ__init____mutmut_37, 
        'xǁAdaptationSetǁ__init____mutmut_38': xǁAdaptationSetǁ__init____mutmut_38, 
        'xǁAdaptationSetǁ__init____mutmut_39': xǁAdaptationSetǁ__init____mutmut_39, 
        'xǁAdaptationSetǁ__init____mutmut_40': xǁAdaptationSetǁ__init____mutmut_40, 
        'xǁAdaptationSetǁ__init____mutmut_41': xǁAdaptationSetǁ__init____mutmut_41, 
        'xǁAdaptationSetǁ__init____mutmut_42': xǁAdaptationSetǁ__init____mutmut_42, 
        'xǁAdaptationSetǁ__init____mutmut_43': xǁAdaptationSetǁ__init____mutmut_43, 
        'xǁAdaptationSetǁ__init____mutmut_44': xǁAdaptationSetǁ__init____mutmut_44, 
        'xǁAdaptationSetǁ__init____mutmut_45': xǁAdaptationSetǁ__init____mutmut_45, 
        'xǁAdaptationSetǁ__init____mutmut_46': xǁAdaptationSetǁ__init____mutmut_46, 
        'xǁAdaptationSetǁ__init____mutmut_47': xǁAdaptationSetǁ__init____mutmut_47, 
        'xǁAdaptationSetǁ__init____mutmut_48': xǁAdaptationSetǁ__init____mutmut_48, 
        'xǁAdaptationSetǁ__init____mutmut_49': xǁAdaptationSetǁ__init____mutmut_49, 
        'xǁAdaptationSetǁ__init____mutmut_50': xǁAdaptationSetǁ__init____mutmut_50, 
        'xǁAdaptationSetǁ__init____mutmut_51': xǁAdaptationSetǁ__init____mutmut_51, 
        'xǁAdaptationSetǁ__init____mutmut_52': xǁAdaptationSetǁ__init____mutmut_52, 
        'xǁAdaptationSetǁ__init____mutmut_53': xǁAdaptationSetǁ__init____mutmut_53, 
        'xǁAdaptationSetǁ__init____mutmut_54': xǁAdaptationSetǁ__init____mutmut_54, 
        'xǁAdaptationSetǁ__init____mutmut_55': xǁAdaptationSetǁ__init____mutmut_55, 
        'xǁAdaptationSetǁ__init____mutmut_56': xǁAdaptationSetǁ__init____mutmut_56, 
        'xǁAdaptationSetǁ__init____mutmut_57': xǁAdaptationSetǁ__init____mutmut_57, 
        'xǁAdaptationSetǁ__init____mutmut_58': xǁAdaptationSetǁ__init____mutmut_58, 
        'xǁAdaptationSetǁ__init____mutmut_59': xǁAdaptationSetǁ__init____mutmut_59, 
        'xǁAdaptationSetǁ__init____mutmut_60': xǁAdaptationSetǁ__init____mutmut_60, 
        'xǁAdaptationSetǁ__init____mutmut_61': xǁAdaptationSetǁ__init____mutmut_61, 
        'xǁAdaptationSetǁ__init____mutmut_62': xǁAdaptationSetǁ__init____mutmut_62, 
        'xǁAdaptationSetǁ__init____mutmut_63': xǁAdaptationSetǁ__init____mutmut_63, 
        'xǁAdaptationSetǁ__init____mutmut_64': xǁAdaptationSetǁ__init____mutmut_64, 
        'xǁAdaptationSetǁ__init____mutmut_65': xǁAdaptationSetǁ__init____mutmut_65, 
        'xǁAdaptationSetǁ__init____mutmut_66': xǁAdaptationSetǁ__init____mutmut_66, 
        'xǁAdaptationSetǁ__init____mutmut_67': xǁAdaptationSetǁ__init____mutmut_67, 
        'xǁAdaptationSetǁ__init____mutmut_68': xǁAdaptationSetǁ__init____mutmut_68, 
        'xǁAdaptationSetǁ__init____mutmut_69': xǁAdaptationSetǁ__init____mutmut_69, 
        'xǁAdaptationSetǁ__init____mutmut_70': xǁAdaptationSetǁ__init____mutmut_70, 
        'xǁAdaptationSetǁ__init____mutmut_71': xǁAdaptationSetǁ__init____mutmut_71, 
        'xǁAdaptationSetǁ__init____mutmut_72': xǁAdaptationSetǁ__init____mutmut_72, 
        'xǁAdaptationSetǁ__init____mutmut_73': xǁAdaptationSetǁ__init____mutmut_73, 
        'xǁAdaptationSetǁ__init____mutmut_74': xǁAdaptationSetǁ__init____mutmut_74, 
        'xǁAdaptationSetǁ__init____mutmut_75': xǁAdaptationSetǁ__init____mutmut_75, 
        'xǁAdaptationSetǁ__init____mutmut_76': xǁAdaptationSetǁ__init____mutmut_76, 
        'xǁAdaptationSetǁ__init____mutmut_77': xǁAdaptationSetǁ__init____mutmut_77, 
        'xǁAdaptationSetǁ__init____mutmut_78': xǁAdaptationSetǁ__init____mutmut_78, 
        'xǁAdaptationSetǁ__init____mutmut_79': xǁAdaptationSetǁ__init____mutmut_79, 
        'xǁAdaptationSetǁ__init____mutmut_80': xǁAdaptationSetǁ__init____mutmut_80, 
        'xǁAdaptationSetǁ__init____mutmut_81': xǁAdaptationSetǁ__init____mutmut_81, 
        'xǁAdaptationSetǁ__init____mutmut_82': xǁAdaptationSetǁ__init____mutmut_82, 
        'xǁAdaptationSetǁ__init____mutmut_83': xǁAdaptationSetǁ__init____mutmut_83, 
        'xǁAdaptationSetǁ__init____mutmut_84': xǁAdaptationSetǁ__init____mutmut_84, 
        'xǁAdaptationSetǁ__init____mutmut_85': xǁAdaptationSetǁ__init____mutmut_85, 
        'xǁAdaptationSetǁ__init____mutmut_86': xǁAdaptationSetǁ__init____mutmut_86, 
        'xǁAdaptationSetǁ__init____mutmut_87': xǁAdaptationSetǁ__init____mutmut_87, 
        'xǁAdaptationSetǁ__init____mutmut_88': xǁAdaptationSetǁ__init____mutmut_88, 
        'xǁAdaptationSetǁ__init____mutmut_89': xǁAdaptationSetǁ__init____mutmut_89, 
        'xǁAdaptationSetǁ__init____mutmut_90': xǁAdaptationSetǁ__init____mutmut_90, 
        'xǁAdaptationSetǁ__init____mutmut_91': xǁAdaptationSetǁ__init____mutmut_91, 
        'xǁAdaptationSetǁ__init____mutmut_92': xǁAdaptationSetǁ__init____mutmut_92, 
        'xǁAdaptationSetǁ__init____mutmut_93': xǁAdaptationSetǁ__init____mutmut_93, 
        'xǁAdaptationSetǁ__init____mutmut_94': xǁAdaptationSetǁ__init____mutmut_94, 
        'xǁAdaptationSetǁ__init____mutmut_95': xǁAdaptationSetǁ__init____mutmut_95, 
        'xǁAdaptationSetǁ__init____mutmut_96': xǁAdaptationSetǁ__init____mutmut_96, 
        'xǁAdaptationSetǁ__init____mutmut_97': xǁAdaptationSetǁ__init____mutmut_97, 
        'xǁAdaptationSetǁ__init____mutmut_98': xǁAdaptationSetǁ__init____mutmut_98, 
        'xǁAdaptationSetǁ__init____mutmut_99': xǁAdaptationSetǁ__init____mutmut_99, 
        'xǁAdaptationSetǁ__init____mutmut_100': xǁAdaptationSetǁ__init____mutmut_100, 
        'xǁAdaptationSetǁ__init____mutmut_101': xǁAdaptationSetǁ__init____mutmut_101, 
        'xǁAdaptationSetǁ__init____mutmut_102': xǁAdaptationSetǁ__init____mutmut_102, 
        'xǁAdaptationSetǁ__init____mutmut_103': xǁAdaptationSetǁ__init____mutmut_103, 
        'xǁAdaptationSetǁ__init____mutmut_104': xǁAdaptationSetǁ__init____mutmut_104, 
        'xǁAdaptationSetǁ__init____mutmut_105': xǁAdaptationSetǁ__init____mutmut_105, 
        'xǁAdaptationSetǁ__init____mutmut_106': xǁAdaptationSetǁ__init____mutmut_106, 
        'xǁAdaptationSetǁ__init____mutmut_107': xǁAdaptationSetǁ__init____mutmut_107, 
        'xǁAdaptationSetǁ__init____mutmut_108': xǁAdaptationSetǁ__init____mutmut_108, 
        'xǁAdaptationSetǁ__init____mutmut_109': xǁAdaptationSetǁ__init____mutmut_109, 
        'xǁAdaptationSetǁ__init____mutmut_110': xǁAdaptationSetǁ__init____mutmut_110, 
        'xǁAdaptationSetǁ__init____mutmut_111': xǁAdaptationSetǁ__init____mutmut_111, 
        'xǁAdaptationSetǁ__init____mutmut_112': xǁAdaptationSetǁ__init____mutmut_112, 
        'xǁAdaptationSetǁ__init____mutmut_113': xǁAdaptationSetǁ__init____mutmut_113, 
        'xǁAdaptationSetǁ__init____mutmut_114': xǁAdaptationSetǁ__init____mutmut_114, 
        'xǁAdaptationSetǁ__init____mutmut_115': xǁAdaptationSetǁ__init____mutmut_115, 
        'xǁAdaptationSetǁ__init____mutmut_116': xǁAdaptationSetǁ__init____mutmut_116, 
        'xǁAdaptationSetǁ__init____mutmut_117': xǁAdaptationSetǁ__init____mutmut_117, 
        'xǁAdaptationSetǁ__init____mutmut_118': xǁAdaptationSetǁ__init____mutmut_118, 
        'xǁAdaptationSetǁ__init____mutmut_119': xǁAdaptationSetǁ__init____mutmut_119, 
        'xǁAdaptationSetǁ__init____mutmut_120': xǁAdaptationSetǁ__init____mutmut_120, 
        'xǁAdaptationSetǁ__init____mutmut_121': xǁAdaptationSetǁ__init____mutmut_121, 
        'xǁAdaptationSetǁ__init____mutmut_122': xǁAdaptationSetǁ__init____mutmut_122, 
        'xǁAdaptationSetǁ__init____mutmut_123': xǁAdaptationSetǁ__init____mutmut_123, 
        'xǁAdaptationSetǁ__init____mutmut_124': xǁAdaptationSetǁ__init____mutmut_124, 
        'xǁAdaptationSetǁ__init____mutmut_125': xǁAdaptationSetǁ__init____mutmut_125, 
        'xǁAdaptationSetǁ__init____mutmut_126': xǁAdaptationSetǁ__init____mutmut_126, 
        'xǁAdaptationSetǁ__init____mutmut_127': xǁAdaptationSetǁ__init____mutmut_127, 
        'xǁAdaptationSetǁ__init____mutmut_128': xǁAdaptationSetǁ__init____mutmut_128, 
        'xǁAdaptationSetǁ__init____mutmut_129': xǁAdaptationSetǁ__init____mutmut_129, 
        'xǁAdaptationSetǁ__init____mutmut_130': xǁAdaptationSetǁ__init____mutmut_130, 
        'xǁAdaptationSetǁ__init____mutmut_131': xǁAdaptationSetǁ__init____mutmut_131, 
        'xǁAdaptationSetǁ__init____mutmut_132': xǁAdaptationSetǁ__init____mutmut_132, 
        'xǁAdaptationSetǁ__init____mutmut_133': xǁAdaptationSetǁ__init____mutmut_133, 
        'xǁAdaptationSetǁ__init____mutmut_134': xǁAdaptationSetǁ__init____mutmut_134, 
        'xǁAdaptationSetǁ__init____mutmut_135': xǁAdaptationSetǁ__init____mutmut_135, 
        'xǁAdaptationSetǁ__init____mutmut_136': xǁAdaptationSetǁ__init____mutmut_136, 
        'xǁAdaptationSetǁ__init____mutmut_137': xǁAdaptationSetǁ__init____mutmut_137, 
        'xǁAdaptationSetǁ__init____mutmut_138': xǁAdaptationSetǁ__init____mutmut_138, 
        'xǁAdaptationSetǁ__init____mutmut_139': xǁAdaptationSetǁ__init____mutmut_139, 
        'xǁAdaptationSetǁ__init____mutmut_140': xǁAdaptationSetǁ__init____mutmut_140, 
        'xǁAdaptationSetǁ__init____mutmut_141': xǁAdaptationSetǁ__init____mutmut_141, 
        'xǁAdaptationSetǁ__init____mutmut_142': xǁAdaptationSetǁ__init____mutmut_142, 
        'xǁAdaptationSetǁ__init____mutmut_143': xǁAdaptationSetǁ__init____mutmut_143, 
        'xǁAdaptationSetǁ__init____mutmut_144': xǁAdaptationSetǁ__init____mutmut_144, 
        'xǁAdaptationSetǁ__init____mutmut_145': xǁAdaptationSetǁ__init____mutmut_145, 
        'xǁAdaptationSetǁ__init____mutmut_146': xǁAdaptationSetǁ__init____mutmut_146, 
        'xǁAdaptationSetǁ__init____mutmut_147': xǁAdaptationSetǁ__init____mutmut_147, 
        'xǁAdaptationSetǁ__init____mutmut_148': xǁAdaptationSetǁ__init____mutmut_148, 
        'xǁAdaptationSetǁ__init____mutmut_149': xǁAdaptationSetǁ__init____mutmut_149, 
        'xǁAdaptationSetǁ__init____mutmut_150': xǁAdaptationSetǁ__init____mutmut_150, 
        'xǁAdaptationSetǁ__init____mutmut_151': xǁAdaptationSetǁ__init____mutmut_151, 
        'xǁAdaptationSetǁ__init____mutmut_152': xǁAdaptationSetǁ__init____mutmut_152, 
        'xǁAdaptationSetǁ__init____mutmut_153': xǁAdaptationSetǁ__init____mutmut_153, 
        'xǁAdaptationSetǁ__init____mutmut_154': xǁAdaptationSetǁ__init____mutmut_154, 
        'xǁAdaptationSetǁ__init____mutmut_155': xǁAdaptationSetǁ__init____mutmut_155, 
        'xǁAdaptationSetǁ__init____mutmut_156': xǁAdaptationSetǁ__init____mutmut_156, 
        'xǁAdaptationSetǁ__init____mutmut_157': xǁAdaptationSetǁ__init____mutmut_157, 
        'xǁAdaptationSetǁ__init____mutmut_158': xǁAdaptationSetǁ__init____mutmut_158, 
        'xǁAdaptationSetǁ__init____mutmut_159': xǁAdaptationSetǁ__init____mutmut_159, 
        'xǁAdaptationSetǁ__init____mutmut_160': xǁAdaptationSetǁ__init____mutmut_160, 
        'xǁAdaptationSetǁ__init____mutmut_161': xǁAdaptationSetǁ__init____mutmut_161, 
        'xǁAdaptationSetǁ__init____mutmut_162': xǁAdaptationSetǁ__init____mutmut_162, 
        'xǁAdaptationSetǁ__init____mutmut_163': xǁAdaptationSetǁ__init____mutmut_163, 
        'xǁAdaptationSetǁ__init____mutmut_164': xǁAdaptationSetǁ__init____mutmut_164, 
        'xǁAdaptationSetǁ__init____mutmut_165': xǁAdaptationSetǁ__init____mutmut_165, 
        'xǁAdaptationSetǁ__init____mutmut_166': xǁAdaptationSetǁ__init____mutmut_166, 
        'xǁAdaptationSetǁ__init____mutmut_167': xǁAdaptationSetǁ__init____mutmut_167, 
        'xǁAdaptationSetǁ__init____mutmut_168': xǁAdaptationSetǁ__init____mutmut_168, 
        'xǁAdaptationSetǁ__init____mutmut_169': xǁAdaptationSetǁ__init____mutmut_169, 
        'xǁAdaptationSetǁ__init____mutmut_170': xǁAdaptationSetǁ__init____mutmut_170
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁAdaptationSetǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁAdaptationSetǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁAdaptationSetǁ__init____mutmut_orig)
    xǁAdaptationSetǁ__init____mutmut_orig.__name__ = 'xǁAdaptationSetǁ__init__'


class Representation(_RepresentationBaseType):
    __tag__ = "Representation"

    parent: AdaptationSet

    def xǁRepresentationǁ__init____mutmut_orig(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_1(self, *args, period: Period, **kwargs) -> None:
        super().__init__(**kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_2(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, )

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_3(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = None

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_4(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = None
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_5(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            None,
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_6(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=None,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_7(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_8(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_9(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "XXidXX",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_10(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "ID",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_11(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "Id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_12(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=False,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_13(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = None

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_14(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            None,
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_15(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=None,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_16(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=None,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_17(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_18(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_19(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_20(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "XXbandwidthXX",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_21(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "BANDWIDTH",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_22(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "Bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_23(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: None,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_24(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(None) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_25(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) * 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_26(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1001.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_27(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=False,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_28(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = None

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_29(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = None
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_30(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(None)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_31(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = None
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_32(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(None)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_33(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = None
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_34(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(None, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_35(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=None)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_36(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_37(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, )
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_38(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = None
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_39(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(None, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_40(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=None)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_41(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_42(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, )
        self.segmentTemplate = self.only_child(SegmentTemplate, period=self.period)

    def xǁRepresentationǁ__init____mutmut_43(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = None

    def xǁRepresentationǁ__init____mutmut_44(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(None, period=self.period)

    def xǁRepresentationǁ__init____mutmut_45(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, period=None)

    def xǁRepresentationǁ__init____mutmut_46(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(period=self.period)

    def xǁRepresentationǁ__init____mutmut_47(self, *args, period: Period, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.id: str = self.attr(  # type: ignore[assignment]
            "id",
            required=True,
        )
        self.bandwidth: float = self.attr(  # type: ignore[assignment]
            "bandwidth",
            parser=lambda b: float(b) / 1000.0,
            required=True,
        )

        self.ident = self.parent.parent.id, self.parent.id, self.id

        self.baseURLs = self.children(BaseURL)
        self.subRepresentations = self.children(SubRepresentation)
        self.segmentBase = self.only_child(SegmentBase, period=self.period)
        self.segmentList = self.only_child(SegmentList, period=self.period)
        self.segmentTemplate = self.only_child(SegmentTemplate, )
    
    xǁRepresentationǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁRepresentationǁ__init____mutmut_1': xǁRepresentationǁ__init____mutmut_1, 
        'xǁRepresentationǁ__init____mutmut_2': xǁRepresentationǁ__init____mutmut_2, 
        'xǁRepresentationǁ__init____mutmut_3': xǁRepresentationǁ__init____mutmut_3, 
        'xǁRepresentationǁ__init____mutmut_4': xǁRepresentationǁ__init____mutmut_4, 
        'xǁRepresentationǁ__init____mutmut_5': xǁRepresentationǁ__init____mutmut_5, 
        'xǁRepresentationǁ__init____mutmut_6': xǁRepresentationǁ__init____mutmut_6, 
        'xǁRepresentationǁ__init____mutmut_7': xǁRepresentationǁ__init____mutmut_7, 
        'xǁRepresentationǁ__init____mutmut_8': xǁRepresentationǁ__init____mutmut_8, 
        'xǁRepresentationǁ__init____mutmut_9': xǁRepresentationǁ__init____mutmut_9, 
        'xǁRepresentationǁ__init____mutmut_10': xǁRepresentationǁ__init____mutmut_10, 
        'xǁRepresentationǁ__init____mutmut_11': xǁRepresentationǁ__init____mutmut_11, 
        'xǁRepresentationǁ__init____mutmut_12': xǁRepresentationǁ__init____mutmut_12, 
        'xǁRepresentationǁ__init____mutmut_13': xǁRepresentationǁ__init____mutmut_13, 
        'xǁRepresentationǁ__init____mutmut_14': xǁRepresentationǁ__init____mutmut_14, 
        'xǁRepresentationǁ__init____mutmut_15': xǁRepresentationǁ__init____mutmut_15, 
        'xǁRepresentationǁ__init____mutmut_16': xǁRepresentationǁ__init____mutmut_16, 
        'xǁRepresentationǁ__init____mutmut_17': xǁRepresentationǁ__init____mutmut_17, 
        'xǁRepresentationǁ__init____mutmut_18': xǁRepresentationǁ__init____mutmut_18, 
        'xǁRepresentationǁ__init____mutmut_19': xǁRepresentationǁ__init____mutmut_19, 
        'xǁRepresentationǁ__init____mutmut_20': xǁRepresentationǁ__init____mutmut_20, 
        'xǁRepresentationǁ__init____mutmut_21': xǁRepresentationǁ__init____mutmut_21, 
        'xǁRepresentationǁ__init____mutmut_22': xǁRepresentationǁ__init____mutmut_22, 
        'xǁRepresentationǁ__init____mutmut_23': xǁRepresentationǁ__init____mutmut_23, 
        'xǁRepresentationǁ__init____mutmut_24': xǁRepresentationǁ__init____mutmut_24, 
        'xǁRepresentationǁ__init____mutmut_25': xǁRepresentationǁ__init____mutmut_25, 
        'xǁRepresentationǁ__init____mutmut_26': xǁRepresentationǁ__init____mutmut_26, 
        'xǁRepresentationǁ__init____mutmut_27': xǁRepresentationǁ__init____mutmut_27, 
        'xǁRepresentationǁ__init____mutmut_28': xǁRepresentationǁ__init____mutmut_28, 
        'xǁRepresentationǁ__init____mutmut_29': xǁRepresentationǁ__init____mutmut_29, 
        'xǁRepresentationǁ__init____mutmut_30': xǁRepresentationǁ__init____mutmut_30, 
        'xǁRepresentationǁ__init____mutmut_31': xǁRepresentationǁ__init____mutmut_31, 
        'xǁRepresentationǁ__init____mutmut_32': xǁRepresentationǁ__init____mutmut_32, 
        'xǁRepresentationǁ__init____mutmut_33': xǁRepresentationǁ__init____mutmut_33, 
        'xǁRepresentationǁ__init____mutmut_34': xǁRepresentationǁ__init____mutmut_34, 
        'xǁRepresentationǁ__init____mutmut_35': xǁRepresentationǁ__init____mutmut_35, 
        'xǁRepresentationǁ__init____mutmut_36': xǁRepresentationǁ__init____mutmut_36, 
        'xǁRepresentationǁ__init____mutmut_37': xǁRepresentationǁ__init____mutmut_37, 
        'xǁRepresentationǁ__init____mutmut_38': xǁRepresentationǁ__init____mutmut_38, 
        'xǁRepresentationǁ__init____mutmut_39': xǁRepresentationǁ__init____mutmut_39, 
        'xǁRepresentationǁ__init____mutmut_40': xǁRepresentationǁ__init____mutmut_40, 
        'xǁRepresentationǁ__init____mutmut_41': xǁRepresentationǁ__init____mutmut_41, 
        'xǁRepresentationǁ__init____mutmut_42': xǁRepresentationǁ__init____mutmut_42, 
        'xǁRepresentationǁ__init____mutmut_43': xǁRepresentationǁ__init____mutmut_43, 
        'xǁRepresentationǁ__init____mutmut_44': xǁRepresentationǁ__init____mutmut_44, 
        'xǁRepresentationǁ__init____mutmut_45': xǁRepresentationǁ__init____mutmut_45, 
        'xǁRepresentationǁ__init____mutmut_46': xǁRepresentationǁ__init____mutmut_46, 
        'xǁRepresentationǁ__init____mutmut_47': xǁRepresentationǁ__init____mutmut_47
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁRepresentationǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁRepresentationǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁRepresentationǁ__init____mutmut_orig)
    xǁRepresentationǁ__init____mutmut_orig.__name__ = 'xǁRepresentationǁ__init__'

    @property
    def lang(self):
        return self.parent.lang

    @property
    def bandwidth_rounded(self) -> float:
        return round(self.bandwidth, 1 - int(math.log10(self.bandwidth)))

    def xǁRepresentationǁsegments__mutmut_orig(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_1(
        self,
        init: bool = False,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_2(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = None
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_3(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList and self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_4(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr(None)
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_5(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("XXsegmentListXX")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_6(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentlist")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_7(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("SEGMENTLIST")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_8(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("Segmentlist")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_9(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = None

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_10(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate and self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_11(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr(None)

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_12(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("XXsegmentTemplateXX")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_13(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmenttemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_14(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("SEGMENTTEMPLATE")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_15(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("Segmenttemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_16(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                None,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_17(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                None,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_18(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=None,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_19(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=None,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_20(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=None,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_21(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=None,
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_22(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_23(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_24(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_25(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_26(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_27(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_28(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_29(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(None),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_30(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth / 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_31(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1001),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_32(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                None,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_33(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=None,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_34(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_35(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_36(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_37(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=None,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_38(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=None,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_39(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=None,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_40(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=None,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_41(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=None,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_42(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=None,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_43(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_44(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_45(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_46(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_47(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_48(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_49(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                )

    def xǁRepresentationǁsegments__mutmut_50(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=+1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_51(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-2,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_52(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() and self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_53(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁRepresentationǁsegments__mutmut_54(
        self,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        """
        Segments are yielded when they are available

        Segments appear on a timeline, for dynamic content they are only available at a certain time
        and sometimes for a limited time. For static content they are all available at the same time.

        :param init: Yield the init segment and perform other initialization logic for dynamic manifests
        :param timestamp: Optional initial timestamp for syncing timelines of multiple substreams
        :param kwargs: extra args to pass to the segment template/list
        :return: yields Segments
        """

        # segmentBase = self.segmentBase or self.walk_back_get_attr("segmentBase")
        segmentList = self.segmentList or self.walk_back_get_attr("segmentList")
        segmentTemplate = self.segmentTemplate or self.walk_back_get_attr("segmentTemplate")

        if segmentTemplate:
            yield from segmentTemplate.segments(
                self.ident,
                self.base_url,
                init=init,
                timestamp=timestamp,
                RepresentationID=self.id,
                Bandwidth=int(self.bandwidth * 1000),
                **kwargs,
            )
        elif segmentList:
            yield from segmentList.segments(
                self.ident,
                init=init,
                **kwargs,
            )
        else:
            yield DASHSegment(
                uri=self.base_url,
                num=-1,
                duration=self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds(),
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=None,
            )
    
    xǁRepresentationǁsegments__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁRepresentationǁsegments__mutmut_1': xǁRepresentationǁsegments__mutmut_1, 
        'xǁRepresentationǁsegments__mutmut_2': xǁRepresentationǁsegments__mutmut_2, 
        'xǁRepresentationǁsegments__mutmut_3': xǁRepresentationǁsegments__mutmut_3, 
        'xǁRepresentationǁsegments__mutmut_4': xǁRepresentationǁsegments__mutmut_4, 
        'xǁRepresentationǁsegments__mutmut_5': xǁRepresentationǁsegments__mutmut_5, 
        'xǁRepresentationǁsegments__mutmut_6': xǁRepresentationǁsegments__mutmut_6, 
        'xǁRepresentationǁsegments__mutmut_7': xǁRepresentationǁsegments__mutmut_7, 
        'xǁRepresentationǁsegments__mutmut_8': xǁRepresentationǁsegments__mutmut_8, 
        'xǁRepresentationǁsegments__mutmut_9': xǁRepresentationǁsegments__mutmut_9, 
        'xǁRepresentationǁsegments__mutmut_10': xǁRepresentationǁsegments__mutmut_10, 
        'xǁRepresentationǁsegments__mutmut_11': xǁRepresentationǁsegments__mutmut_11, 
        'xǁRepresentationǁsegments__mutmut_12': xǁRepresentationǁsegments__mutmut_12, 
        'xǁRepresentationǁsegments__mutmut_13': xǁRepresentationǁsegments__mutmut_13, 
        'xǁRepresentationǁsegments__mutmut_14': xǁRepresentationǁsegments__mutmut_14, 
        'xǁRepresentationǁsegments__mutmut_15': xǁRepresentationǁsegments__mutmut_15, 
        'xǁRepresentationǁsegments__mutmut_16': xǁRepresentationǁsegments__mutmut_16, 
        'xǁRepresentationǁsegments__mutmut_17': xǁRepresentationǁsegments__mutmut_17, 
        'xǁRepresentationǁsegments__mutmut_18': xǁRepresentationǁsegments__mutmut_18, 
        'xǁRepresentationǁsegments__mutmut_19': xǁRepresentationǁsegments__mutmut_19, 
        'xǁRepresentationǁsegments__mutmut_20': xǁRepresentationǁsegments__mutmut_20, 
        'xǁRepresentationǁsegments__mutmut_21': xǁRepresentationǁsegments__mutmut_21, 
        'xǁRepresentationǁsegments__mutmut_22': xǁRepresentationǁsegments__mutmut_22, 
        'xǁRepresentationǁsegments__mutmut_23': xǁRepresentationǁsegments__mutmut_23, 
        'xǁRepresentationǁsegments__mutmut_24': xǁRepresentationǁsegments__mutmut_24, 
        'xǁRepresentationǁsegments__mutmut_25': xǁRepresentationǁsegments__mutmut_25, 
        'xǁRepresentationǁsegments__mutmut_26': xǁRepresentationǁsegments__mutmut_26, 
        'xǁRepresentationǁsegments__mutmut_27': xǁRepresentationǁsegments__mutmut_27, 
        'xǁRepresentationǁsegments__mutmut_28': xǁRepresentationǁsegments__mutmut_28, 
        'xǁRepresentationǁsegments__mutmut_29': xǁRepresentationǁsegments__mutmut_29, 
        'xǁRepresentationǁsegments__mutmut_30': xǁRepresentationǁsegments__mutmut_30, 
        'xǁRepresentationǁsegments__mutmut_31': xǁRepresentationǁsegments__mutmut_31, 
        'xǁRepresentationǁsegments__mutmut_32': xǁRepresentationǁsegments__mutmut_32, 
        'xǁRepresentationǁsegments__mutmut_33': xǁRepresentationǁsegments__mutmut_33, 
        'xǁRepresentationǁsegments__mutmut_34': xǁRepresentationǁsegments__mutmut_34, 
        'xǁRepresentationǁsegments__mutmut_35': xǁRepresentationǁsegments__mutmut_35, 
        'xǁRepresentationǁsegments__mutmut_36': xǁRepresentationǁsegments__mutmut_36, 
        'xǁRepresentationǁsegments__mutmut_37': xǁRepresentationǁsegments__mutmut_37, 
        'xǁRepresentationǁsegments__mutmut_38': xǁRepresentationǁsegments__mutmut_38, 
        'xǁRepresentationǁsegments__mutmut_39': xǁRepresentationǁsegments__mutmut_39, 
        'xǁRepresentationǁsegments__mutmut_40': xǁRepresentationǁsegments__mutmut_40, 
        'xǁRepresentationǁsegments__mutmut_41': xǁRepresentationǁsegments__mutmut_41, 
        'xǁRepresentationǁsegments__mutmut_42': xǁRepresentationǁsegments__mutmut_42, 
        'xǁRepresentationǁsegments__mutmut_43': xǁRepresentationǁsegments__mutmut_43, 
        'xǁRepresentationǁsegments__mutmut_44': xǁRepresentationǁsegments__mutmut_44, 
        'xǁRepresentationǁsegments__mutmut_45': xǁRepresentationǁsegments__mutmut_45, 
        'xǁRepresentationǁsegments__mutmut_46': xǁRepresentationǁsegments__mutmut_46, 
        'xǁRepresentationǁsegments__mutmut_47': xǁRepresentationǁsegments__mutmut_47, 
        'xǁRepresentationǁsegments__mutmut_48': xǁRepresentationǁsegments__mutmut_48, 
        'xǁRepresentationǁsegments__mutmut_49': xǁRepresentationǁsegments__mutmut_49, 
        'xǁRepresentationǁsegments__mutmut_50': xǁRepresentationǁsegments__mutmut_50, 
        'xǁRepresentationǁsegments__mutmut_51': xǁRepresentationǁsegments__mutmut_51, 
        'xǁRepresentationǁsegments__mutmut_52': xǁRepresentationǁsegments__mutmut_52, 
        'xǁRepresentationǁsegments__mutmut_53': xǁRepresentationǁsegments__mutmut_53, 
        'xǁRepresentationǁsegments__mutmut_54': xǁRepresentationǁsegments__mutmut_54
    }
    
    def segments(self, *args, **kwargs):
        result = yield from _mutmut_yield_from_trampoline(object.__getattribute__(self, "xǁRepresentationǁsegments__mutmut_orig"), object.__getattribute__(self, "xǁRepresentationǁsegments__mutmut_mutants"), args, kwargs, self)
        return result 
    
    segments.__signature__ = _mutmut_signature(xǁRepresentationǁsegments__mutmut_orig)
    xǁRepresentationǁsegments__mutmut_orig.__name__ = 'xǁRepresentationǁsegments'


class SubRepresentation(_RepresentationBaseType):
    __tag__ = "SubRepresentation"


class _SegmentBaseType(MPDNode):
    parent: Period | AdaptationSet | Representation

    _ancestors = (Period, AdaptationSet, Representation)

    def xǁ_SegmentBaseTypeǁ__init____mutmut_orig(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_1(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(**kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_2(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, )

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_3(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = None

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_4(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = None
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_5(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            None,
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_6(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=None,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_7(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=None,
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_8(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_9(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_10(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_11(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "XXtimescaleXX",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_12(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "TIMESCALE",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_13(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "Timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_14(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default(None, 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_15(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", None),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_16(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default(1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_17(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", ),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_18(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("XXtimescaleXX", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_19(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("TIMESCALE", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_20(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("Timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_21(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 2),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_22(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = None
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_23(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            None,
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_24(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=None,
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_25(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=None,
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_26(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_27(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_28(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_29(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "XXpresentationTimeOffsetXX",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_30(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationtimeoffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_31(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "PRESENTATIONTIMEOFFSET",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_32(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "Presentationtimeoffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_33(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(None),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_34(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default(None, timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_35(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", None),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_36(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default(timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_37(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", ),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_38(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("XXpresentationTimeOffsetXX", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_39(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationtimeoffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_40(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("PRESENTATIONTIMEOFFSET", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_41(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("Presentationtimeoffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_42(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = None

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_43(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            None,
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_44(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=None,
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_45(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=None,
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_46(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_47(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_48(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_49(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "XXavailabilityTimeOffsetXX",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_50(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilitytimeoffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_51(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "AVAILABILITYTIMEOFFSET",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_52(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "Availabilitytimeoffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_53(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(None),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_54(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default(None, timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_55(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", None),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_56(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default(timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_57(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", ),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_58(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("XXavailabilityTimeOffsetXX", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_59(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilitytimeoffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_60(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("AVAILABILITYTIMEOFFSET", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_61(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("Availabilitytimeoffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_62(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = None

    def xǁ_SegmentBaseTypeǁ__init____mutmut_63(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(None) or self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_64(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) and self._find_default("initialization")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_65(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default(None)

    def xǁ_SegmentBaseTypeǁ__init____mutmut_66(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("XXinitializationXX")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_67(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("INITIALIZATION")

    def xǁ_SegmentBaseTypeǁ__init____mutmut_68(self, *args, period: "Period", **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.period = period

        self.timescale: int = self.attr(
            "timescale",
            parser=int,
            default=self._find_default("timescale", 1),
        )
        self.presentationTimeOffset: timedelta = self.attr(
            "presentationTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("presentationTimeOffset", timedelta()),
        )
        self.availabilityTimeOffset: timedelta = self.attr(
            "availabilityTimeOffset",
            parser=MPDParsers.timedelta(self.timescale),
            default=self._find_default("availabilityTimeOffset", timedelta()),
        )

        self.initialization = self.only_child(Initialization) or self._find_default("Initialization")
    
    xǁ_SegmentBaseTypeǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_SegmentBaseTypeǁ__init____mutmut_1': xǁ_SegmentBaseTypeǁ__init____mutmut_1, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_2': xǁ_SegmentBaseTypeǁ__init____mutmut_2, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_3': xǁ_SegmentBaseTypeǁ__init____mutmut_3, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_4': xǁ_SegmentBaseTypeǁ__init____mutmut_4, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_5': xǁ_SegmentBaseTypeǁ__init____mutmut_5, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_6': xǁ_SegmentBaseTypeǁ__init____mutmut_6, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_7': xǁ_SegmentBaseTypeǁ__init____mutmut_7, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_8': xǁ_SegmentBaseTypeǁ__init____mutmut_8, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_9': xǁ_SegmentBaseTypeǁ__init____mutmut_9, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_10': xǁ_SegmentBaseTypeǁ__init____mutmut_10, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_11': xǁ_SegmentBaseTypeǁ__init____mutmut_11, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_12': xǁ_SegmentBaseTypeǁ__init____mutmut_12, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_13': xǁ_SegmentBaseTypeǁ__init____mutmut_13, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_14': xǁ_SegmentBaseTypeǁ__init____mutmut_14, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_15': xǁ_SegmentBaseTypeǁ__init____mutmut_15, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_16': xǁ_SegmentBaseTypeǁ__init____mutmut_16, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_17': xǁ_SegmentBaseTypeǁ__init____mutmut_17, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_18': xǁ_SegmentBaseTypeǁ__init____mutmut_18, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_19': xǁ_SegmentBaseTypeǁ__init____mutmut_19, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_20': xǁ_SegmentBaseTypeǁ__init____mutmut_20, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_21': xǁ_SegmentBaseTypeǁ__init____mutmut_21, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_22': xǁ_SegmentBaseTypeǁ__init____mutmut_22, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_23': xǁ_SegmentBaseTypeǁ__init____mutmut_23, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_24': xǁ_SegmentBaseTypeǁ__init____mutmut_24, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_25': xǁ_SegmentBaseTypeǁ__init____mutmut_25, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_26': xǁ_SegmentBaseTypeǁ__init____mutmut_26, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_27': xǁ_SegmentBaseTypeǁ__init____mutmut_27, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_28': xǁ_SegmentBaseTypeǁ__init____mutmut_28, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_29': xǁ_SegmentBaseTypeǁ__init____mutmut_29, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_30': xǁ_SegmentBaseTypeǁ__init____mutmut_30, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_31': xǁ_SegmentBaseTypeǁ__init____mutmut_31, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_32': xǁ_SegmentBaseTypeǁ__init____mutmut_32, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_33': xǁ_SegmentBaseTypeǁ__init____mutmut_33, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_34': xǁ_SegmentBaseTypeǁ__init____mutmut_34, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_35': xǁ_SegmentBaseTypeǁ__init____mutmut_35, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_36': xǁ_SegmentBaseTypeǁ__init____mutmut_36, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_37': xǁ_SegmentBaseTypeǁ__init____mutmut_37, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_38': xǁ_SegmentBaseTypeǁ__init____mutmut_38, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_39': xǁ_SegmentBaseTypeǁ__init____mutmut_39, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_40': xǁ_SegmentBaseTypeǁ__init____mutmut_40, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_41': xǁ_SegmentBaseTypeǁ__init____mutmut_41, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_42': xǁ_SegmentBaseTypeǁ__init____mutmut_42, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_43': xǁ_SegmentBaseTypeǁ__init____mutmut_43, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_44': xǁ_SegmentBaseTypeǁ__init____mutmut_44, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_45': xǁ_SegmentBaseTypeǁ__init____mutmut_45, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_46': xǁ_SegmentBaseTypeǁ__init____mutmut_46, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_47': xǁ_SegmentBaseTypeǁ__init____mutmut_47, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_48': xǁ_SegmentBaseTypeǁ__init____mutmut_48, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_49': xǁ_SegmentBaseTypeǁ__init____mutmut_49, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_50': xǁ_SegmentBaseTypeǁ__init____mutmut_50, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_51': xǁ_SegmentBaseTypeǁ__init____mutmut_51, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_52': xǁ_SegmentBaseTypeǁ__init____mutmut_52, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_53': xǁ_SegmentBaseTypeǁ__init____mutmut_53, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_54': xǁ_SegmentBaseTypeǁ__init____mutmut_54, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_55': xǁ_SegmentBaseTypeǁ__init____mutmut_55, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_56': xǁ_SegmentBaseTypeǁ__init____mutmut_56, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_57': xǁ_SegmentBaseTypeǁ__init____mutmut_57, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_58': xǁ_SegmentBaseTypeǁ__init____mutmut_58, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_59': xǁ_SegmentBaseTypeǁ__init____mutmut_59, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_60': xǁ_SegmentBaseTypeǁ__init____mutmut_60, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_61': xǁ_SegmentBaseTypeǁ__init____mutmut_61, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_62': xǁ_SegmentBaseTypeǁ__init____mutmut_62, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_63': xǁ_SegmentBaseTypeǁ__init____mutmut_63, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_64': xǁ_SegmentBaseTypeǁ__init____mutmut_64, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_65': xǁ_SegmentBaseTypeǁ__init____mutmut_65, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_66': xǁ_SegmentBaseTypeǁ__init____mutmut_66, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_67': xǁ_SegmentBaseTypeǁ__init____mutmut_67, 
        'xǁ_SegmentBaseTypeǁ__init____mutmut_68': xǁ_SegmentBaseTypeǁ__init____mutmut_68
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_SegmentBaseTypeǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁ_SegmentBaseTypeǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁ_SegmentBaseTypeǁ__init____mutmut_orig)
    xǁ_SegmentBaseTypeǁ__init____mutmut_orig.__name__ = 'xǁ_SegmentBaseTypeǁ__init__'

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_orig(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            self._ancestors,
            lambda node: getattr(node, nodeattr, None),
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_1(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = None
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            self._ancestors,
            lambda node: getattr(node, nodeattr, None),
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_2(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].upper()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            self._ancestors,
            lambda node: getattr(node, nodeattr, None),
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_3(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[1].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            self._ancestors,
            lambda node: getattr(node, nodeattr, None),
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_4(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[2:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            self._ancestors,
            lambda node: getattr(node, nodeattr, None),
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_5(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = None
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_6(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            None,
            self._ancestors,
            lambda node: getattr(node, nodeattr, None),
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_7(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            None,
            lambda node: getattr(node, nodeattr, None),
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_8(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            self._ancestors,
            None,
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_9(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            self._ancestors,
            lambda node: getattr(node, nodeattr, None),
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_10(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            lambda node: getattr(node, nodeattr, None),
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_11(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            self._ancestors,
            )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_12(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            self._ancestors,
            lambda node: None,
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_13(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            self._ancestors,
            lambda node: getattr(None, nodeattr, None),
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_14(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            self._ancestors,
            lambda node: getattr(node, None, None),
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_15(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            self._ancestors,
            lambda node: getattr(nodeattr, None),
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_16(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            self._ancestors,
            lambda node: getattr(node, None),
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_17(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            self._ancestors,
            lambda node: getattr(node, nodeattr, ),
        )
        return default if value is None else value

    def xǁ_SegmentBaseTypeǁ_find_default__mutmut_18(self, attr: str, default: TAttrDefault = None) -> TAttrDefault | Any:
        """Find default values from nodes of the same type on ancestor nodes"""
        # the node attribute on each ancestor is named after its node tag, with the first character being lowercase
        nodeattr = f"{self.__tag__[0].lower()}{self.__tag__[1:]}"
        # start with the parent node, to avoid an unnecessary failed lookup on the current node
        value = self.parent.walk_back_get_attr(
            attr,
            self._ancestors,
            lambda node: getattr(node, nodeattr, None),
        )
        return default if value is not None else value
    
    xǁ_SegmentBaseTypeǁ_find_default__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_SegmentBaseTypeǁ_find_default__mutmut_1': xǁ_SegmentBaseTypeǁ_find_default__mutmut_1, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_2': xǁ_SegmentBaseTypeǁ_find_default__mutmut_2, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_3': xǁ_SegmentBaseTypeǁ_find_default__mutmut_3, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_4': xǁ_SegmentBaseTypeǁ_find_default__mutmut_4, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_5': xǁ_SegmentBaseTypeǁ_find_default__mutmut_5, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_6': xǁ_SegmentBaseTypeǁ_find_default__mutmut_6, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_7': xǁ_SegmentBaseTypeǁ_find_default__mutmut_7, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_8': xǁ_SegmentBaseTypeǁ_find_default__mutmut_8, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_9': xǁ_SegmentBaseTypeǁ_find_default__mutmut_9, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_10': xǁ_SegmentBaseTypeǁ_find_default__mutmut_10, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_11': xǁ_SegmentBaseTypeǁ_find_default__mutmut_11, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_12': xǁ_SegmentBaseTypeǁ_find_default__mutmut_12, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_13': xǁ_SegmentBaseTypeǁ_find_default__mutmut_13, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_14': xǁ_SegmentBaseTypeǁ_find_default__mutmut_14, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_15': xǁ_SegmentBaseTypeǁ_find_default__mutmut_15, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_16': xǁ_SegmentBaseTypeǁ_find_default__mutmut_16, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_17': xǁ_SegmentBaseTypeǁ_find_default__mutmut_17, 
        'xǁ_SegmentBaseTypeǁ_find_default__mutmut_18': xǁ_SegmentBaseTypeǁ_find_default__mutmut_18
    }
    
    def _find_default(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_SegmentBaseTypeǁ_find_default__mutmut_orig"), object.__getattribute__(self, "xǁ_SegmentBaseTypeǁ_find_default__mutmut_mutants"), args, kwargs, self)
        return result 
    
    _find_default.__signature__ = _mutmut_signature(xǁ_SegmentBaseTypeǁ_find_default__mutmut_orig)
    xǁ_SegmentBaseTypeǁ_find_default__mutmut_orig.__name__ = 'xǁ_SegmentBaseTypeǁ_find_default'


class _MultipleSegmentBaseType(_SegmentBaseType):
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_orig(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_1(self, *args, **kwargs) -> None:
        super().__init__(**kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_2(self, *args, **kwargs) -> None:
        super().__init__(*args, )

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_3(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = None
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_4(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            None,
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_5(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=None,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_6(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=None,
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_7(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_8(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_9(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_10(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "XXdurationXX",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_11(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "DURATION",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_12(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "Duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_13(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default(None),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_14(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("XXdurationXX"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_15(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("DURATION"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_16(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("Duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_17(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = None

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_18(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            None,
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_19(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=None,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_20(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=None,
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_21(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_22(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_23(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_24(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "XXstartNumberXX",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_25(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startnumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_26(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "STARTNUMBER",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_27(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "Startnumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_28(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default(None, 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_29(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", None),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_30(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default(1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_31(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", ),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_32(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("XXstartNumberXX", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_33(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startnumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_34(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("STARTNUMBER", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_35(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("Startnumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_36(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 2),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_37(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = None

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_38(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration * self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_39(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 1.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_40(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = None
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_41(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(None) or self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_42(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) and self._find_default("segmentTimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_43(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default(None)
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_44(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("XXsegmentTimelineXX")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_45(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("segmenttimeline")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_46(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("SEGMENTTIMELINE")
    def xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_47(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.duration = self.attr(
            "duration",
            parser=int,
            default=self._find_default("duration"),
        )
        self.startNumber: int = self.attr(
            "startNumber",
            parser=int,
            default=self._find_default("startNumber", 1),
        )

        self.duration_seconds = self.duration / self.timescale if self.duration else 0.0

        self.segmentTimeline = self.only_child(SegmentTimeline) or self._find_default("Segmenttimeline")
    
    xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_1': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_1, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_2': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_2, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_3': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_3, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_4': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_4, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_5': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_5, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_6': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_6, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_7': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_7, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_8': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_8, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_9': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_9, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_10': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_10, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_11': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_11, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_12': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_12, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_13': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_13, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_14': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_14, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_15': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_15, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_16': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_16, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_17': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_17, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_18': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_18, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_19': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_19, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_20': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_20, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_21': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_21, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_22': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_22, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_23': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_23, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_24': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_24, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_25': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_25, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_26': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_26, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_27': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_27, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_28': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_28, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_29': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_29, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_30': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_30, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_31': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_31, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_32': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_32, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_33': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_33, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_34': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_34, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_35': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_35, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_36': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_36, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_37': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_37, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_38': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_38, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_39': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_39, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_40': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_40, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_41': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_41, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_42': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_42, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_43': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_43, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_44': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_44, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_45': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_45, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_46': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_46, 
        'xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_47': xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_47
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_orig)
    xǁ_MultipleSegmentBaseTypeǁ__init____mutmut_orig.__name__ = 'xǁ_MultipleSegmentBaseTypeǁ__init__'


class SegmentBase(_SegmentBaseType):
    __tag__ = "SegmentBase"


class SegmentList(_MultipleSegmentBaseType):
    __tag__ = "SegmentList"

    def xǁSegmentListǁ__init____mutmut_orig(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.segmentURLs = self.children(SegmentURL)

    def xǁSegmentListǁ__init____mutmut_1(self, *args, **kwargs) -> None:
        super().__init__(**kwargs)

        self.segmentURLs = self.children(SegmentURL)

    def xǁSegmentListǁ__init____mutmut_2(self, *args, **kwargs) -> None:
        super().__init__(*args, )

        self.segmentURLs = self.children(SegmentURL)

    def xǁSegmentListǁ__init____mutmut_3(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.segmentURLs = None

    def xǁSegmentListǁ__init____mutmut_4(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.segmentURLs = self.children(None)
    
    xǁSegmentListǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁSegmentListǁ__init____mutmut_1': xǁSegmentListǁ__init____mutmut_1, 
        'xǁSegmentListǁ__init____mutmut_2': xǁSegmentListǁ__init____mutmut_2, 
        'xǁSegmentListǁ__init____mutmut_3': xǁSegmentListǁ__init____mutmut_3, 
        'xǁSegmentListǁ__init____mutmut_4': xǁSegmentListǁ__init____mutmut_4
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁSegmentListǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁSegmentListǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁSegmentListǁ__init____mutmut_orig)
    xǁSegmentListǁ__init____mutmut_orig.__name__ = 'xǁSegmentListǁ__init__'

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_orig(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_1(
        self,
        ident: TTimelineIdent,
        init: bool = False,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_2(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init or self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_3(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=None,
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_4(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=None,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_5(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=None,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_6(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=None,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_7(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=None,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_8(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=None,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_9(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=None,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_10(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_11(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_12(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_13(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_14(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_15(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_16(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_17(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(None),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_18(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=+1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_19(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-2,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_20(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=1.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_21(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_22(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_23(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(None, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_24(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, None):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_25(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_26(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, ):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_27(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=None,
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_28(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=None,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_29(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=None,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_30(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=None,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_31(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=None,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_32(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=None,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_33(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=None,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_34(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_35(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_36(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_37(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_38(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_39(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_40(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_41(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(None),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_42(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=True,
                byterange=segment_url.media_range,
            )

    # noinspection PyUnusedLocal
    def xǁSegmentListǁsegments__mutmut_43(
        self,
        ident: TTimelineIdent,
        init: bool = True,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init and self.initialization:  # pragma: no branch
            yield DASHSegment(
                uri=self.make_url(self.initialization.source_url),
                num=-1,
                duration=0.0,
                available_at=self.period.availabilityStartTime,
                init=True,
                content=False,
                byterange=self.initialization.range,
            )
        for num, segment_url in self.segment_urls(ident, init):
            yield DASHSegment(
                uri=self.make_url(segment_url.media),
                num=num,
                duration=self.duration_seconds,
                available_at=self.period.availabilityStartTime,
                init=False,
                content=False,
                byterange=segment_url.media_range,
            )
    
    xǁSegmentListǁsegments__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁSegmentListǁsegments__mutmut_1': xǁSegmentListǁsegments__mutmut_1, 
        'xǁSegmentListǁsegments__mutmut_2': xǁSegmentListǁsegments__mutmut_2, 
        'xǁSegmentListǁsegments__mutmut_3': xǁSegmentListǁsegments__mutmut_3, 
        'xǁSegmentListǁsegments__mutmut_4': xǁSegmentListǁsegments__mutmut_4, 
        'xǁSegmentListǁsegments__mutmut_5': xǁSegmentListǁsegments__mutmut_5, 
        'xǁSegmentListǁsegments__mutmut_6': xǁSegmentListǁsegments__mutmut_6, 
        'xǁSegmentListǁsegments__mutmut_7': xǁSegmentListǁsegments__mutmut_7, 
        'xǁSegmentListǁsegments__mutmut_8': xǁSegmentListǁsegments__mutmut_8, 
        'xǁSegmentListǁsegments__mutmut_9': xǁSegmentListǁsegments__mutmut_9, 
        'xǁSegmentListǁsegments__mutmut_10': xǁSegmentListǁsegments__mutmut_10, 
        'xǁSegmentListǁsegments__mutmut_11': xǁSegmentListǁsegments__mutmut_11, 
        'xǁSegmentListǁsegments__mutmut_12': xǁSegmentListǁsegments__mutmut_12, 
        'xǁSegmentListǁsegments__mutmut_13': xǁSegmentListǁsegments__mutmut_13, 
        'xǁSegmentListǁsegments__mutmut_14': xǁSegmentListǁsegments__mutmut_14, 
        'xǁSegmentListǁsegments__mutmut_15': xǁSegmentListǁsegments__mutmut_15, 
        'xǁSegmentListǁsegments__mutmut_16': xǁSegmentListǁsegments__mutmut_16, 
        'xǁSegmentListǁsegments__mutmut_17': xǁSegmentListǁsegments__mutmut_17, 
        'xǁSegmentListǁsegments__mutmut_18': xǁSegmentListǁsegments__mutmut_18, 
        'xǁSegmentListǁsegments__mutmut_19': xǁSegmentListǁsegments__mutmut_19, 
        'xǁSegmentListǁsegments__mutmut_20': xǁSegmentListǁsegments__mutmut_20, 
        'xǁSegmentListǁsegments__mutmut_21': xǁSegmentListǁsegments__mutmut_21, 
        'xǁSegmentListǁsegments__mutmut_22': xǁSegmentListǁsegments__mutmut_22, 
        'xǁSegmentListǁsegments__mutmut_23': xǁSegmentListǁsegments__mutmut_23, 
        'xǁSegmentListǁsegments__mutmut_24': xǁSegmentListǁsegments__mutmut_24, 
        'xǁSegmentListǁsegments__mutmut_25': xǁSegmentListǁsegments__mutmut_25, 
        'xǁSegmentListǁsegments__mutmut_26': xǁSegmentListǁsegments__mutmut_26, 
        'xǁSegmentListǁsegments__mutmut_27': xǁSegmentListǁsegments__mutmut_27, 
        'xǁSegmentListǁsegments__mutmut_28': xǁSegmentListǁsegments__mutmut_28, 
        'xǁSegmentListǁsegments__mutmut_29': xǁSegmentListǁsegments__mutmut_29, 
        'xǁSegmentListǁsegments__mutmut_30': xǁSegmentListǁsegments__mutmut_30, 
        'xǁSegmentListǁsegments__mutmut_31': xǁSegmentListǁsegments__mutmut_31, 
        'xǁSegmentListǁsegments__mutmut_32': xǁSegmentListǁsegments__mutmut_32, 
        'xǁSegmentListǁsegments__mutmut_33': xǁSegmentListǁsegments__mutmut_33, 
        'xǁSegmentListǁsegments__mutmut_34': xǁSegmentListǁsegments__mutmut_34, 
        'xǁSegmentListǁsegments__mutmut_35': xǁSegmentListǁsegments__mutmut_35, 
        'xǁSegmentListǁsegments__mutmut_36': xǁSegmentListǁsegments__mutmut_36, 
        'xǁSegmentListǁsegments__mutmut_37': xǁSegmentListǁsegments__mutmut_37, 
        'xǁSegmentListǁsegments__mutmut_38': xǁSegmentListǁsegments__mutmut_38, 
        'xǁSegmentListǁsegments__mutmut_39': xǁSegmentListǁsegments__mutmut_39, 
        'xǁSegmentListǁsegments__mutmut_40': xǁSegmentListǁsegments__mutmut_40, 
        'xǁSegmentListǁsegments__mutmut_41': xǁSegmentListǁsegments__mutmut_41, 
        'xǁSegmentListǁsegments__mutmut_42': xǁSegmentListǁsegments__mutmut_42, 
        'xǁSegmentListǁsegments__mutmut_43': xǁSegmentListǁsegments__mutmut_43
    }
    
    def segments(self, *args, **kwargs):
        result = yield from _mutmut_yield_from_trampoline(object.__getattribute__(self, "xǁSegmentListǁsegments__mutmut_orig"), object.__getattribute__(self, "xǁSegmentListǁsegments__mutmut_mutants"), args, kwargs, self)
        return result 
    
    segments.__signature__ = _mutmut_signature(xǁSegmentListǁsegments__mutmut_orig)
    xǁSegmentListǁsegments__mutmut_orig.__name__ = 'xǁSegmentListǁsegments'

    def xǁSegmentListǁsegment_urls__mutmut_orig(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_1(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type != "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_2(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "XXstaticXX":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_3(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "STATIC":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_4(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "Static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_5(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = None
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_6(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = None
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_7(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = None
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_8(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = None

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_9(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number + self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_10(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = None
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_11(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = None

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_12(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number + self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_13(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset > 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_14(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 1:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_15(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = None
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_16(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    None,
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_17(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber + 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_18(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 2} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_19(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset <= -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_20(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < +1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_21(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -2
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_22(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    ) - "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_23(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "XXThis is unsupported and will result in incoherent output data.XX",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_24(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "this is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_25(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "THIS IS UNSUPPORTED AND WILL RESULT IN INCOHERENT OUTPUT DATA.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_26(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = None
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_27(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = None

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_28(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = None

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_29(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number - len(segment_urls)

        yield from enumerate(segment_urls, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_30(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(None, start_number)

    def xǁSegmentListǁsegment_urls__mutmut_31(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, None)

    def xǁSegmentListǁsegment_urls__mutmut_32(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(start_number)

    def xǁSegmentListǁsegment_urls__mutmut_33(self, ident: TTimelineIdent, init: bool) -> Iterator[tuple[int, SegmentURL]]:
        if init:
            if self.root.type == "static":
                # yield all segments in a static manifest
                start_number = self.startNumber
                segment_urls = self.segmentURLs
            else:
                # yield a specific number of segments from the live-edge of dynamic manifests
                start_number = self.calculate_optimal_start()
                segment_urls = self.segmentURLs[start_number - self.startNumber :]

        else:
            # skip segments with a lower number than the remembered segment number
            # and check if we've skipped any segments after reloading the manifest
            start_number = self.root.timelines[ident]
            offset = start_number - self.startNumber

            if offset >= 0:
                # no segments were skipped: yield a slice of the segments
                segment_urls = self.segmentURLs[offset:]
            else:
                # segments were skipped: yield all segments and set the correct segment number
                log.warning(
                    (
                        f"Skipped segments {start_number}-{self.startNumber - 1} after manifest reload. "
                        if offset < -1
                        else f"Skipped segment {start_number} after manifest reload. "
                    )
                    + "This is unsupported and will result in incoherent output data.",
                )
                start_number = self.startNumber
                segment_urls = self.segmentURLs

        # remember the next segment number
        self.root.timelines[ident] = start_number + len(segment_urls)

        yield from enumerate(segment_urls, )
    
    xǁSegmentListǁsegment_urls__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁSegmentListǁsegment_urls__mutmut_1': xǁSegmentListǁsegment_urls__mutmut_1, 
        'xǁSegmentListǁsegment_urls__mutmut_2': xǁSegmentListǁsegment_urls__mutmut_2, 
        'xǁSegmentListǁsegment_urls__mutmut_3': xǁSegmentListǁsegment_urls__mutmut_3, 
        'xǁSegmentListǁsegment_urls__mutmut_4': xǁSegmentListǁsegment_urls__mutmut_4, 
        'xǁSegmentListǁsegment_urls__mutmut_5': xǁSegmentListǁsegment_urls__mutmut_5, 
        'xǁSegmentListǁsegment_urls__mutmut_6': xǁSegmentListǁsegment_urls__mutmut_6, 
        'xǁSegmentListǁsegment_urls__mutmut_7': xǁSegmentListǁsegment_urls__mutmut_7, 
        'xǁSegmentListǁsegment_urls__mutmut_8': xǁSegmentListǁsegment_urls__mutmut_8, 
        'xǁSegmentListǁsegment_urls__mutmut_9': xǁSegmentListǁsegment_urls__mutmut_9, 
        'xǁSegmentListǁsegment_urls__mutmut_10': xǁSegmentListǁsegment_urls__mutmut_10, 
        'xǁSegmentListǁsegment_urls__mutmut_11': xǁSegmentListǁsegment_urls__mutmut_11, 
        'xǁSegmentListǁsegment_urls__mutmut_12': xǁSegmentListǁsegment_urls__mutmut_12, 
        'xǁSegmentListǁsegment_urls__mutmut_13': xǁSegmentListǁsegment_urls__mutmut_13, 
        'xǁSegmentListǁsegment_urls__mutmut_14': xǁSegmentListǁsegment_urls__mutmut_14, 
        'xǁSegmentListǁsegment_urls__mutmut_15': xǁSegmentListǁsegment_urls__mutmut_15, 
        'xǁSegmentListǁsegment_urls__mutmut_16': xǁSegmentListǁsegment_urls__mutmut_16, 
        'xǁSegmentListǁsegment_urls__mutmut_17': xǁSegmentListǁsegment_urls__mutmut_17, 
        'xǁSegmentListǁsegment_urls__mutmut_18': xǁSegmentListǁsegment_urls__mutmut_18, 
        'xǁSegmentListǁsegment_urls__mutmut_19': xǁSegmentListǁsegment_urls__mutmut_19, 
        'xǁSegmentListǁsegment_urls__mutmut_20': xǁSegmentListǁsegment_urls__mutmut_20, 
        'xǁSegmentListǁsegment_urls__mutmut_21': xǁSegmentListǁsegment_urls__mutmut_21, 
        'xǁSegmentListǁsegment_urls__mutmut_22': xǁSegmentListǁsegment_urls__mutmut_22, 
        'xǁSegmentListǁsegment_urls__mutmut_23': xǁSegmentListǁsegment_urls__mutmut_23, 
        'xǁSegmentListǁsegment_urls__mutmut_24': xǁSegmentListǁsegment_urls__mutmut_24, 
        'xǁSegmentListǁsegment_urls__mutmut_25': xǁSegmentListǁsegment_urls__mutmut_25, 
        'xǁSegmentListǁsegment_urls__mutmut_26': xǁSegmentListǁsegment_urls__mutmut_26, 
        'xǁSegmentListǁsegment_urls__mutmut_27': xǁSegmentListǁsegment_urls__mutmut_27, 
        'xǁSegmentListǁsegment_urls__mutmut_28': xǁSegmentListǁsegment_urls__mutmut_28, 
        'xǁSegmentListǁsegment_urls__mutmut_29': xǁSegmentListǁsegment_urls__mutmut_29, 
        'xǁSegmentListǁsegment_urls__mutmut_30': xǁSegmentListǁsegment_urls__mutmut_30, 
        'xǁSegmentListǁsegment_urls__mutmut_31': xǁSegmentListǁsegment_urls__mutmut_31, 
        'xǁSegmentListǁsegment_urls__mutmut_32': xǁSegmentListǁsegment_urls__mutmut_32, 
        'xǁSegmentListǁsegment_urls__mutmut_33': xǁSegmentListǁsegment_urls__mutmut_33
    }
    
    def segment_urls(self, *args, **kwargs):
        result = yield from _mutmut_yield_from_trampoline(object.__getattribute__(self, "xǁSegmentListǁsegment_urls__mutmut_orig"), object.__getattribute__(self, "xǁSegmentListǁsegment_urls__mutmut_mutants"), args, kwargs, self)
        return result 
    
    segment_urls.__signature__ = _mutmut_signature(xǁSegmentListǁsegment_urls__mutmut_orig)
    xǁSegmentListǁsegment_urls__mutmut_orig.__name__ = 'xǁSegmentListǁsegment_urls'

    def xǁSegmentListǁcalculate_optimal_start__mutmut_orig(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(0, math.ceil(suggested_delay.total_seconds() / self.duration_seconds))

        start = self.startNumber + len(self.segmentURLs) - offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_1(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = None

        if self.duration_seconds == 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(0, math.ceil(suggested_delay.total_seconds() / self.duration_seconds))

        start = self.startNumber + len(self.segmentURLs) - offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_2(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds != 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(0, math.ceil(suggested_delay.total_seconds() / self.duration_seconds))

        start = self.startNumber + len(self.segmentURLs) - offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_3(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 1.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(0, math.ceil(suggested_delay.total_seconds() / self.duration_seconds))

        start = self.startNumber + len(self.segmentURLs) - offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_4(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 0.0:
            log.info(None)
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(0, math.ceil(suggested_delay.total_seconds() / self.duration_seconds))

        start = self.startNumber + len(self.segmentURLs) - offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_5(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = None
        else:
            offset = max(0, math.ceil(suggested_delay.total_seconds() / self.duration_seconds))

        start = self.startNumber + len(self.segmentURLs) - offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_6(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = None

        start = self.startNumber + len(self.segmentURLs) - offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_7(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(None, math.ceil(suggested_delay.total_seconds() / self.duration_seconds))

        start = self.startNumber + len(self.segmentURLs) - offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_8(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(0, None)

        start = self.startNumber + len(self.segmentURLs) - offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_9(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(math.ceil(suggested_delay.total_seconds() / self.duration_seconds))

        start = self.startNumber + len(self.segmentURLs) - offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_10(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(0, )

        start = self.startNumber + len(self.segmentURLs) - offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_11(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(1, math.ceil(suggested_delay.total_seconds() / self.duration_seconds))

        start = self.startNumber + len(self.segmentURLs) - offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_12(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(0, math.ceil(None))

        start = self.startNumber + len(self.segmentURLs) - offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_13(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(0, math.ceil(suggested_delay.total_seconds() * self.duration_seconds))

        start = self.startNumber + len(self.segmentURLs) - offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_14(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(0, math.ceil(suggested_delay.total_seconds() / self.duration_seconds))

        start = None
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_15(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(0, math.ceil(suggested_delay.total_seconds() / self.duration_seconds))

        start = self.startNumber - len(self.segmentURLs) - offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_16(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(0, math.ceil(suggested_delay.total_seconds() / self.duration_seconds))

        start = self.startNumber + len(self.segmentURLs) + offset
        log.debug(f"Calculated optimal offset is {offset} segments. First segment is {start}.")

        return start

    def xǁSegmentListǁcalculate_optimal_start__mutmut_17(self) -> int:
        """Calculate the optimal segment number to start based on the suggestedPresentationDelay"""
        suggested_delay = self.root.suggestedPresentationDelay

        if self.duration_seconds == 0.0:
            log.info(f"Unknown segment duration. Falling back to an offset of {MPD.DEFAULT_LIVE_EDGE_SEGMENTS} segments.")
            offset = MPD.DEFAULT_LIVE_EDGE_SEGMENTS
        else:
            offset = max(0, math.ceil(suggested_delay.total_seconds() / self.duration_seconds))

        start = self.startNumber + len(self.segmentURLs) - offset
        log.debug(None)

        return start
    
    xǁSegmentListǁcalculate_optimal_start__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁSegmentListǁcalculate_optimal_start__mutmut_1': xǁSegmentListǁcalculate_optimal_start__mutmut_1, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_2': xǁSegmentListǁcalculate_optimal_start__mutmut_2, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_3': xǁSegmentListǁcalculate_optimal_start__mutmut_3, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_4': xǁSegmentListǁcalculate_optimal_start__mutmut_4, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_5': xǁSegmentListǁcalculate_optimal_start__mutmut_5, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_6': xǁSegmentListǁcalculate_optimal_start__mutmut_6, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_7': xǁSegmentListǁcalculate_optimal_start__mutmut_7, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_8': xǁSegmentListǁcalculate_optimal_start__mutmut_8, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_9': xǁSegmentListǁcalculate_optimal_start__mutmut_9, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_10': xǁSegmentListǁcalculate_optimal_start__mutmut_10, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_11': xǁSegmentListǁcalculate_optimal_start__mutmut_11, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_12': xǁSegmentListǁcalculate_optimal_start__mutmut_12, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_13': xǁSegmentListǁcalculate_optimal_start__mutmut_13, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_14': xǁSegmentListǁcalculate_optimal_start__mutmut_14, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_15': xǁSegmentListǁcalculate_optimal_start__mutmut_15, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_16': xǁSegmentListǁcalculate_optimal_start__mutmut_16, 
        'xǁSegmentListǁcalculate_optimal_start__mutmut_17': xǁSegmentListǁcalculate_optimal_start__mutmut_17
    }
    
    def calculate_optimal_start(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁSegmentListǁcalculate_optimal_start__mutmut_orig"), object.__getattribute__(self, "xǁSegmentListǁcalculate_optimal_start__mutmut_mutants"), args, kwargs, self)
        return result 
    
    calculate_optimal_start.__signature__ = _mutmut_signature(xǁSegmentListǁcalculate_optimal_start__mutmut_orig)
    xǁSegmentListǁcalculate_optimal_start__mutmut_orig.__name__ = 'xǁSegmentListǁcalculate_optimal_start'

    def xǁSegmentListǁmake_url__mutmut_orig(self, url: str | None) -> str:
        return urljoin(self.base_url, url)

    def xǁSegmentListǁmake_url__mutmut_1(self, url: str | None) -> str:
        return urljoin(None, url)

    def xǁSegmentListǁmake_url__mutmut_2(self, url: str | None) -> str:
        return urljoin(self.base_url, None)

    def xǁSegmentListǁmake_url__mutmut_3(self, url: str | None) -> str:
        return urljoin(url)

    def xǁSegmentListǁmake_url__mutmut_4(self, url: str | None) -> str:
        return urljoin(self.base_url, )
    
    xǁSegmentListǁmake_url__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁSegmentListǁmake_url__mutmut_1': xǁSegmentListǁmake_url__mutmut_1, 
        'xǁSegmentListǁmake_url__mutmut_2': xǁSegmentListǁmake_url__mutmut_2, 
        'xǁSegmentListǁmake_url__mutmut_3': xǁSegmentListǁmake_url__mutmut_3, 
        'xǁSegmentListǁmake_url__mutmut_4': xǁSegmentListǁmake_url__mutmut_4
    }
    
    def make_url(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁSegmentListǁmake_url__mutmut_orig"), object.__getattribute__(self, "xǁSegmentListǁmake_url__mutmut_mutants"), args, kwargs, self)
        return result 
    
    make_url.__signature__ = _mutmut_signature(xǁSegmentListǁmake_url__mutmut_orig)
    xǁSegmentListǁmake_url__mutmut_orig.__name__ = 'xǁSegmentListǁmake_url'


class SegmentTemplate(_MultipleSegmentBaseType):
    __tag__ = "SegmentTemplate"

    def xǁSegmentTemplateǁ__init____mutmut_orig(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            "initialization",
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = self.attr(
            "media",
            parser=MPDParsers.segment_template,
        )

    def xǁSegmentTemplateǁ__init____mutmut_1(self, *args, **kwargs) -> None:
        super().__init__(**kwargs)

        self.fmt_initialization = self.attr(
            "initialization",
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = self.attr(
            "media",
            parser=MPDParsers.segment_template,
        )

    def xǁSegmentTemplateǁ__init____mutmut_2(self, *args, **kwargs) -> None:
        super().__init__(*args, )

        self.fmt_initialization = self.attr(
            "initialization",
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = self.attr(
            "media",
            parser=MPDParsers.segment_template,
        )

    def xǁSegmentTemplateǁ__init____mutmut_3(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = None
        self.fmt_media = self.attr(
            "media",
            parser=MPDParsers.segment_template,
        )

    def xǁSegmentTemplateǁ__init____mutmut_4(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            None,
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = self.attr(
            "media",
            parser=MPDParsers.segment_template,
        )

    def xǁSegmentTemplateǁ__init____mutmut_5(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            "initialization",
            parser=None,
        )
        self.fmt_media = self.attr(
            "media",
            parser=MPDParsers.segment_template,
        )

    def xǁSegmentTemplateǁ__init____mutmut_6(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = self.attr(
            "media",
            parser=MPDParsers.segment_template,
        )

    def xǁSegmentTemplateǁ__init____mutmut_7(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            "initialization",
            )
        self.fmt_media = self.attr(
            "media",
            parser=MPDParsers.segment_template,
        )

    def xǁSegmentTemplateǁ__init____mutmut_8(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            "XXinitializationXX",
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = self.attr(
            "media",
            parser=MPDParsers.segment_template,
        )

    def xǁSegmentTemplateǁ__init____mutmut_9(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            "INITIALIZATION",
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = self.attr(
            "media",
            parser=MPDParsers.segment_template,
        )

    def xǁSegmentTemplateǁ__init____mutmut_10(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            "Initialization",
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = self.attr(
            "media",
            parser=MPDParsers.segment_template,
        )

    def xǁSegmentTemplateǁ__init____mutmut_11(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            "initialization",
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = None

    def xǁSegmentTemplateǁ__init____mutmut_12(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            "initialization",
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = self.attr(
            None,
            parser=MPDParsers.segment_template,
        )

    def xǁSegmentTemplateǁ__init____mutmut_13(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            "initialization",
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = self.attr(
            "media",
            parser=None,
        )

    def xǁSegmentTemplateǁ__init____mutmut_14(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            "initialization",
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = self.attr(
            parser=MPDParsers.segment_template,
        )

    def xǁSegmentTemplateǁ__init____mutmut_15(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            "initialization",
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = self.attr(
            "media",
            )

    def xǁSegmentTemplateǁ__init____mutmut_16(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            "initialization",
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = self.attr(
            "XXmediaXX",
            parser=MPDParsers.segment_template,
        )

    def xǁSegmentTemplateǁ__init____mutmut_17(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            "initialization",
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = self.attr(
            "MEDIA",
            parser=MPDParsers.segment_template,
        )

    def xǁSegmentTemplateǁ__init____mutmut_18(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.fmt_initialization = self.attr(
            "initialization",
            parser=MPDParsers.segment_template,
        )
        self.fmt_media = self.attr(
            "Media",
            parser=MPDParsers.segment_template,
        )
    
    xǁSegmentTemplateǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁSegmentTemplateǁ__init____mutmut_1': xǁSegmentTemplateǁ__init____mutmut_1, 
        'xǁSegmentTemplateǁ__init____mutmut_2': xǁSegmentTemplateǁ__init____mutmut_2, 
        'xǁSegmentTemplateǁ__init____mutmut_3': xǁSegmentTemplateǁ__init____mutmut_3, 
        'xǁSegmentTemplateǁ__init____mutmut_4': xǁSegmentTemplateǁ__init____mutmut_4, 
        'xǁSegmentTemplateǁ__init____mutmut_5': xǁSegmentTemplateǁ__init____mutmut_5, 
        'xǁSegmentTemplateǁ__init____mutmut_6': xǁSegmentTemplateǁ__init____mutmut_6, 
        'xǁSegmentTemplateǁ__init____mutmut_7': xǁSegmentTemplateǁ__init____mutmut_7, 
        'xǁSegmentTemplateǁ__init____mutmut_8': xǁSegmentTemplateǁ__init____mutmut_8, 
        'xǁSegmentTemplateǁ__init____mutmut_9': xǁSegmentTemplateǁ__init____mutmut_9, 
        'xǁSegmentTemplateǁ__init____mutmut_10': xǁSegmentTemplateǁ__init____mutmut_10, 
        'xǁSegmentTemplateǁ__init____mutmut_11': xǁSegmentTemplateǁ__init____mutmut_11, 
        'xǁSegmentTemplateǁ__init____mutmut_12': xǁSegmentTemplateǁ__init____mutmut_12, 
        'xǁSegmentTemplateǁ__init____mutmut_13': xǁSegmentTemplateǁ__init____mutmut_13, 
        'xǁSegmentTemplateǁ__init____mutmut_14': xǁSegmentTemplateǁ__init____mutmut_14, 
        'xǁSegmentTemplateǁ__init____mutmut_15': xǁSegmentTemplateǁ__init____mutmut_15, 
        'xǁSegmentTemplateǁ__init____mutmut_16': xǁSegmentTemplateǁ__init____mutmut_16, 
        'xǁSegmentTemplateǁ__init____mutmut_17': xǁSegmentTemplateǁ__init____mutmut_17, 
        'xǁSegmentTemplateǁ__init____mutmut_18': xǁSegmentTemplateǁ__init____mutmut_18
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁSegmentTemplateǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁSegmentTemplateǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁSegmentTemplateǁ__init____mutmut_orig)
    xǁSegmentTemplateǁ__init____mutmut_orig.__name__ = 'xǁSegmentTemplateǁ__init__'

    def xǁSegmentTemplateǁsegments__mutmut_orig(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_1(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = False,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_2(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = None
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_3(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(None, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_4(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(**kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_5(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, )
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_6(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=None,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_7(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=None,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_8(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=None,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_9(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=None,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_10(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=None,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_11(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=None,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_12(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_13(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_14(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_15(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_16(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_17(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_18(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_19(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=+1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_20(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-2,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_21(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=1.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_22(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=False,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_23(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=True,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_24(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(None, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_25(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, None, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_26(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=None, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_27(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_28(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_29(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_30(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, ):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_31(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=None,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_32(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=None,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_33(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=None,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_34(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=None,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_35(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=None,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_36(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=None,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_37(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_38(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_39(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                available_at=available_at,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_40(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                init=False,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_41(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_42(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_43(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=True,
                )

    def xǁSegmentTemplateǁsegments__mutmut_44(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=True,
                content=True,
                byterange=None,
            )

    def xǁSegmentTemplateǁsegments__mutmut_45(
        self,
        ident: TTimelineIdent,
        base_url: str,
        init: bool = True,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[DASHSegment]:
        if init:
            init_url = self.format_initialization(base_url, **kwargs)
            if init_url:  # pragma: no branch
                yield DASHSegment(
                    uri=init_url,
                    num=-1,
                    duration=0.0,
                    available_at=self.period.availabilityStartTime,
                    init=True,
                    content=False,
                    byterange=None,
                )
        for media_url, num, duration, available_at in self.format_media(ident, base_url, timestamp=timestamp, **kwargs):
            yield DASHSegment(
                uri=media_url,
                num=num,
                duration=duration,
                available_at=available_at,
                init=False,
                content=False,
                byterange=None,
            )
    
    xǁSegmentTemplateǁsegments__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁSegmentTemplateǁsegments__mutmut_1': xǁSegmentTemplateǁsegments__mutmut_1, 
        'xǁSegmentTemplateǁsegments__mutmut_2': xǁSegmentTemplateǁsegments__mutmut_2, 
        'xǁSegmentTemplateǁsegments__mutmut_3': xǁSegmentTemplateǁsegments__mutmut_3, 
        'xǁSegmentTemplateǁsegments__mutmut_4': xǁSegmentTemplateǁsegments__mutmut_4, 
        'xǁSegmentTemplateǁsegments__mutmut_5': xǁSegmentTemplateǁsegments__mutmut_5, 
        'xǁSegmentTemplateǁsegments__mutmut_6': xǁSegmentTemplateǁsegments__mutmut_6, 
        'xǁSegmentTemplateǁsegments__mutmut_7': xǁSegmentTemplateǁsegments__mutmut_7, 
        'xǁSegmentTemplateǁsegments__mutmut_8': xǁSegmentTemplateǁsegments__mutmut_8, 
        'xǁSegmentTemplateǁsegments__mutmut_9': xǁSegmentTemplateǁsegments__mutmut_9, 
        'xǁSegmentTemplateǁsegments__mutmut_10': xǁSegmentTemplateǁsegments__mutmut_10, 
        'xǁSegmentTemplateǁsegments__mutmut_11': xǁSegmentTemplateǁsegments__mutmut_11, 
        'xǁSegmentTemplateǁsegments__mutmut_12': xǁSegmentTemplateǁsegments__mutmut_12, 
        'xǁSegmentTemplateǁsegments__mutmut_13': xǁSegmentTemplateǁsegments__mutmut_13, 
        'xǁSegmentTemplateǁsegments__mutmut_14': xǁSegmentTemplateǁsegments__mutmut_14, 
        'xǁSegmentTemplateǁsegments__mutmut_15': xǁSegmentTemplateǁsegments__mutmut_15, 
        'xǁSegmentTemplateǁsegments__mutmut_16': xǁSegmentTemplateǁsegments__mutmut_16, 
        'xǁSegmentTemplateǁsegments__mutmut_17': xǁSegmentTemplateǁsegments__mutmut_17, 
        'xǁSegmentTemplateǁsegments__mutmut_18': xǁSegmentTemplateǁsegments__mutmut_18, 
        'xǁSegmentTemplateǁsegments__mutmut_19': xǁSegmentTemplateǁsegments__mutmut_19, 
        'xǁSegmentTemplateǁsegments__mutmut_20': xǁSegmentTemplateǁsegments__mutmut_20, 
        'xǁSegmentTemplateǁsegments__mutmut_21': xǁSegmentTemplateǁsegments__mutmut_21, 
        'xǁSegmentTemplateǁsegments__mutmut_22': xǁSegmentTemplateǁsegments__mutmut_22, 
        'xǁSegmentTemplateǁsegments__mutmut_23': xǁSegmentTemplateǁsegments__mutmut_23, 
        'xǁSegmentTemplateǁsegments__mutmut_24': xǁSegmentTemplateǁsegments__mutmut_24, 
        'xǁSegmentTemplateǁsegments__mutmut_25': xǁSegmentTemplateǁsegments__mutmut_25, 
        'xǁSegmentTemplateǁsegments__mutmut_26': xǁSegmentTemplateǁsegments__mutmut_26, 
        'xǁSegmentTemplateǁsegments__mutmut_27': xǁSegmentTemplateǁsegments__mutmut_27, 
        'xǁSegmentTemplateǁsegments__mutmut_28': xǁSegmentTemplateǁsegments__mutmut_28, 
        'xǁSegmentTemplateǁsegments__mutmut_29': xǁSegmentTemplateǁsegments__mutmut_29, 
        'xǁSegmentTemplateǁsegments__mutmut_30': xǁSegmentTemplateǁsegments__mutmut_30, 
        'xǁSegmentTemplateǁsegments__mutmut_31': xǁSegmentTemplateǁsegments__mutmut_31, 
        'xǁSegmentTemplateǁsegments__mutmut_32': xǁSegmentTemplateǁsegments__mutmut_32, 
        'xǁSegmentTemplateǁsegments__mutmut_33': xǁSegmentTemplateǁsegments__mutmut_33, 
        'xǁSegmentTemplateǁsegments__mutmut_34': xǁSegmentTemplateǁsegments__mutmut_34, 
        'xǁSegmentTemplateǁsegments__mutmut_35': xǁSegmentTemplateǁsegments__mutmut_35, 
        'xǁSegmentTemplateǁsegments__mutmut_36': xǁSegmentTemplateǁsegments__mutmut_36, 
        'xǁSegmentTemplateǁsegments__mutmut_37': xǁSegmentTemplateǁsegments__mutmut_37, 
        'xǁSegmentTemplateǁsegments__mutmut_38': xǁSegmentTemplateǁsegments__mutmut_38, 
        'xǁSegmentTemplateǁsegments__mutmut_39': xǁSegmentTemplateǁsegments__mutmut_39, 
        'xǁSegmentTemplateǁsegments__mutmut_40': xǁSegmentTemplateǁsegments__mutmut_40, 
        'xǁSegmentTemplateǁsegments__mutmut_41': xǁSegmentTemplateǁsegments__mutmut_41, 
        'xǁSegmentTemplateǁsegments__mutmut_42': xǁSegmentTemplateǁsegments__mutmut_42, 
        'xǁSegmentTemplateǁsegments__mutmut_43': xǁSegmentTemplateǁsegments__mutmut_43, 
        'xǁSegmentTemplateǁsegments__mutmut_44': xǁSegmentTemplateǁsegments__mutmut_44, 
        'xǁSegmentTemplateǁsegments__mutmut_45': xǁSegmentTemplateǁsegments__mutmut_45
    }
    
    def segments(self, *args, **kwargs):
        result = yield from _mutmut_yield_from_trampoline(object.__getattribute__(self, "xǁSegmentTemplateǁsegments__mutmut_orig"), object.__getattribute__(self, "xǁSegmentTemplateǁsegments__mutmut_mutants"), args, kwargs, self)
        return result 
    
    segments.__signature__ = _mutmut_signature(xǁSegmentTemplateǁsegments__mutmut_orig)
    xǁSegmentTemplateǁsegments__mutmut_orig.__name__ = 'xǁSegmentTemplateǁsegments'

    @staticmethod
    def make_url(base_url: str, url: str) -> str:
        return urljoin(base_url, url)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_orig(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_1(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_2(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError(None)

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_3(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("XXUnknown segment durations: missing duration/timescale attributes on SegmentTemplateXX")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_4(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("unknown segment durations: missing duration/timescale attributes on segmenttemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_5(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("UNKNOWN SEGMENT DURATIONS: MISSING DURATION/TIMESCALE ATTRIBUTES ON SEGMENTTEMPLATE")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_6(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on segmenttemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_7(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type != "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_8(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "XXstaticXX":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_9(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "STATIC":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_10(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "Static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_11(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = None
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_12(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(None)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_13(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = None
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_14(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() and self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_15(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = None
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_16(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(None, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_17(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, None)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_18(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_19(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, )
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_20(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(None) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_21(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration * self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_22(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) - 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_23(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 2)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_24(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = None
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_25(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(None)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_26(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = None
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_27(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp and now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_28(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = None

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_29(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time + self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_30(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime + self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_31(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = None
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_32(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = None

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_33(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = None
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_34(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start + suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_35(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay + buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_36(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = None
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_37(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(None, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_38(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, None)
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_39(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_40(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, )
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_41(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(1, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_42(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(None))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_43(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset * self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_44(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = None

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_45(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(None)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_46(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber - number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_47(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = None
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_48(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=None)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_49(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset / self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_50(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = None
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_51(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime - available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_52(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = None

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_53(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                None,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_54(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                None,
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_55(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_56(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_57(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=None),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_58(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(None)
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_59(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(None)
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_60(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(None)
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_61(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                None,
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_62(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join(None),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_63(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "XX; XX".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_64(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                None,
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_65(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join(None),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_66(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "XX; XX".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_67(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(None, available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_68(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, None)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_69(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(available_iter)

    def xǁSegmentTemplateǁsegment_numbers__mutmut_70(self, timestamp: datetime | None = None) -> Iterator[tuple[int, datetime]]:
        """
        yield the segment number and when it will be available.

        There are two cases for segment number generation, "static" and "dynamic":

        In the case of static streams, the segment number starts at the startNumber and counts
        up to the number of segments that are represented by the periods-duration.

        In the case of dynamic streams, the segments should appear at the specified time.
        In the simplest case, the segment number is based on the time since the availabilityStartTime.
        """

        if not self.duration_seconds:  # pragma: no cover
            raise MPDParsingError("Unknown segment durations: missing duration/timescale attributes on SegmentTemplate")

        number_iter: Iterator[int] | Sequence[int]
        available_iter: Iterator[datetime]

        if self.root.type == "static":
            available_iter = repeat(self.period.availabilityStartTime)
            duration = self.period.duration.total_seconds() or self.root.mediaPresentationDuration.total_seconds()
            if duration:
                number_iter = range(self.startNumber, int(duration / self.duration_seconds) + 1)
            else:
                number_iter = count(self.startNumber)
        else:
            current_time = timestamp or now()
            since_start = current_time - self.period.availabilityStartTime - self.presentationTimeOffset

            suggested_delay = self.root.suggestedPresentationDelay
            buffer_time = self.root.minBufferTime

            # Segment number
            seconds_offset = (since_start - suggested_delay - buffer_time).total_seconds()
            number_offset = max(0, int(seconds_offset / self.duration_seconds))
            number_iter = count(self.startNumber + number_offset)

            # Segment availability time
            available_offset = timedelta(seconds=number_offset * self.duration_seconds)
            available_start = self.period.availabilityStartTime + available_offset
            available_iter = count_dt(
                available_start,
                timedelta(seconds=self.duration_seconds),
            )

            log.debug(f"Stream start: {self.period.availabilityStartTime}")
            log.debug(f"Current time: {current_time}")
            log.debug(f"Availability: {available_start}")
            log.debug(
                "; ".join([
                    f"presentationTimeOffset: {self.presentationTimeOffset}",
                    f"suggestedPresentationDelay: {self.root.suggestedPresentationDelay}",
                    f"minBufferTime: {self.root.minBufferTime}",
                ]),
            )
            log.debug(
                "; ".join([
                    f"segmentDuration: {self.duration_seconds}",
                    f"segmentStart: {self.startNumber}",
                    f"segmentOffset: {number_offset} ({seconds_offset}s)",
                ]),
            )

        yield from zip(number_iter, )
    
    xǁSegmentTemplateǁsegment_numbers__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁSegmentTemplateǁsegment_numbers__mutmut_1': xǁSegmentTemplateǁsegment_numbers__mutmut_1, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_2': xǁSegmentTemplateǁsegment_numbers__mutmut_2, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_3': xǁSegmentTemplateǁsegment_numbers__mutmut_3, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_4': xǁSegmentTemplateǁsegment_numbers__mutmut_4, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_5': xǁSegmentTemplateǁsegment_numbers__mutmut_5, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_6': xǁSegmentTemplateǁsegment_numbers__mutmut_6, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_7': xǁSegmentTemplateǁsegment_numbers__mutmut_7, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_8': xǁSegmentTemplateǁsegment_numbers__mutmut_8, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_9': xǁSegmentTemplateǁsegment_numbers__mutmut_9, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_10': xǁSegmentTemplateǁsegment_numbers__mutmut_10, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_11': xǁSegmentTemplateǁsegment_numbers__mutmut_11, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_12': xǁSegmentTemplateǁsegment_numbers__mutmut_12, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_13': xǁSegmentTemplateǁsegment_numbers__mutmut_13, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_14': xǁSegmentTemplateǁsegment_numbers__mutmut_14, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_15': xǁSegmentTemplateǁsegment_numbers__mutmut_15, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_16': xǁSegmentTemplateǁsegment_numbers__mutmut_16, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_17': xǁSegmentTemplateǁsegment_numbers__mutmut_17, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_18': xǁSegmentTemplateǁsegment_numbers__mutmut_18, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_19': xǁSegmentTemplateǁsegment_numbers__mutmut_19, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_20': xǁSegmentTemplateǁsegment_numbers__mutmut_20, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_21': xǁSegmentTemplateǁsegment_numbers__mutmut_21, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_22': xǁSegmentTemplateǁsegment_numbers__mutmut_22, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_23': xǁSegmentTemplateǁsegment_numbers__mutmut_23, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_24': xǁSegmentTemplateǁsegment_numbers__mutmut_24, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_25': xǁSegmentTemplateǁsegment_numbers__mutmut_25, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_26': xǁSegmentTemplateǁsegment_numbers__mutmut_26, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_27': xǁSegmentTemplateǁsegment_numbers__mutmut_27, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_28': xǁSegmentTemplateǁsegment_numbers__mutmut_28, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_29': xǁSegmentTemplateǁsegment_numbers__mutmut_29, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_30': xǁSegmentTemplateǁsegment_numbers__mutmut_30, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_31': xǁSegmentTemplateǁsegment_numbers__mutmut_31, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_32': xǁSegmentTemplateǁsegment_numbers__mutmut_32, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_33': xǁSegmentTemplateǁsegment_numbers__mutmut_33, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_34': xǁSegmentTemplateǁsegment_numbers__mutmut_34, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_35': xǁSegmentTemplateǁsegment_numbers__mutmut_35, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_36': xǁSegmentTemplateǁsegment_numbers__mutmut_36, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_37': xǁSegmentTemplateǁsegment_numbers__mutmut_37, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_38': xǁSegmentTemplateǁsegment_numbers__mutmut_38, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_39': xǁSegmentTemplateǁsegment_numbers__mutmut_39, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_40': xǁSegmentTemplateǁsegment_numbers__mutmut_40, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_41': xǁSegmentTemplateǁsegment_numbers__mutmut_41, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_42': xǁSegmentTemplateǁsegment_numbers__mutmut_42, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_43': xǁSegmentTemplateǁsegment_numbers__mutmut_43, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_44': xǁSegmentTemplateǁsegment_numbers__mutmut_44, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_45': xǁSegmentTemplateǁsegment_numbers__mutmut_45, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_46': xǁSegmentTemplateǁsegment_numbers__mutmut_46, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_47': xǁSegmentTemplateǁsegment_numbers__mutmut_47, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_48': xǁSegmentTemplateǁsegment_numbers__mutmut_48, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_49': xǁSegmentTemplateǁsegment_numbers__mutmut_49, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_50': xǁSegmentTemplateǁsegment_numbers__mutmut_50, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_51': xǁSegmentTemplateǁsegment_numbers__mutmut_51, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_52': xǁSegmentTemplateǁsegment_numbers__mutmut_52, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_53': xǁSegmentTemplateǁsegment_numbers__mutmut_53, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_54': xǁSegmentTemplateǁsegment_numbers__mutmut_54, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_55': xǁSegmentTemplateǁsegment_numbers__mutmut_55, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_56': xǁSegmentTemplateǁsegment_numbers__mutmut_56, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_57': xǁSegmentTemplateǁsegment_numbers__mutmut_57, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_58': xǁSegmentTemplateǁsegment_numbers__mutmut_58, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_59': xǁSegmentTemplateǁsegment_numbers__mutmut_59, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_60': xǁSegmentTemplateǁsegment_numbers__mutmut_60, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_61': xǁSegmentTemplateǁsegment_numbers__mutmut_61, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_62': xǁSegmentTemplateǁsegment_numbers__mutmut_62, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_63': xǁSegmentTemplateǁsegment_numbers__mutmut_63, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_64': xǁSegmentTemplateǁsegment_numbers__mutmut_64, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_65': xǁSegmentTemplateǁsegment_numbers__mutmut_65, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_66': xǁSegmentTemplateǁsegment_numbers__mutmut_66, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_67': xǁSegmentTemplateǁsegment_numbers__mutmut_67, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_68': xǁSegmentTemplateǁsegment_numbers__mutmut_68, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_69': xǁSegmentTemplateǁsegment_numbers__mutmut_69, 
        'xǁSegmentTemplateǁsegment_numbers__mutmut_70': xǁSegmentTemplateǁsegment_numbers__mutmut_70
    }
    
    def segment_numbers(self, *args, **kwargs):
        result = yield from _mutmut_yield_from_trampoline(object.__getattribute__(self, "xǁSegmentTemplateǁsegment_numbers__mutmut_orig"), object.__getattribute__(self, "xǁSegmentTemplateǁsegment_numbers__mutmut_mutants"), args, kwargs, self)
        return result 
    
    segment_numbers.__signature__ = _mutmut_signature(xǁSegmentTemplateǁsegment_numbers__mutmut_orig)
    xǁSegmentTemplateǁsegment_numbers__mutmut_orig.__name__ = 'xǁSegmentTemplateǁsegment_numbers'

    def xǁSegmentTemplateǁsegment_timeline__mutmut_orig(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_1(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_2(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError(None)

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_3(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("XXMissing SegmentTimeline in SegmentTemplateXX")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_4(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("missing segmenttimeline in segmenttemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_5(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("MISSING SEGMENTTIMELINE IN SEGMENTTEMPLATE")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_6(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing segmenttimeline in segmenttemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_7(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type != "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_8(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "XXstaticXX":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_9(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "STATIC":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_10(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "Static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_11(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(None, self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_12(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), None, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_13(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, None)
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_14(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_15(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_16(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, )
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_17(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(None), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_18(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(None))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_19(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = None
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_20(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = None

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_21(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time != -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_22(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == +1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_23(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -2

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_24(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = None

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_25(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime + self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_26(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = None
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_27(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = None

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_28(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(None):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_29(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(None)):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_30(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(None, self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_31(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), None))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_32(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_33(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), ))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_34(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(None), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_35(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial or available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_36(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at < threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_37(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold and segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_38(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t < time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_39(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    return

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_40(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append(None)
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_41(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at = timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_42(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at += timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_43(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=None)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_44(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d * self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_45(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(None):
                self.root.timelines[ident] = segment.t
                yield number, segment, available_at

    def xǁSegmentTemplateǁsegment_timeline__mutmut_46(self, ident: TTimelineIdent) -> Iterator[tuple[int, TimelineSegment, datetime]]:
        if not self.segmentTimeline:  # pragma: no cover
            raise MPDParsingError("Missing SegmentTimeline in SegmentTemplate")

        if self.root.type == "static":
            yield from zip(count(self.startNumber), self.segmentTimeline.segments, repeat(self.period.availabilityStartTime))
        else:
            time = self.root.timelines[ident]
            is_initial = time == -1

            threshold = self.root.publishTime - self.root.suggestedPresentationDelay

            # transform the timeline into a segment list
            timeline = []
            available_at = self.root.publishTime

            # the last segment in the timeline is the most recent one
            # so, work backwards and calculate when each of the segments was
            # available, based on the durations relative to the publish-time
            for number, segment in reversed(list(zip(count(self.startNumber), self.segmentTimeline.segments))):
                # stop once the suggestedPresentationDelay is reached on the first manifest parsing
                # or when a segment with a lower or equal time value was already returned from an earlier manifest
                if is_initial and available_at <= threshold or segment.t <= time:
                    break

                timeline.append((number, segment, available_at))
                available_at -= timedelta(seconds=segment.d / self.timescale)

            # return the segments in chronological order
            for number, segment, available_at in reversed(timeline):
                self.root.timelines[ident] = None
                yield number, segment, available_at
    
    xǁSegmentTemplateǁsegment_timeline__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁSegmentTemplateǁsegment_timeline__mutmut_1': xǁSegmentTemplateǁsegment_timeline__mutmut_1, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_2': xǁSegmentTemplateǁsegment_timeline__mutmut_2, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_3': xǁSegmentTemplateǁsegment_timeline__mutmut_3, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_4': xǁSegmentTemplateǁsegment_timeline__mutmut_4, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_5': xǁSegmentTemplateǁsegment_timeline__mutmut_5, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_6': xǁSegmentTemplateǁsegment_timeline__mutmut_6, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_7': xǁSegmentTemplateǁsegment_timeline__mutmut_7, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_8': xǁSegmentTemplateǁsegment_timeline__mutmut_8, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_9': xǁSegmentTemplateǁsegment_timeline__mutmut_9, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_10': xǁSegmentTemplateǁsegment_timeline__mutmut_10, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_11': xǁSegmentTemplateǁsegment_timeline__mutmut_11, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_12': xǁSegmentTemplateǁsegment_timeline__mutmut_12, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_13': xǁSegmentTemplateǁsegment_timeline__mutmut_13, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_14': xǁSegmentTemplateǁsegment_timeline__mutmut_14, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_15': xǁSegmentTemplateǁsegment_timeline__mutmut_15, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_16': xǁSegmentTemplateǁsegment_timeline__mutmut_16, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_17': xǁSegmentTemplateǁsegment_timeline__mutmut_17, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_18': xǁSegmentTemplateǁsegment_timeline__mutmut_18, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_19': xǁSegmentTemplateǁsegment_timeline__mutmut_19, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_20': xǁSegmentTemplateǁsegment_timeline__mutmut_20, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_21': xǁSegmentTemplateǁsegment_timeline__mutmut_21, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_22': xǁSegmentTemplateǁsegment_timeline__mutmut_22, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_23': xǁSegmentTemplateǁsegment_timeline__mutmut_23, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_24': xǁSegmentTemplateǁsegment_timeline__mutmut_24, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_25': xǁSegmentTemplateǁsegment_timeline__mutmut_25, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_26': xǁSegmentTemplateǁsegment_timeline__mutmut_26, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_27': xǁSegmentTemplateǁsegment_timeline__mutmut_27, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_28': xǁSegmentTemplateǁsegment_timeline__mutmut_28, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_29': xǁSegmentTemplateǁsegment_timeline__mutmut_29, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_30': xǁSegmentTemplateǁsegment_timeline__mutmut_30, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_31': xǁSegmentTemplateǁsegment_timeline__mutmut_31, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_32': xǁSegmentTemplateǁsegment_timeline__mutmut_32, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_33': xǁSegmentTemplateǁsegment_timeline__mutmut_33, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_34': xǁSegmentTemplateǁsegment_timeline__mutmut_34, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_35': xǁSegmentTemplateǁsegment_timeline__mutmut_35, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_36': xǁSegmentTemplateǁsegment_timeline__mutmut_36, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_37': xǁSegmentTemplateǁsegment_timeline__mutmut_37, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_38': xǁSegmentTemplateǁsegment_timeline__mutmut_38, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_39': xǁSegmentTemplateǁsegment_timeline__mutmut_39, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_40': xǁSegmentTemplateǁsegment_timeline__mutmut_40, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_41': xǁSegmentTemplateǁsegment_timeline__mutmut_41, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_42': xǁSegmentTemplateǁsegment_timeline__mutmut_42, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_43': xǁSegmentTemplateǁsegment_timeline__mutmut_43, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_44': xǁSegmentTemplateǁsegment_timeline__mutmut_44, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_45': xǁSegmentTemplateǁsegment_timeline__mutmut_45, 
        'xǁSegmentTemplateǁsegment_timeline__mutmut_46': xǁSegmentTemplateǁsegment_timeline__mutmut_46
    }
    
    def segment_timeline(self, *args, **kwargs):
        result = yield from _mutmut_yield_from_trampoline(object.__getattribute__(self, "xǁSegmentTemplateǁsegment_timeline__mutmut_orig"), object.__getattribute__(self, "xǁSegmentTemplateǁsegment_timeline__mutmut_mutants"), args, kwargs, self)
        return result 
    
    segment_timeline.__signature__ = _mutmut_signature(xǁSegmentTemplateǁsegment_timeline__mutmut_orig)
    xǁSegmentTemplateǁsegment_timeline__mutmut_orig.__name__ = 'xǁSegmentTemplateǁsegment_timeline'

    def xǁSegmentTemplateǁformat_initialization__mutmut_orig(self, base_url: str, **kwargs) -> str | None:
        if self.fmt_initialization is not None:  # pragma: no branch
            return self.make_url(base_url, self.fmt_initialization(**kwargs))

    def xǁSegmentTemplateǁformat_initialization__mutmut_1(self, base_url: str, **kwargs) -> str | None:
        if self.fmt_initialization is None:  # pragma: no branch
            return self.make_url(base_url, self.fmt_initialization(**kwargs))

    def xǁSegmentTemplateǁformat_initialization__mutmut_2(self, base_url: str, **kwargs) -> str | None:
        if self.fmt_initialization is not None:  # pragma: no branch
            return self.make_url(None, self.fmt_initialization(**kwargs))

    def xǁSegmentTemplateǁformat_initialization__mutmut_3(self, base_url: str, **kwargs) -> str | None:
        if self.fmt_initialization is not None:  # pragma: no branch
            return self.make_url(base_url, None)

    def xǁSegmentTemplateǁformat_initialization__mutmut_4(self, base_url: str, **kwargs) -> str | None:
        if self.fmt_initialization is not None:  # pragma: no branch
            return self.make_url(self.fmt_initialization(**kwargs))

    def xǁSegmentTemplateǁformat_initialization__mutmut_5(self, base_url: str, **kwargs) -> str | None:
        if self.fmt_initialization is not None:  # pragma: no branch
            return self.make_url(base_url, )
    
    xǁSegmentTemplateǁformat_initialization__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁSegmentTemplateǁformat_initialization__mutmut_1': xǁSegmentTemplateǁformat_initialization__mutmut_1, 
        'xǁSegmentTemplateǁformat_initialization__mutmut_2': xǁSegmentTemplateǁformat_initialization__mutmut_2, 
        'xǁSegmentTemplateǁformat_initialization__mutmut_3': xǁSegmentTemplateǁformat_initialization__mutmut_3, 
        'xǁSegmentTemplateǁformat_initialization__mutmut_4': xǁSegmentTemplateǁformat_initialization__mutmut_4, 
        'xǁSegmentTemplateǁformat_initialization__mutmut_5': xǁSegmentTemplateǁformat_initialization__mutmut_5
    }
    
    def format_initialization(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁSegmentTemplateǁformat_initialization__mutmut_orig"), object.__getattribute__(self, "xǁSegmentTemplateǁformat_initialization__mutmut_mutants"), args, kwargs, self)
        return result 
    
    format_initialization.__signature__ = _mutmut_signature(xǁSegmentTemplateǁformat_initialization__mutmut_orig)
    xǁSegmentTemplateǁformat_initialization__mutmut_orig.__name__ = 'xǁSegmentTemplateǁformat_initialization'

    def xǁSegmentTemplateǁformat_media__mutmut_orig(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_1(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is not None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_2(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_3(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(None)
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_4(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = None
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_5(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=None):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_6(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = None
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_7(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(None, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_8(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, None)
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_9(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_10(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, )
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_11(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=None, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_12(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(**kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_13(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, ))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_14(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(None)
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_15(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(None):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_16(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = None
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_17(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(None, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_18(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, None)
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_19(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_20(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, )
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_21(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=None, Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_22(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=None, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_23(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_24(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, **kwargs))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_25(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, ))
                duration = segment.d / self.timescale
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_26(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = None
                yield url, number, duration, available_at

    def xǁSegmentTemplateǁformat_media__mutmut_27(
        self,
        ident: TTimelineIdent,
        base_url: str,
        timestamp: datetime | None = None,
        **kwargs,
    ) -> Iterator[tuple[str, int, float, datetime]]:
        if self.fmt_media is None:  # pragma: no cover
            return

        if not self.segmentTimeline:
            log.debug(f"Generating segment numbers for {self.root.type} playlist: {ident!r}")
            duration = self.duration_seconds
            for number, available_at in self.segment_numbers(timestamp=timestamp):
                url = self.make_url(base_url, self.fmt_media(Number=number, **kwargs))
                yield url, number, duration, available_at
        else:
            log.debug(f"Generating segment timeline for {self.root.type} playlist: {ident!r}")
            for number, segment, available_at in self.segment_timeline(ident):
                url = self.make_url(base_url, self.fmt_media(Time=segment.t, Number=number, **kwargs))
                duration = segment.d * self.timescale
                yield url, number, duration, available_at
    
    xǁSegmentTemplateǁformat_media__mutmut_mutants : ClassVar[MutantDict] = {
    'xǁSegmentTemplateǁformat_media__mutmut_1': xǁSegmentTemplateǁformat_media__mutmut_1, 
        'xǁSegmentTemplateǁformat_media__mutmut_2': xǁSegmentTemplateǁformat_media__mutmut_2, 
        'xǁSegmentTemplateǁformat_media__mutmut_3': xǁSegmentTemplateǁformat_media__mutmut_3, 
        'xǁSegmentTemplateǁformat_media__mutmut_4': xǁSegmentTemplateǁformat_media__mutmut_4, 
        'xǁSegmentTemplateǁformat_media__mutmut_5': xǁSegmentTemplateǁformat_media__mutmut_5, 
        'xǁSegmentTemplateǁformat_media__mutmut_6': xǁSegmentTemplateǁformat_media__mutmut_6, 
        'xǁSegmentTemplateǁformat_media__mutmut_7': xǁSegmentTemplateǁformat_media__mutmut_7, 
        'xǁSegmentTemplateǁformat_media__mutmut_8': xǁSegmentTemplateǁformat_media__mutmut_8, 
        'xǁSegmentTemplateǁformat_media__mutmut_9': xǁSegmentTemplateǁformat_media__mutmut_9, 
        'xǁSegmentTemplateǁformat_media__mutmut_10': xǁSegmentTemplateǁformat_media__mutmut_10, 
        'xǁSegmentTemplateǁformat_media__mutmut_11': xǁSegmentTemplateǁformat_media__mutmut_11, 
        'xǁSegmentTemplateǁformat_media__mutmut_12': xǁSegmentTemplateǁformat_media__mutmut_12, 
        'xǁSegmentTemplateǁformat_media__mutmut_13': xǁSegmentTemplateǁformat_media__mutmut_13, 
        'xǁSegmentTemplateǁformat_media__mutmut_14': xǁSegmentTemplateǁformat_media__mutmut_14, 
        'xǁSegmentTemplateǁformat_media__mutmut_15': xǁSegmentTemplateǁformat_media__mutmut_15, 
        'xǁSegmentTemplateǁformat_media__mutmut_16': xǁSegmentTemplateǁformat_media__mutmut_16, 
        'xǁSegmentTemplateǁformat_media__mutmut_17': xǁSegmentTemplateǁformat_media__mutmut_17, 
        'xǁSegmentTemplateǁformat_media__mutmut_18': xǁSegmentTemplateǁformat_media__mutmut_18, 
        'xǁSegmentTemplateǁformat_media__mutmut_19': xǁSegmentTemplateǁformat_media__mutmut_19, 
        'xǁSegmentTemplateǁformat_media__mutmut_20': xǁSegmentTemplateǁformat_media__mutmut_20, 
        'xǁSegmentTemplateǁformat_media__mutmut_21': xǁSegmentTemplateǁformat_media__mutmut_21, 
        'xǁSegmentTemplateǁformat_media__mutmut_22': xǁSegmentTemplateǁformat_media__mutmut_22, 
        'xǁSegmentTemplateǁformat_media__mutmut_23': xǁSegmentTemplateǁformat_media__mutmut_23, 
        'xǁSegmentTemplateǁformat_media__mutmut_24': xǁSegmentTemplateǁformat_media__mutmut_24, 
        'xǁSegmentTemplateǁformat_media__mutmut_25': xǁSegmentTemplateǁformat_media__mutmut_25, 
        'xǁSegmentTemplateǁformat_media__mutmut_26': xǁSegmentTemplateǁformat_media__mutmut_26, 
        'xǁSegmentTemplateǁformat_media__mutmut_27': xǁSegmentTemplateǁformat_media__mutmut_27
    }
    
    def format_media(self, *args, **kwargs):
        result = yield from _mutmut_yield_from_trampoline(object.__getattribute__(self, "xǁSegmentTemplateǁformat_media__mutmut_orig"), object.__getattribute__(self, "xǁSegmentTemplateǁformat_media__mutmut_mutants"), args, kwargs, self)
        return result 
    
    format_media.__signature__ = _mutmut_signature(xǁSegmentTemplateǁformat_media__mutmut_orig)
    xǁSegmentTemplateǁformat_media__mutmut_orig.__name__ = 'xǁSegmentTemplateǁformat_media'


class SegmentTimeline(MPDNode):
    __tag__ = "SegmentTimeline"

    def xǁSegmentTimelineǁ__init____mutmut_orig(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.timescale = self.walk_back_get_attr("timescale")

        self.timeline_segments = self.children(_TimelineSegment)

    def xǁSegmentTimelineǁ__init____mutmut_1(self, *args, **kwargs) -> None:
        super().__init__(**kwargs)

        self.timescale = self.walk_back_get_attr("timescale")

        self.timeline_segments = self.children(_TimelineSegment)

    def xǁSegmentTimelineǁ__init____mutmut_2(self, *args, **kwargs) -> None:
        super().__init__(*args, )

        self.timescale = self.walk_back_get_attr("timescale")

        self.timeline_segments = self.children(_TimelineSegment)

    def xǁSegmentTimelineǁ__init____mutmut_3(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.timescale = None

        self.timeline_segments = self.children(_TimelineSegment)

    def xǁSegmentTimelineǁ__init____mutmut_4(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.timescale = self.walk_back_get_attr(None)

        self.timeline_segments = self.children(_TimelineSegment)

    def xǁSegmentTimelineǁ__init____mutmut_5(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.timescale = self.walk_back_get_attr("XXtimescaleXX")

        self.timeline_segments = self.children(_TimelineSegment)

    def xǁSegmentTimelineǁ__init____mutmut_6(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.timescale = self.walk_back_get_attr("TIMESCALE")

        self.timeline_segments = self.children(_TimelineSegment)

    def xǁSegmentTimelineǁ__init____mutmut_7(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.timescale = self.walk_back_get_attr("Timescale")

        self.timeline_segments = self.children(_TimelineSegment)

    def xǁSegmentTimelineǁ__init____mutmut_8(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.timescale = self.walk_back_get_attr("timescale")

        self.timeline_segments = None

    def xǁSegmentTimelineǁ__init____mutmut_9(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.timescale = self.walk_back_get_attr("timescale")

        self.timeline_segments = self.children(None)
    
    xǁSegmentTimelineǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁSegmentTimelineǁ__init____mutmut_1': xǁSegmentTimelineǁ__init____mutmut_1, 
        'xǁSegmentTimelineǁ__init____mutmut_2': xǁSegmentTimelineǁ__init____mutmut_2, 
        'xǁSegmentTimelineǁ__init____mutmut_3': xǁSegmentTimelineǁ__init____mutmut_3, 
        'xǁSegmentTimelineǁ__init____mutmut_4': xǁSegmentTimelineǁ__init____mutmut_4, 
        'xǁSegmentTimelineǁ__init____mutmut_5': xǁSegmentTimelineǁ__init____mutmut_5, 
        'xǁSegmentTimelineǁ__init____mutmut_6': xǁSegmentTimelineǁ__init____mutmut_6, 
        'xǁSegmentTimelineǁ__init____mutmut_7': xǁSegmentTimelineǁ__init____mutmut_7, 
        'xǁSegmentTimelineǁ__init____mutmut_8': xǁSegmentTimelineǁ__init____mutmut_8, 
        'xǁSegmentTimelineǁ__init____mutmut_9': xǁSegmentTimelineǁ__init____mutmut_9
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁSegmentTimelineǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁSegmentTimelineǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁSegmentTimelineǁ__init____mutmut_orig)
    xǁSegmentTimelineǁ__init____mutmut_orig.__name__ = 'xǁSegmentTimelineǁ__init__'

    @property
    def segments(self) -> Iterator[TimelineSegment]:
        t = 0
        for tsegment in self.timeline_segments:
            if t == 0 and tsegment.t is not None:
                t = tsegment.t
            # check the start time from MPD
            for _ in range(tsegment.r + 1):
                yield TimelineSegment(t, tsegment.d)
                t += tsegment.d


class _TimelineSegment(MPDNode):
    __tag__ = "S"

    def xǁ_TimelineSegmentǁ__init____mutmut_orig(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_1(self, *args, **kwargs) -> None:
        super().__init__(**kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_2(self, *args, **kwargs) -> None:
        super().__init__(*args, )

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_3(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = None
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_4(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr(None, parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_5(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=None)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_6(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr(parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_7(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", )
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_8(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("XXtXX", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_9(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("T", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_10(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("T", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_11(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = None  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_12(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr(None, parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_13(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=None, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_14(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=None)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_15(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr(parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_16(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_17(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, )  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_18(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("XXdXX", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_19(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("D", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_20(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("D", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_21(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=False)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_22(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = None

    def xǁ_TimelineSegmentǁ__init____mutmut_23(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr(None, parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_24(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=None, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_25(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=None)

    def xǁ_TimelineSegmentǁ__init____mutmut_26(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr(parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_27(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_28(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, )

    def xǁ_TimelineSegmentǁ__init____mutmut_29(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("XXrXX", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_30(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("R", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_31(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("R", parser=int, default=0)

    def xǁ_TimelineSegmentǁ__init____mutmut_32(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.t = self.attr("t", parser=int)
        self.d: int = self.attr("d", parser=int, required=True)  # type: ignore[assignment]
        self.r = self.attr("r", parser=int, default=1)
    
    xǁ_TimelineSegmentǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁ_TimelineSegmentǁ__init____mutmut_1': xǁ_TimelineSegmentǁ__init____mutmut_1, 
        'xǁ_TimelineSegmentǁ__init____mutmut_2': xǁ_TimelineSegmentǁ__init____mutmut_2, 
        'xǁ_TimelineSegmentǁ__init____mutmut_3': xǁ_TimelineSegmentǁ__init____mutmut_3, 
        'xǁ_TimelineSegmentǁ__init____mutmut_4': xǁ_TimelineSegmentǁ__init____mutmut_4, 
        'xǁ_TimelineSegmentǁ__init____mutmut_5': xǁ_TimelineSegmentǁ__init____mutmut_5, 
        'xǁ_TimelineSegmentǁ__init____mutmut_6': xǁ_TimelineSegmentǁ__init____mutmut_6, 
        'xǁ_TimelineSegmentǁ__init____mutmut_7': xǁ_TimelineSegmentǁ__init____mutmut_7, 
        'xǁ_TimelineSegmentǁ__init____mutmut_8': xǁ_TimelineSegmentǁ__init____mutmut_8, 
        'xǁ_TimelineSegmentǁ__init____mutmut_9': xǁ_TimelineSegmentǁ__init____mutmut_9, 
        'xǁ_TimelineSegmentǁ__init____mutmut_10': xǁ_TimelineSegmentǁ__init____mutmut_10, 
        'xǁ_TimelineSegmentǁ__init____mutmut_11': xǁ_TimelineSegmentǁ__init____mutmut_11, 
        'xǁ_TimelineSegmentǁ__init____mutmut_12': xǁ_TimelineSegmentǁ__init____mutmut_12, 
        'xǁ_TimelineSegmentǁ__init____mutmut_13': xǁ_TimelineSegmentǁ__init____mutmut_13, 
        'xǁ_TimelineSegmentǁ__init____mutmut_14': xǁ_TimelineSegmentǁ__init____mutmut_14, 
        'xǁ_TimelineSegmentǁ__init____mutmut_15': xǁ_TimelineSegmentǁ__init____mutmut_15, 
        'xǁ_TimelineSegmentǁ__init____mutmut_16': xǁ_TimelineSegmentǁ__init____mutmut_16, 
        'xǁ_TimelineSegmentǁ__init____mutmut_17': xǁ_TimelineSegmentǁ__init____mutmut_17, 
        'xǁ_TimelineSegmentǁ__init____mutmut_18': xǁ_TimelineSegmentǁ__init____mutmut_18, 
        'xǁ_TimelineSegmentǁ__init____mutmut_19': xǁ_TimelineSegmentǁ__init____mutmut_19, 
        'xǁ_TimelineSegmentǁ__init____mutmut_20': xǁ_TimelineSegmentǁ__init____mutmut_20, 
        'xǁ_TimelineSegmentǁ__init____mutmut_21': xǁ_TimelineSegmentǁ__init____mutmut_21, 
        'xǁ_TimelineSegmentǁ__init____mutmut_22': xǁ_TimelineSegmentǁ__init____mutmut_22, 
        'xǁ_TimelineSegmentǁ__init____mutmut_23': xǁ_TimelineSegmentǁ__init____mutmut_23, 
        'xǁ_TimelineSegmentǁ__init____mutmut_24': xǁ_TimelineSegmentǁ__init____mutmut_24, 
        'xǁ_TimelineSegmentǁ__init____mutmut_25': xǁ_TimelineSegmentǁ__init____mutmut_25, 
        'xǁ_TimelineSegmentǁ__init____mutmut_26': xǁ_TimelineSegmentǁ__init____mutmut_26, 
        'xǁ_TimelineSegmentǁ__init____mutmut_27': xǁ_TimelineSegmentǁ__init____mutmut_27, 
        'xǁ_TimelineSegmentǁ__init____mutmut_28': xǁ_TimelineSegmentǁ__init____mutmut_28, 
        'xǁ_TimelineSegmentǁ__init____mutmut_29': xǁ_TimelineSegmentǁ__init____mutmut_29, 
        'xǁ_TimelineSegmentǁ__init____mutmut_30': xǁ_TimelineSegmentǁ__init____mutmut_30, 
        'xǁ_TimelineSegmentǁ__init____mutmut_31': xǁ_TimelineSegmentǁ__init____mutmut_31, 
        'xǁ_TimelineSegmentǁ__init____mutmut_32': xǁ_TimelineSegmentǁ__init____mutmut_32
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁ_TimelineSegmentǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁ_TimelineSegmentǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁ_TimelineSegmentǁ__init____mutmut_orig)
    xǁ_TimelineSegmentǁ__init____mutmut_orig.__name__ = 'xǁ_TimelineSegmentǁ__init__'


class Initialization(MPDNode):
    __tag__ = "Initialization"

    def xǁInitializationǁ__init____mutmut_orig(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.source_url = self.attr("sourceURL")
        self.range = self.attr(
            "range",
            parser=MPDParsers.range,
        )

    def xǁInitializationǁ__init____mutmut_1(self, *args, **kwargs) -> None:
        super().__init__(**kwargs)

        self.source_url = self.attr("sourceURL")
        self.range = self.attr(
            "range",
            parser=MPDParsers.range,
        )

    def xǁInitializationǁ__init____mutmut_2(self, *args, **kwargs) -> None:
        super().__init__(*args, )

        self.source_url = self.attr("sourceURL")
        self.range = self.attr(
            "range",
            parser=MPDParsers.range,
        )

    def xǁInitializationǁ__init____mutmut_3(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.source_url = None
        self.range = self.attr(
            "range",
            parser=MPDParsers.range,
        )

    def xǁInitializationǁ__init____mutmut_4(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.source_url = self.attr(None)
        self.range = self.attr(
            "range",
            parser=MPDParsers.range,
        )

    def xǁInitializationǁ__init____mutmut_5(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.source_url = self.attr("XXsourceURLXX")
        self.range = self.attr(
            "range",
            parser=MPDParsers.range,
        )

    def xǁInitializationǁ__init____mutmut_6(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.source_url = self.attr("sourceurl")
        self.range = self.attr(
            "range",
            parser=MPDParsers.range,
        )

    def xǁInitializationǁ__init____mutmut_7(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.source_url = self.attr("SOURCEURL")
        self.range = self.attr(
            "range",
            parser=MPDParsers.range,
        )

    def xǁInitializationǁ__init____mutmut_8(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.source_url = self.attr("Sourceurl")
        self.range = self.attr(
            "range",
            parser=MPDParsers.range,
        )

    def xǁInitializationǁ__init____mutmut_9(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.source_url = self.attr("sourceURL")
        self.range = None

    def xǁInitializationǁ__init____mutmut_10(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.source_url = self.attr("sourceURL")
        self.range = self.attr(
            None,
            parser=MPDParsers.range,
        )

    def xǁInitializationǁ__init____mutmut_11(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.source_url = self.attr("sourceURL")
        self.range = self.attr(
            "range",
            parser=None,
        )

    def xǁInitializationǁ__init____mutmut_12(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.source_url = self.attr("sourceURL")
        self.range = self.attr(
            parser=MPDParsers.range,
        )

    def xǁInitializationǁ__init____mutmut_13(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.source_url = self.attr("sourceURL")
        self.range = self.attr(
            "range",
            )

    def xǁInitializationǁ__init____mutmut_14(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.source_url = self.attr("sourceURL")
        self.range = self.attr(
            "XXrangeXX",
            parser=MPDParsers.range,
        )

    def xǁInitializationǁ__init____mutmut_15(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.source_url = self.attr("sourceURL")
        self.range = self.attr(
            "RANGE",
            parser=MPDParsers.range,
        )

    def xǁInitializationǁ__init____mutmut_16(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.source_url = self.attr("sourceURL")
        self.range = self.attr(
            "Range",
            parser=MPDParsers.range,
        )
    
    xǁInitializationǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁInitializationǁ__init____mutmut_1': xǁInitializationǁ__init____mutmut_1, 
        'xǁInitializationǁ__init____mutmut_2': xǁInitializationǁ__init____mutmut_2, 
        'xǁInitializationǁ__init____mutmut_3': xǁInitializationǁ__init____mutmut_3, 
        'xǁInitializationǁ__init____mutmut_4': xǁInitializationǁ__init____mutmut_4, 
        'xǁInitializationǁ__init____mutmut_5': xǁInitializationǁ__init____mutmut_5, 
        'xǁInitializationǁ__init____mutmut_6': xǁInitializationǁ__init____mutmut_6, 
        'xǁInitializationǁ__init____mutmut_7': xǁInitializationǁ__init____mutmut_7, 
        'xǁInitializationǁ__init____mutmut_8': xǁInitializationǁ__init____mutmut_8, 
        'xǁInitializationǁ__init____mutmut_9': xǁInitializationǁ__init____mutmut_9, 
        'xǁInitializationǁ__init____mutmut_10': xǁInitializationǁ__init____mutmut_10, 
        'xǁInitializationǁ__init____mutmut_11': xǁInitializationǁ__init____mutmut_11, 
        'xǁInitializationǁ__init____mutmut_12': xǁInitializationǁ__init____mutmut_12, 
        'xǁInitializationǁ__init____mutmut_13': xǁInitializationǁ__init____mutmut_13, 
        'xǁInitializationǁ__init____mutmut_14': xǁInitializationǁ__init____mutmut_14, 
        'xǁInitializationǁ__init____mutmut_15': xǁInitializationǁ__init____mutmut_15, 
        'xǁInitializationǁ__init____mutmut_16': xǁInitializationǁ__init____mutmut_16
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁInitializationǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁInitializationǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁInitializationǁ__init____mutmut_orig)
    xǁInitializationǁ__init____mutmut_orig.__name__ = 'xǁInitializationǁ__init__'


class SegmentURL(MPDNode):
    __tag__ = "SegmentURL"

    def xǁSegmentURLǁ__init____mutmut_orig(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.media = self.attr("media")
        self.media_range = self.attr(
            "mediaRange",
            parser=MPDParsers.range,
        )

    def xǁSegmentURLǁ__init____mutmut_1(self, *args, **kwargs) -> None:
        super().__init__(**kwargs)

        self.media = self.attr("media")
        self.media_range = self.attr(
            "mediaRange",
            parser=MPDParsers.range,
        )

    def xǁSegmentURLǁ__init____mutmut_2(self, *args, **kwargs) -> None:
        super().__init__(*args, )

        self.media = self.attr("media")
        self.media_range = self.attr(
            "mediaRange",
            parser=MPDParsers.range,
        )

    def xǁSegmentURLǁ__init____mutmut_3(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.media = None
        self.media_range = self.attr(
            "mediaRange",
            parser=MPDParsers.range,
        )

    def xǁSegmentURLǁ__init____mutmut_4(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.media = self.attr(None)
        self.media_range = self.attr(
            "mediaRange",
            parser=MPDParsers.range,
        )

    def xǁSegmentURLǁ__init____mutmut_5(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.media = self.attr("XXmediaXX")
        self.media_range = self.attr(
            "mediaRange",
            parser=MPDParsers.range,
        )

    def xǁSegmentURLǁ__init____mutmut_6(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.media = self.attr("MEDIA")
        self.media_range = self.attr(
            "mediaRange",
            parser=MPDParsers.range,
        )

    def xǁSegmentURLǁ__init____mutmut_7(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.media = self.attr("Media")
        self.media_range = self.attr(
            "mediaRange",
            parser=MPDParsers.range,
        )

    def xǁSegmentURLǁ__init____mutmut_8(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.media = self.attr("media")
        self.media_range = None

    def xǁSegmentURLǁ__init____mutmut_9(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.media = self.attr("media")
        self.media_range = self.attr(
            None,
            parser=MPDParsers.range,
        )

    def xǁSegmentURLǁ__init____mutmut_10(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.media = self.attr("media")
        self.media_range = self.attr(
            "mediaRange",
            parser=None,
        )

    def xǁSegmentURLǁ__init____mutmut_11(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.media = self.attr("media")
        self.media_range = self.attr(
            parser=MPDParsers.range,
        )

    def xǁSegmentURLǁ__init____mutmut_12(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.media = self.attr("media")
        self.media_range = self.attr(
            "mediaRange",
            )

    def xǁSegmentURLǁ__init____mutmut_13(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.media = self.attr("media")
        self.media_range = self.attr(
            "XXmediaRangeXX",
            parser=MPDParsers.range,
        )

    def xǁSegmentURLǁ__init____mutmut_14(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.media = self.attr("media")
        self.media_range = self.attr(
            "mediarange",
            parser=MPDParsers.range,
        )

    def xǁSegmentURLǁ__init____mutmut_15(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.media = self.attr("media")
        self.media_range = self.attr(
            "MEDIARANGE",
            parser=MPDParsers.range,
        )

    def xǁSegmentURLǁ__init____mutmut_16(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.media = self.attr("media")
        self.media_range = self.attr(
            "Mediarange",
            parser=MPDParsers.range,
        )
    
    xǁSegmentURLǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁSegmentURLǁ__init____mutmut_1': xǁSegmentURLǁ__init____mutmut_1, 
        'xǁSegmentURLǁ__init____mutmut_2': xǁSegmentURLǁ__init____mutmut_2, 
        'xǁSegmentURLǁ__init____mutmut_3': xǁSegmentURLǁ__init____mutmut_3, 
        'xǁSegmentURLǁ__init____mutmut_4': xǁSegmentURLǁ__init____mutmut_4, 
        'xǁSegmentURLǁ__init____mutmut_5': xǁSegmentURLǁ__init____mutmut_5, 
        'xǁSegmentURLǁ__init____mutmut_6': xǁSegmentURLǁ__init____mutmut_6, 
        'xǁSegmentURLǁ__init____mutmut_7': xǁSegmentURLǁ__init____mutmut_7, 
        'xǁSegmentURLǁ__init____mutmut_8': xǁSegmentURLǁ__init____mutmut_8, 
        'xǁSegmentURLǁ__init____mutmut_9': xǁSegmentURLǁ__init____mutmut_9, 
        'xǁSegmentURLǁ__init____mutmut_10': xǁSegmentURLǁ__init____mutmut_10, 
        'xǁSegmentURLǁ__init____mutmut_11': xǁSegmentURLǁ__init____mutmut_11, 
        'xǁSegmentURLǁ__init____mutmut_12': xǁSegmentURLǁ__init____mutmut_12, 
        'xǁSegmentURLǁ__init____mutmut_13': xǁSegmentURLǁ__init____mutmut_13, 
        'xǁSegmentURLǁ__init____mutmut_14': xǁSegmentURLǁ__init____mutmut_14, 
        'xǁSegmentURLǁ__init____mutmut_15': xǁSegmentURLǁ__init____mutmut_15, 
        'xǁSegmentURLǁ__init____mutmut_16': xǁSegmentURLǁ__init____mutmut_16
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁSegmentURLǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁSegmentURLǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁSegmentURLǁ__init____mutmut_orig)
    xǁSegmentURLǁ__init____mutmut_orig.__name__ = 'xǁSegmentURLǁ__init__'


class ContentProtection(MPDNode):
    __tag__ = "ContentProtection"

    def xǁContentProtectionǁ__init____mutmut_orig(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("schemeIdUri")
        self.value = self.attr("value")
        self.default_KID = self.attr("default_KID")

    def xǁContentProtectionǁ__init____mutmut_1(self, *args, **kwargs) -> None:
        super().__init__(**kwargs)

        self.schemeIdUri = self.attr("schemeIdUri")
        self.value = self.attr("value")
        self.default_KID = self.attr("default_KID")

    def xǁContentProtectionǁ__init____mutmut_2(self, *args, **kwargs) -> None:
        super().__init__(*args, )

        self.schemeIdUri = self.attr("schemeIdUri")
        self.value = self.attr("value")
        self.default_KID = self.attr("default_KID")

    def xǁContentProtectionǁ__init____mutmut_3(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = None
        self.value = self.attr("value")
        self.default_KID = self.attr("default_KID")

    def xǁContentProtectionǁ__init____mutmut_4(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr(None)
        self.value = self.attr("value")
        self.default_KID = self.attr("default_KID")

    def xǁContentProtectionǁ__init____mutmut_5(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("XXschemeIdUriXX")
        self.value = self.attr("value")
        self.default_KID = self.attr("default_KID")

    def xǁContentProtectionǁ__init____mutmut_6(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("schemeiduri")
        self.value = self.attr("value")
        self.default_KID = self.attr("default_KID")

    def xǁContentProtectionǁ__init____mutmut_7(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("SCHEMEIDURI")
        self.value = self.attr("value")
        self.default_KID = self.attr("default_KID")

    def xǁContentProtectionǁ__init____mutmut_8(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("Schemeiduri")
        self.value = self.attr("value")
        self.default_KID = self.attr("default_KID")

    def xǁContentProtectionǁ__init____mutmut_9(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("schemeIdUri")
        self.value = None
        self.default_KID = self.attr("default_KID")

    def xǁContentProtectionǁ__init____mutmut_10(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("schemeIdUri")
        self.value = self.attr(None)
        self.default_KID = self.attr("default_KID")

    def xǁContentProtectionǁ__init____mutmut_11(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("schemeIdUri")
        self.value = self.attr("XXvalueXX")
        self.default_KID = self.attr("default_KID")

    def xǁContentProtectionǁ__init____mutmut_12(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("schemeIdUri")
        self.value = self.attr("VALUE")
        self.default_KID = self.attr("default_KID")

    def xǁContentProtectionǁ__init____mutmut_13(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("schemeIdUri")
        self.value = self.attr("Value")
        self.default_KID = self.attr("default_KID")

    def xǁContentProtectionǁ__init____mutmut_14(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("schemeIdUri")
        self.value = self.attr("value")
        self.default_KID = None

    def xǁContentProtectionǁ__init____mutmut_15(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("schemeIdUri")
        self.value = self.attr("value")
        self.default_KID = self.attr(None)

    def xǁContentProtectionǁ__init____mutmut_16(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("schemeIdUri")
        self.value = self.attr("value")
        self.default_KID = self.attr("XXdefault_KIDXX")

    def xǁContentProtectionǁ__init____mutmut_17(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("schemeIdUri")
        self.value = self.attr("value")
        self.default_KID = self.attr("default_kid")

    def xǁContentProtectionǁ__init____mutmut_18(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("schemeIdUri")
        self.value = self.attr("value")
        self.default_KID = self.attr("DEFAULT_KID")

    def xǁContentProtectionǁ__init____mutmut_19(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.schemeIdUri = self.attr("schemeIdUri")
        self.value = self.attr("value")
        self.default_KID = self.attr("Default_kid")
    
    xǁContentProtectionǁ__init____mutmut_mutants : ClassVar[MutantDict] = {
    'xǁContentProtectionǁ__init____mutmut_1': xǁContentProtectionǁ__init____mutmut_1, 
        'xǁContentProtectionǁ__init____mutmut_2': xǁContentProtectionǁ__init____mutmut_2, 
        'xǁContentProtectionǁ__init____mutmut_3': xǁContentProtectionǁ__init____mutmut_3, 
        'xǁContentProtectionǁ__init____mutmut_4': xǁContentProtectionǁ__init____mutmut_4, 
        'xǁContentProtectionǁ__init____mutmut_5': xǁContentProtectionǁ__init____mutmut_5, 
        'xǁContentProtectionǁ__init____mutmut_6': xǁContentProtectionǁ__init____mutmut_6, 
        'xǁContentProtectionǁ__init____mutmut_7': xǁContentProtectionǁ__init____mutmut_7, 
        'xǁContentProtectionǁ__init____mutmut_8': xǁContentProtectionǁ__init____mutmut_8, 
        'xǁContentProtectionǁ__init____mutmut_9': xǁContentProtectionǁ__init____mutmut_9, 
        'xǁContentProtectionǁ__init____mutmut_10': xǁContentProtectionǁ__init____mutmut_10, 
        'xǁContentProtectionǁ__init____mutmut_11': xǁContentProtectionǁ__init____mutmut_11, 
        'xǁContentProtectionǁ__init____mutmut_12': xǁContentProtectionǁ__init____mutmut_12, 
        'xǁContentProtectionǁ__init____mutmut_13': xǁContentProtectionǁ__init____mutmut_13, 
        'xǁContentProtectionǁ__init____mutmut_14': xǁContentProtectionǁ__init____mutmut_14, 
        'xǁContentProtectionǁ__init____mutmut_15': xǁContentProtectionǁ__init____mutmut_15, 
        'xǁContentProtectionǁ__init____mutmut_16': xǁContentProtectionǁ__init____mutmut_16, 
        'xǁContentProtectionǁ__init____mutmut_17': xǁContentProtectionǁ__init____mutmut_17, 
        'xǁContentProtectionǁ__init____mutmut_18': xǁContentProtectionǁ__init____mutmut_18, 
        'xǁContentProtectionǁ__init____mutmut_19': xǁContentProtectionǁ__init____mutmut_19
    }
    
    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(object.__getattribute__(self, "xǁContentProtectionǁ__init____mutmut_orig"), object.__getattribute__(self, "xǁContentProtectionǁ__init____mutmut_mutants"), args, kwargs, self)
        return result 
    
    __init__.__signature__ = _mutmut_signature(xǁContentProtectionǁ__init____mutmut_orig)
    xǁContentProtectionǁ__init____mutmut_orig.__name__ = 'xǁContentProtectionǁ__init__'
